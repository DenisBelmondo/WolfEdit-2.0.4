unit UMapBSPTree;interface	uses		HexIO, UDrawing, UMapParams, ULevel;	procedure MapBSPTree (level: LevelHandle;									layers: MapLayers;									vis: Rect);implementation	var		level: LevelHandle;		base: longint;		vis: Rect;	function BSPCoord (x: integer): integer;	begin		BSPCoord := margin + x * (cellSize div 2);	end;	procedure MapBSPTree (level: LevelHandle;									layers: MapLayers;									vis: Rect);		function Visible (r: Rect): boolean;		begin			InsetRect(r, -segMargin, -segMargin);			Visible := SectRect(vis, r, r);		end;		procedure DrawHSplit (r: Rect;										split: integer);		begin			r.top := split - splitThick;			r.bottom := split + splitThick;			FillRect(r, hSplitPat);		end;		procedure DrawVSplit (r: Rect;										split: integer);		begin			r.left := split - splitThick;			r.right := split + splitThick;			FillRect(r, vSplitPat);		end;		procedure SplitRect (r: Rect;										e: BSPEntry;										var r0, r1: Rect);			var				split: integer;		begin			split := BSPCoord(e.coord0);			r0 := r;			r1 := r;			case BAND(e.flags, bspSplitDir) of				bspSplitH:  begin						if splitLayer in layers then							DrawHSplit(r, split);						r0.bottom := split;						r1.top := split;					end;				bspSplitV:  begin						if splitLayer in layers then							DrawVSplit(r, split);						r0.right := split;						r1.left := split;					end;			end;			if EmptyRect(r0) | EmptyRect(r1) then				SysBeep(5);		end;		procedure MapSegments (n: integer;										r: Rect);			var				e: BSPEntry;				stop: boolean;				c0, c1, c2, dir: integer;				s, s2: Rect;				p: Point;		begin			stop := false;			while not stop do begin					GetBSPEntry(level, n, e);					n := n + 1;					c0 := BSPCoord(e.coord0);					c1 := BSPCoord(e.coord1);					c2 := BSPCoord(e.coord2);					dir := BAND(e.flags, bspSegType);					case dir of						bspFaceNorth: 							SetRect(s, c1, c0, c2, c0 + segThick);						bspFaceSouth: 							SetRect(s, c1, c0 - segThick, c2, c0);						bspFaceWest: 							SetRect(s, c0, c1, c0 + segThick, c2);						bspFaceEast: 							SetRect(s, c0 - segThick, c1, c0, c2);						otherwise							;					end;					if segLayer in layers then begin							FillRect(s, black);							s2 := s;							InsetRect(s2, segBorder, segBorder);							case dir of								bspFaceNorth: 									s2.bottom := s2.bottom + segBorder;								bspFaceSouth: 									s2.top := s2.top - segBorder;								bspFaceEast: 									s2.left := s2.left - segBorder;								bspFaceWest: 									s2.right := s2.right + segBorder;								otherwise									;							end;							FillRect(s2, segPat);						end;					if segCodeLayer in layers then begin							SetPt(p, (s.right + s.left) div 2, (s.top + s.bottom) div 2);							case dir of								bspFaceNorth, bspFaceSouth:  begin										MoveTo(p.h - fontSize, p.v);										BoxText(Hex(e.grid, 2));										MoveTo(p.h + fontSize, p.v);										BoxText(Hex(e.area, 2));									end;								bspFaceEast, bspFaceWest:  begin										MoveTo(p.h, p.v - fontSize);										BoxText(Hex(e.grid, 2));										MoveTo(p.h, p.v + fontSize);										BoxText(Hex(e.area, 2));									end;							end;						end;					if BAND(e.flags, bspLastSeg) <> 0 then						stop := true;				end;		end;		procedure MapNode (n: integer;										r: Rect);			var				e: BSPEntry;				r0, r1: Rect;		begin			if Visible(r) then begin					GetBSPEntry(level, n, e);					if BAND(e.flags, bspTerminal) <> 0 then begin							if layers * [segLayer, segCodeLayer] <> [] then								MapSegments(n, r);						end					else begin							SplitRect(r, e, r0, r1);							MapNode(BigEndian(e.links[0]), r1);							MapNode(BigEndian(e.links[1]), r0);						end;				end;		end;		procedure MapRoot;			var				r0: Rect;				c0, c1: integer;		begin			PenNormal;			c0 := BSPCoord(0);			c1 := BSPCoord(128);			SetRect(r0, c0, c0, c1, c1);			MapNode(0, r0);		end;	begin		if layers * [splitLayer, segLayer, segCodeLayer] <> [] then			MapRoot;	end;end.