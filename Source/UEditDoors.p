unit UEditDoors;interface	uses		UWolfDoc;	procedure EditDoors (mapList: TMapListDoc);implementation	uses		UEditArt, ULZSS;	const		doorEditDlogID = 132;		shadeItem = 5;		mirrorItem = 6;		doorSideObjectCode = $FE;	type		TDoorImagePalette = object(TImagePalette)				procedure IDoorImagePalette;				procedure DrawImage (itemNo: integer; r: Rect);				override;			end;		TDoorEditDialog = object(TArtEditDialog)				procedure IDoorEditDialog (itsMapList: TMapListDoc);				procedure UninstallArt;				override;				procedure InstallArt;				override;				function ArtImageType: CustomImageType;				override;				function ArtImageCode: integer;				override;				procedure ChangeImage (gworld: GWorldPtr; isThumbnail: boolean);				override;			end;	function DoorObjectCode (itemNo: integer): integer;	begin		if itemNo < 4 then			DoorObjectCode := $5A + 2 * itemNo		else			DoorObjectCode := doorSideObjectCode;	end;	function DoorImageCode (itemNo: integer): integer;		var			code: integer;	begin		code := DoorObjectCode(itemNo);		if itemNo < 4 then			code := code + 1;		DoorImageCode := code;	end;	procedure TDoorImagePalette.IDoorImagePalette;	begin		IImagePalette(5, 5);		fDialog := nil;	end;	procedure TDoorImagePalette.DrawImage (itemNo: integer; r: Rect);	begin		fDialog.fMapList.PlotObject(DoorImageCode(itemNo), 0, r);	end;	procedure TDoorEditDialog.IDoorEditDialog (itsMapList: TMapListDoc);		var			palette: TDoorImagePalette;	begin		new(palette);		palette.IDoorImagePalette;		IArtEditDialog(doorEditDlogID, palette, itsMapList, true);		palette.fDialog := self;	end;	procedure TDoorEditDialog.UninstallArt;		var			wal: WallArtListHandle;		procedure Uninstall (var this: WallArtListEntry);		begin			if fArtView.fChanged then begin					if this.art <> nil then						DisposHandle(this.art);					this.art := fArtView.ExtractWall;					fMapList.Changed;					fArtView.fChanged := false;				end;			UninstallFlag(this.darkFlag, shadeItem);			UninstallFlag(this.mirrorFlag, mirrorItem);		end;	begin {TDoorEditDialog.UninstallDoor}		if fCurrentArt >= 0 then begin				wal := fMapList.GetWallArtList;				HLock(Handle(wal));				Uninstall(wal^^[59 + fCurrentArt]);				HUnlock(Handle(wal));			end;	end;	procedure TDoorEditDialog.InstallArt;		procedure Install (this: WallArtListEntry);		begin			fArtView.InstallWall(this.art);			InstallFlag(this.darkFlag, shadeItem);			InstallFlag(this.mirrorFlag, mirrorItem);		end;	begin {TDoorEditDialog.InstallArt}		if fCurrentArt >= 0 then			Install(fMapList.GetWallArtList^^[59 + fCurrentArt]);	end;	function TDoorEditDialog.ArtImageType: CustomImageType;	begin		ArtImageType := objectImage;	end;	function TDoorEditDialog.ArtImageCode: integer;	begin		ArtImageCode := DoorImageCode(fCurrentArt);	end;	procedure TDoorEditDialog.ChangeImage (gworld: GWorldPtr; isThumbnail: boolean);		var			buffer: packed array[0..127, 0..127] of 0..255;			pixels: Ptr;			width, height, bytes: longint;			code: integer;			shrink: boolean;	begin		code := ArtImageCode;		if gworld <> nil then begin				pixels := GetPixBaseAddr(GetGWorldPixMap(gworld));				width := gworld^.portRect.right;				height := gworld^.portRect.bottom;				bytes := width * height;				shrink := (not isThumbnail) and (fCurrentArt < 4);				ChangeDoorImage(code, gworld, shrink);				if fCurrentArt < 4 then begin						BlockMove(pixels, @buffer, bytes);						TransposePixels(@buffer, pixels, width, height);						ChangeDoorImage(code - 1, gworld, shrink);						BlockMove(@buffer, pixels, bytes);					end;			end		else begin				ChangeDoorImage(code + 1, nil, false);				ChangeDoorImage(code, nil, false);			end;	end;	procedure EditDoors (mapList: TMapListDoc);		var			dlog: TDoorEditDialog;		procedure CheckWindow (win: TWindow);		begin			if member(win, TDoorEditDialog) then begin					win.Select;					exit(EditDoors);				end;		end;	begin		mapList.EachWindowDo(CheckWindow);		new(dlog);		dlog.IDoorEditDialog(mapList);		dlog.Show;	end;end.