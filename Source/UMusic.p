unit UMusic;interface	uses		UWolfDoc;	function SongIDToMenuItem (id: integer; extraMusic: TMusicRsrcList): integer;	function MenuItemToSongID (item: integer; extraMusic: TMusicRsrcList): integer;	function DefaultTitleMusic: integer;	function DefaultBetweenLevelsMusic: integer;	function DefaultLevelMusic: integer;	procedure SetUpMusicMenu (encounter: integer; extraMusic: TMusicRsrcList);	procedure ImportMusic (mapList: TMapListDoc);	procedure EditMusic (mapList: TMapListDoc);	procedure IUMusic;implementation	uses		UGoof, UDialog, UList, UScrap;	const		songListID = 128;		musicMenuID = 138;		couldntImportMusicAlrtID = 162;		replaceMusicAlrtID = 163;		noMemAlrtID = 148;		defaultTitleMusicItem = 3;		defaultBetweenLevelsMusicItem = 4;		defaultLevelMusicItem = 5;		musicListDlogID = 142;		musicListItem = 1;		importMusicItem = 2;	type		SongListEntry = record				encounter: integer;				songID: integer;			end;		SongListHandle = ^SongListPtr;		SongListPtr = ^SongListRecord;		SongListRecord = record				numSongs: integer;				entries: array[1..999] of SongListEntry;			end;	var		gSongList: SongListHandle;	function GetSongList (id: integer): SongListHandle;	begin		GetSongList := SongListHandle(GetResource('MUS#', id));	end;	function SongIDToMenuItem (id: integer; extraMusic: TMusicRsrcList): integer;		var			i: integer;			p: TMusicRsrcList;	begin		i := 1;		with gSongList^^ do			while i <= numSongs do begin					if entries[i].songID = id then begin							SongIDToMenuItem := i + 2;							exit(SongIDToMenuItem);						end;					i := i + 1;				end;		i := i + 1;		p := extraMusic;		while p <> nil do begin				if p.id = id then begin						SongIDToMenuItem := i + 2;						exit(SongIDToMenuItem);					end;				i := i + 1;				p := p.next;			end;		SongIDToMenuItem := 0;	end;	function MenuItemToSongID (item: integer; extraMusic: TMusicRsrcList): integer;		var			p: TMusicRsrcList;	begin		MenuItemToSongID := 0;		item := item - 2;		if item >= 1 then begin				if item <= gSongList^^.numSongs then					MenuItemToSongID := gSongList^^.entries[item].songID				else begin						item := item - gSongList^^.numSongs - 1;						p := extraMusic;						while (item > 1) & (p <> nil) do begin								p := p.next;								item := item - 1;							end;						if p <> nil then							MenuItemToSongID := p.id;					end;			end;	end;	function DefaultTitleMusic: integer;	begin		DefaultTitleMusic := MenuItemToSongID(defaultTitleMusicItem, nil);	end;	function DefaultBetweenLevelsMusic: integer;	begin		DefaultBetweenLevelsMusic := MenuItemToSongID(defaultBetweenLevelsMusicItem, nil);	end;	function DefaultLevelMusic: integer;	begin		DefaultLevelMusic := MenuItemToSongID(defaultLevelMusicItem, nil);	end;	procedure SetUpMusicMenu (encounter: integer; extraMusic: TMusicRsrcList);		var			i, nMenu, nBuiltIn: integer;			m: MenuHandle;			p: TMusicRsrcList;	begin		m := GetMenu(musicMenuID);		nMenu := CountMItems(m);		nBuiltIn := gSongList^^.numSongs + 2;		while nMenu > nBuiltIn do begin				DelMenuItem(m, nMenu);				nMenu := nMenu - 1;			end;		for i := 1 to gSongList^^.numSongs do			if encounter < gSongList^^.entries[i].encounter then				DisableItem(m, i + 2)			else				EnableItem(m, i + 2);		if extraMusic <> nil then begin				AppendMenu(m, '(-');				p := extraMusic;				while p <> nil do begin						AppendMenu(m, p.name);						EnableItem(m, CountMItems(m));						p := p.next;					end;			end;	end;	procedure DisposeMusic (p: TMusicRsrcList);	begin		if p <> nil then begin				DisposHandle(p.song);				DisposHandle(p.midi);				dispose(p);			end;	end;	function AddMusic (mapList: TMapListDoc; name: string; midi: Handle): OSErr;		var			i: integer;			p: TMusicRsrcList;		procedure Check (result: OSErr);		begin			if result <> noErr then begin					DisposeMusic(p);					DisposHandle(midi);					AddMusic := result;					exit(AddMusic);				end;		end;	begin {AddMusic}		i := 256;		p := mapList.fMusic;		while p <> nil do begin				if p.id >= i then					i := p.id + 1;				p := p.next;			end;		p := nil;		new(p);		Check(MemError);		p.id := i;		p.name := name;		p.midi := midi;		midi := nil;		p.song := GetResource('SONG', 128);		Check(ResError);		DetachResource(p.song);		p.next := mapList.fMusic;		mapList.fMusic := p;		mapList.Changed;		AddMusic := noErr;	end;	function ReplaceMusic (mapList: TMapListDoc; p: TMusicRsrcList; midi: Handle): OSErr;		var			old: Handle;	begin		ParamText(p.name, '', '', '');		if Ask(replaceMusicAlrtID) = ok then begin				old := p.midi;				p.midi := midi;				DisposHandle(old);				mapList.Changed;			end		else			DisposHandle(midi);		ReplaceMusic := noErr;	end;	procedure RemoveMusic (mapList: TMapListDoc; music: TMusicRsrcList);		var			p: TMusicRsrcList;	begin		if music = mapList.fMusic then			mapList.fMusic := music.next		else begin				p := mapList.fMusic;				while (p <> nil) & (p.next <> music) do					p := p.next;				if p <> nil then					p.next := music.next;			end;		DisposHandle(music.song);		DisposHandle(music.midi);		dispose(music);		mapList.Changed;	end;	function InstallMusic (mapList: TMapListDoc; name: string; midi: Handle): OSErr;		var			p: TMusicRsrcList;	begin		p := mapList.fMusic;		while p <> nil do begin				if p.name = name then begin						InstallMusic := ReplaceMusic(mapList, p, midi);						exit(InstallMusic);					end;				p := p.next;			end;		InstallMusic := AddMusic(mapList, name, midi);	end;{$IFC NOT Demo}	procedure ImportMusic (mapList: TMapListDoc);		var			reply: StandardFileReply;			types: SFTypeList;			refNum: integer;			midi: Handle;			size: longint;		procedure Check (result: OSErr);			var				junk: OSErr;		begin			if result <> noErr then begin					ErrorAlert(couldntImportMusicAlrtID, reply.sfFile.name, result);					if refNum <> 0 then						junk := FSClose(refNum);					DisposHandle(midi);					exit(ImportMusic);				end;		end;	begin {ImportMusic}		midi := nil;		refNum := 0;		types[0] := 'MIDI';		types[1] := 'Midi';		types[2] := 'midi';		StandardGetFile(nil, 3, types, reply);		if reply.sfGood then begin				Check(MemError);				Check(FSpOpenDF(reply.sfFile, fsRdPerm, refNum));				Check(GetEOF(refNum, size));				midi := NewHandle(size);				Check(MemError);				HLock(midi);				Check(FSRead(refNum, size, midi^));				HUnlock(midi);				Check(FSClose(refNum));				Check(InstallMusic(mapList, reply.sfFile.name, midi));			end;	end;	type		TMusicListWindow = object(TDialog)				fMapList: TMapListDoc;				fMusicListView: TMusicListView;				procedure IMusicListWindow (itsMapList: TMapListDoc);				procedure ItemHit (var e: EventInfo; itemNo: integer);				override;				procedure UpdateTitle;				override;			end;		TMusicListView = object(TList)				fMapList: TMapListDoc;				procedure IMusicListView (itsMapList: TMapListDoc);				procedure SetupMenus;				override;				procedure DoMenuCommand (cmdNumber: integer);				override;				procedure DrawCell (cell: Point; r: Rect; var hilite: boolean);				override;				procedure DoCopy;				procedure DoPaste;				procedure DoClear;				procedure DoImportMusic;				function CurrentMusic: integer;				function GetMusic (index: integer): TMusicRsrcList;				procedure UpdateDimensions;			end;	procedure TMusicListWindow.IMusicListWindow (itsMapList: TMapListDoc);		var			musicListView: TMusicListView;	begin		fMapList := itsMapList;		IDocGetNewDialog(itsMapList, musicListDlogID);		new(musicListView);		musicListView.IMusicListView(itsMapList);		fMusicListView := musicListView;		InstallItemView(musicListItem, fMusicListView, [frmBorder, frmVScroll]);		fTarget := fMusicListView;	end;	procedure TMusicListWindow.ItemHit (var e: EventInfo; itemNo: integer);	begin		case itemNo of			importMusicItem: 				fMusicListView.DoImportMusic;			otherwise				inherited ItemHit(e, itemNo);		end;	end;	procedure TMusicListWindow.UpdateTitle;	begin		SetTitle(concat('Music from ', fMapList.fFileName));	end;	procedure TMusicListView.IMusicListView (itsMapList: TMapListDoc);	begin		fMapList := itsMapList;		IList(500, 16, 1, 0, 0, []);		UpdateDimensions;	end;	procedure TMusicListView.SetupMenus;	begin		inherited SetupMenus;		if CurrentMusic > 0 then begin				EnableCmd(cutCmd);				EnableCmd(copyCmd);				EnableCmd(clearCmd);			end		else begin				DisableCmd(cutCmd);				DisableCmd(copyCmd);				DisableCmd(clearCmd);			end;		if ProbeScrap('midi') then			EnableCmd(pasteCmd)		else			DisableCmd(pasteCmd);	end;	procedure TMusicListView.DoMenuCommand (cmdNumber: integer);	begin		case cmdNumber of			cutCmd:  begin					DoCopy;					DoClear;				end;			copyCmd: 				DoCopy;			pasteCmd: 				DoPaste;			clearCmd: 				DoClear;			otherwise				inherited DoMenuCommand(cmdNumber);		end;	end;	procedure TMusicListView.DrawCell (cell: Point; r: Rect; var hilite: boolean);		var			music: TMusicRsrcList;	begin		music := GetMusic(cell.v + 1);		if music <> nil then begin				TextFont(geneva);				TextSize(12);				TextFace([]);				if hilite then begin						FillRect(r, black);						TextMode(srcBic);						hilite := false;					end				else begin						EraseRect(r);						TextMode(srcOr);					end;				MoveTo(r.left + 5, r.bottom - 4);				DrawString(music.name);			end;	end;	procedure TMusicListView.DoCopy;		var			music: TMusicRsrcList;			nameH: Handle;	begin		music := GetMusic(CurrentMusic);		ClearScrap;		WriteScrap('midi', music.midi);		nameH := NewHandle(length(music.name));		BlockMove(@music.name[1], nameH^, length(music.name));		WriteScrap('TEXT', nameH);		DisposHandle(nameH);	end;	procedure TMusicListView.DoPaste;		var			oldMusic: TMusicRsrcList;			newMidi: Handle;			nameH: Handle;			name: string;			result: OSErr;	begin		ReadScrap('midi', newMidi);		ReadScrap('TEXT', nameH);		if nameH <> nil then begin		{$R-}				name[0] := chr(GetHandleSize(nameH));				BlockMove(nameH^, @name[1], ord(name[0]));		{$R+}				DisposHandle(Handle(nameH));			end		else			name := 'Untitled';		result := AddMusic(fMapList, name, newMidi);		if result <> noErr then			DoAlert(noMemAlrtID);		UpdateDimensions;		Invalidate;	end;	procedure TMusicListView.DoClear;		var			music: TMusicRsrcList;	begin		music := GetMusic(CurrentMusic);		RemoveMusic(fMapList, music);		UpdateDimensions;		Invalidate;	end;	procedure TMusicListView.DoImportMusic;	begin		ImportMusic(fMapList);		UpdateDimensions;		Invalidate;	end;	function TMusicListView.CurrentMusic: integer;	begin		if EmptyRect(fSelection) then			CurrentMusic := 0		else			CurrentMusic := fSelection.bottom;	end;	function TMusicListView.GetMusic (index: integer): TMusicRsrcList;		var			i: integer;			music: TMusicRsrcList;	begin		music := fMapList.fMusic;		i := 1;		while (i <> index) and (music <> nil) do begin				i := i + 1;				music := music.next;			end;		GetMusic := music;	end;	procedure TMusicListView.UpdateDimensions;		var			n: integer;			p: TMusicRsrcList;	begin		n := 0;		p := fMapList.fMusic;		while p <> nil do begin				n := n + 1;				p := p.next;			end;		SetDimensions(0, 0, 1, n);	end;{$ENDC}{$IFC Demo}	procedure EditMusic (mapList: TMapListDoc);	begin	end;{$ELSEC}	procedure EditMusic (mapList: TMapListDoc);		var			mw: TMusicListWindow;		procedure TestWindow (win: TWindow);		begin			if member(win, TMusicListWindow) then begin					win.Select;					exit(EditMusic);				end;		end;	begin {EditMusic}		mapList.EachWindowDo(TestWindow);		new(mw);		mw.IMusicListWindow(mapList);		mw.Select;	end;{$ENDC}	procedure IUMusic;	begin		gSongList := GetSongList(songListID);	end;end.