unit UCTables;interface	uses		UWolfDoc;	const		titleCTabID = 134;		getPsychedCTabID = 145; {?}		intermissionCTabID = 140;		gameCTabID = 145;	type		WolfCTab = packed array[0..767] of 0..255;		WolfCTabPtr = ^WolfCTab;		WolfCTabHandle = ^WolfCTabPtr;	function WolfToMacCTab (wct: WolfCTabHandle): CTabHandle;	function MacToWolfCTab (ctab: CTabHandle): WolfCTabHandle;	function GetWolfCTab (id: integer): CTabHandle;	function GetMapListCTab (mapList: TMapListDoc; id: integer): CTabHandle;	procedure PutMapListCTab (mapList: TMapListDoc; id: integer; ctab: CTabHandle);	procedure EditColours (mapList: TMapListDoc; cTabID: integer);implementation	uses		Palettes, Picker, UList, UDialog;	const		editColoursDlogID = 143;		coloursItem = 3;		importItem = 4;		exportItem = 5;		systemItem = 6;		editItem = 7;		floorItem = 8;		ceilingItem = 9;		standardItem = 10;		couldntOpenAlrtID = 8194;		badClutFileAlrtID = 149;		darkTableID = 136;	function Extend (x: integer): integer;	begin		Extend := BOR(x, BSL(x, 8));	end;	function Chop (x: integer): integer;	begin		Chop := BAND(BSR(x, 8), $FF);	end;	function WolfToMacCTab (wct: WolfCTabHandle): CTabHandle;		var			mct: CTabHandle;			i: integer;	begin {WolfToMacCTab}		mct := CTabHandle(NewHandle(8 + 256 * sizeof(ColorSpec)));		with mct^^ do begin				ctSeed := GetCTSeed;				ctFlags := 0;				ctSize := 255;				for i := 0 to 255 do begin			{$R-}						ctTable[i].value := i;						ctTable[i].rgb.red := Extend(wct^^[3 * i]);						ctTable[i].rgb.green := Extend(wct^^[3 * i + 1]);						ctTable[i].rgb.blue := Extend(wct^^[3 * i + 2]);			{$R+}					end;			end;		WolfToMacCTab := mct;	end;	function MacToWolfCTab (ctab: CTabHandle): WolfCTabHandle;		var			wct: WolfCTabHandle;			i: integer;	begin		wct := WolfCTabHandle(NewHandle(sizeof(WolfCTab)));		for i := 0 to 255 do	  {$R-}			with ctab^^.ctTable[i].rgb do begin	  {$R+}					wct^^[3 * i] := Chop(red);					wct^^[3 * i + 1] := Chop(green);					wct^^[3 * i + 2] := Chop(blue);				end;		MacToWolfCTab := wct;	end;	function GetWolfCTab (id: integer): CTabHandle;		var			wct: WolfCTabHandle;	begin		wct := WolfCTabHandle(GetResource('BRGR', id));		GetWolfCTab := WolfToMacCTab(wct);	end;	function GetMapListCTab (mapList: TMapListDoc; id: integer): CTabHandle;		var			wct: WolfCTabHandle;	begin		wct := WolfCTabHandle(mapList.GetMiscBrgr(id));		if wct = nil then			wct := WolfCTabHandle(GetResource('BRGR', id));		GetMapListCTab := WolfToMacCTab(wct);	end;	procedure PutMapListCTab (mapList: TMapListDoc; id: integer; ctab: CTabHandle);		var			wct: WolfCTabHandle;	begin		wct := MacToWolfCTab(ctab);		mapList.InstallMiscBrgr(Handle(wct), id);		mapList.Changed;	end;	procedure Ensure256Entries (ctab: CTabHandle);		var			i: integer;	begin		if ctab^^.ctSize <> 255 then begin				SetHandleSize(Handle(ctab), sizeof(ctab^^) + 255 * sizeof(ColorSpec));				for i := ctab^^.ctSize + 1 to 255 do		  {$R-}					with ctab^^.ctTable[i] do begin		  {$R+}							value := i;							rgb.red := 0;							rgb.green := 0;							rgb.blue := 0;						end;			end;	end;	function ImportCTab: CTabHandle;		var			h: Handle;			ctab: CTabHandle;			typeList: SFTypeList;			reply: StandardFileReply;			resFile: integer;	begin		ImportCTab := nil;		ctab := nil;		StandardGetFile(nil, -1, typeList, reply);		if reply.sfGood then begin				resFile := FSpOpenResFile(reply.sfFile, fsRdPerm);				if ResError <> noErr then begin						if ResError <> eofErr then							ErrorAlert(couldntOpenAlrtID, reply.sfFile.name, ResError);					end				else begin						h := Get1IndResource('clut', 1);						ctab := CTabHandle(h);						if h <> nil then							DetachResource(h);						CloseResFile(resFile);						if ctab <> nil then begin								ctab^^.ctSeed := GetCTSeed;								Ensure256Entries(ctab);							end;					end;			end;		if ctab = nil then begin				ParamText(reply.sfFile.name, '', '', '');				DoAlert(badClutFileAlrtID);			end;		ImportCTab := ctab;	end;	procedure ExportCTab (ctab: CTabHandle);		var			resFile: integer;			h: Handle;			typeList: SFTypeList;			reply: StandardFileReply;		procedure Abort;		begin			if resFile <> 0 then				CloseResFile(resFile);			exit(ExportCTab);		end;		procedure BadClutFile;		begin			ParamText(reply.sfFile.name, '', '', '');			DoAlert(badClutFileAlrtID);			Abort;		end;		procedure Check (result: OSErr);		begin			if result <> noErr then begin					if result = eofErr then						BadClutFile					else						ErrorAlert(couldntOpenAlrtID, reply.sfFile.name, result);					Abort;				end;		end;	begin {ExportCTab}		resFile := 0;		StandardGetFile(nil, -1, typeList, reply);		if reply.sfGood then begin				resFile := FSpOpenResFile(reply.sfFile, fsRdWrPerm);				Check(ResError);				h := Get1IndResource('clut', 1);				if h = nil then					BadClutFile;				SetHandleSize(h, GetHandleSize(Handle(ctab)));				BlockMove(Ptr(ctab^), h^, GetHandleSize(h));				ChangedResource(h);				Check(ResError);				CloseResFile(resFile);				Check(ResError);			end;	end;	procedure Darken (var x: integer);		var			lx: longint;	begin		lx := BAND(longint(x), $FFFF);		x := (lx * 3) div 4;	end;	function MakeDarkTable (inTab: CTabHandle): Handle;		type			DarkTabHandle = ^DarkTabPtr;			DarkTabPtr = ^DarkTable;			DarkTable = packed array[0..255] of 0..255;		var			outTab: CTabHandle;			size: longint;			i: integer;			dtab: DarkTabHandle;	begin		size := GetHandleSize(Handle(inTab));		outTab := CTabHandle(NewHandle(size));		BlockMove(Ptr(inTab^), Ptr(outTab^), size);		for i := 0 to outTab^^.ctSize do	  {$R-}			with outTab^^.ctTable[i].rgb do begin	  {$R+}					Darken(red);					Darken(green);					Darken(blue);				end;		GetSubTable(outTab, 4, inTab);		dtab := DarkTabHandle(NewHandle(sizeof(DarkTable)));		for i := 0 to outTab^^.ctSize do	  {$R-}			dtab^^[i] := outTab^^.ctTable[i].value;	  {$R+}		DisposHandle(Handle(outTab));		MakeDarkTable := Handle(dtab);	end;	type		TCTabView = object(TList)				fCTabID: integer;				fCTab: CTabHandle;				fPalette: PaletteHandle;				fChanged: boolean;				procedure ICTabView (mapList: TMapListDoc; cTabID: integer);				procedure Free;				override;				procedure DrawCell (cell: Point; r: Rect; var hilite: boolean);				override;				procedure ChangeCellHilite (cell: Point; hilite: boolean);				override;				procedure DoubleClick (var e: EventInfo);				override;				procedure SetSelectionRect (newSel: Rect);				override;				procedure EditColour;				procedure SwapColour (target: integer);				procedure InstallCTab (newCTab: CTabHandle);				procedure CTabChanged;			end;	procedure TCTabView.ICTabView (mapList: TMapListDoc; cTabID: integer);	begin		IList(16, 16, 16, 16, 1, []);		fCTabID := cTabID;		fCTab := GetMapListCTab(mapList, cTabID);		fPalette := NewPalette(256, fCTab, pmTolerant, 0);		fChanged := false;	end;	procedure TCTabView.Free;	begin		DisposHandle(Handle(fCTab));		DisposePalette(fPalette);		inherited Free;	end;	procedure TCTabView.DrawCell (cell: Point; r: Rect; var hilite: boolean);		var			i: integer;			oldPen: PenState;			c: char;	begin		GetPenState(oldPen);		PenSize(1, 1);		if hilite then			PenPat(black)		else			PenPat(white);		FrameRect(r);		InsetRect(r, 1, 1);		i := cell.v * 16 + cell.h;	{$R-}		RGBForeColor(fCTab^^.ctTable[i].rgb);	{$R+}		FillRect(r, black);		ForeColor(blackColor);		if (fCTabID = gameCTabID) and ((i = $2A) or (i = $2F)) then begin				InsetRect(r, 4, 3);				r.top := r.top - 1;				TextFont(geneva);				TextSize(9);				TextFace([]);				case i of					$2A: 						c := 'F';					$2F:  begin							r.right := r.right + 1;							c := 'C';						end;				end;				EraseRect(r);				MoveTo(r.left + 1, r.bottom - 1);				DrawChar(c);			end;		SetPenState(oldPen);		hilite := false;	end;	procedure TCTabView.ChangeCellHilite (cell: Point; hilite: boolean);		var			r: Rect;			oldPen: PenState;	begin		CellToRect(cell, r);		GetPenState(oldPen);		PenNormal;		PenMode(patXor);		FrameRect(r);		SetPenState(oldPen);	end;	procedure TCTabView.DoubleClick (var e: EventInfo);	begin		EditColour;	end;	procedure TCTabView.SetSelectionRect (newSel: Rect);		var			dlog: TDialog;			enableEdit, enableFC: boolean;	begin		inherited SetSelectionRect(newSel);		enableEdit := not EmptyRect(newSel);		enableFC := enableEdit and (fCTabID = gameCTabID);		dlog := TDialog(fFrame.fWindow);		dlog.EnableItem(editItem, enableEdit);		dlog.EnableItem(floorItem, enableFC);		dlog.EnableItem(ceilingItem, enableFC);	end;	procedure TCTabView.EditColour;		var			i: integer;			newRGB: RGBColor;			where: Point;	begin		if not EmptyRect(fSelection) then begin				i := fSelection.top * 16 + fSelection.left;				SetPt(where, 0, 0);		{$R-}				if GetColor(where, 'Choose a new colour:', fCTab^^.ctTable[i].rgb, newRGB) then begin						fCTab^^.ctTable[i].rgb := newRGB;						CTabChanged;					end;		{$R+}			end;	end;	procedure SwapRGB (var x, y: RGBColor);		var			t: RGBColor;	begin		t := x;		x := y;		y := t;	end;	procedure TCTabView.SwapColour (target: integer);		var			selection: integer;	begin		if not EmptyRect(fSelection) then begin				selection := fSelection.top * 16 + fSelection.left;				with fCTab^^ do		  {$R-}					SwapRGB(ctTable[selection].rgb, ctTable[target].rgb);		  {$R+}				CTabChanged;			end;	end;	procedure TCTabView.InstallCTab (newCTab: CTabHandle);	begin		DisposHandle(Handle(fCTab));		fCTab := newCTab;		CTabChanged;	end;	procedure TCTabView.CTabChanged;	begin		CTab2Palette(fCTab, fPalette, pmTolerant, 0);		ActivatePalette(fFrame.fWindow.fWMgrWindow);		Invalidate;		fChanged := true;	end;	type		TEditColoursDlog = object(TDialog)				fMapList: TMapListDoc;				fCTView: TCTabView;				procedure IEditColoursDialog (mapList: TMapListDoc; cTabID: integer);				procedure ItemHit (var e: EventInfo; itemNo: integer);				override;				procedure DoImport;				procedure DoExport;			end;	procedure TEditColoursDlog.IEditColoursDialog (mapList: TMapListDoc; cTabID: integer);		var			what: string;			ctView: TCTabView;	begin		IGetNewDialog(editColoursDlogID);		case cTabID of			titleCTabID: 				what := 'Title';			gameCTabID: 				what := 'Game';			intermissionCTabID: 				what := 'Intermission';		end;		SetTitle(concat(what, ' Colours from ', mapList.fFileName));		EnableItem(editItem, false);		EnableItem(floorItem, false);		EnableItem(ceilingItem, false);		new(ctView);		ctView.ICTabView(mapList, cTabID);		fCTView := ctView;		InstallItemView(coloursItem, fCTView, [frmBorder]);		SetPalette(fWMgrWindow, fCTView.fPalette, true);	end;	procedure TEditColoursDlog.ItemHit (var e: EventInfo; itemNo: integer);	begin		case itemNo of			importItem: 				DoImport;			exportItem: 				DoExport;			systemItem: 				fCTView.InstallCTab(GetCTable(8));			editItem: 				fCTView.EditColour;			floorItem: 				fCTView.SwapColour($2A);			ceilingItem: 				fCTView.SwapColour($2F);			standardItem: 				fCTView.InstallCTab(GetWolfCTab(fCTView.fCTabID));			otherwise				inherited ItemHit(e, itemNo);		end;	end;	procedure TEditColoursDlog.DoImport;		var			newCTab: CTabHandle;	begin		newCTab := ImportCTab;		if newCTab <> nil then			fCTView.InstallCTab(newCTab);	end;	procedure TEditColoursDlog.DoExport;	begin		ExportCTab(fCTView.fCTab);	end;	procedure EditColours (mapList: TMapListDoc; cTabID: integer);		var			dlog: TEditColoursDlog;			item: integer;			ctab: CTabHandle;	begin		new(dlog);		dlog.IEditColoursDialog(mapList, cTabID);		dlog.Select;		item := dlog.DoModalDialog;		if (item = ok) and (dlog.fCTView.fChanged) then begin				ctab := dlog.fCTView.fCTab;				PutMapListCTab(mapList, cTabID, ctab);				if cTabID = gameCTabID then					mapList.InstallMiscBrgr(MakeDarkTable(ctab), darkTableID);			end;		dlog.Free;	end;end.