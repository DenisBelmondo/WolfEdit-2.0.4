unit UArtView;interface	uses		QDOffscreen, UGoof, UWolfDoc, UPixMapView;	const		wallPixWidth = 128;		wallPixHeight = 128;		wallPixSize = wallPixWidth * wallPixHeight;		objectPixWidth = 128;		objectPixHeight = 128;		objectPixSize = objectPixWidth * objectPixHeight;	type		TArtView = object(TPixMapView)				fPixels: Ptr;				fRemoveWhite: boolean;				fCompressedType: OSType;				fCompressedData: Handle;				procedure TArtView.IArtView (itsMapList: TMapListDoc; itsWidth, itsHeight: integer);				procedure Free;				override;				procedure ClearCompressedData;				procedure InstallWall (art: WallArtHandle);				function ExtractWall: WallArtHandle;				procedure InstallObject (art: ObjectArtHandle);				function ExtractObject: ObjectArtHandle;				procedure TArtView.DoCopy;				override;				procedure TArtView.DoPaste;				override;			end;implementation	uses		UScrap, ULZSS, UCTables;	const		artClutID = 128;		outOfMemAlrtID = 148;	procedure OutOfMemory;	begin		DoAlert(outOfMemAlrtID);	end;	procedure ShowWatch;	begin		gCurrentCursor := GetCursor(watchCursor);		SetCursor(gCurrentCursor^^);	end;	function CopyHandle (h: univ Handle): Handle;		var			result: OSErr;	begin		result := HandToHand(h);		if result = noErr then			CopyHandle := h		else begin				OutOfMemory;				CopyHandle := nil;			end;	end;	procedure TArtView.IArtView (itsMapList: TMapListDoc; itsWidth, itsHeight: integer);		var			ctab: CTabHandle;	begin		ctab := GetMapListCTab(itsMapList, gameCTabID);		IPixMapView(itsWidth, itsHeight, ctab);		DisposHandle(Handle(ctab));		fPixels := GetPixBaseAddr(fPixMap);		fRemoveWhite := false;		fCompressedType := 'NONE';		fCompressedData := nil;	end;	procedure TArtView.Free;	begin		DisposHandle(fCompressedData);		inherited Free;	end;	procedure TArtView.ClearCompressedData;	begin		DisposHandle(fCompressedData);		fCompressedType := 'NONE';		fCompressedData := nil;	end;	procedure TArtView.InstallWall (art: WallArtHandle);		var			buffer: Ptr;	begin		ClearCompressedData;		if art <> nil then begin				fCompressedType := 'WWAL';				fCompressedData := CopyHandle(art);				ShowWatch;				buffer := NewPtr(wallPixSize);				if buffer = nil then begin						OutOfMemory;						exit(InstallWall);					end;				HLock(Handle(art));				DLZSS(art^, buffer, wallPixSize);				TransposePixels(buffer, fPixels, wallPixHeight, wallPixWidth);				HUnlock(Handle(art));				DisposPtr(buffer);				fNonEmpty := true;			end		else begin				ClearGWorld;				fNonEmpty := false;			end;		Invalidate;		fChanged := false;	end;	function TArtView.ExtractWall: WallArtHandle;		var			buffer: Ptr;	begin		if fNonEmpty then begin				if fCompressedType <> 'WWAL' then begin						DisposHandle(fCompressedData);						fCompressedData := nil;						buffer := NewPtr(wallPixSize);						if buffer = nil then begin								OutOfMemory;								exit(ExtractWall);							end;						TransposePixels(fPixels, buffer, wallPixWidth, wallPixHeight);						fCompressedData := LZSS(buffer, wallPixSize);						DisposPtr(buffer);						fCompressedType := 'WWAL';					end;				ExtractWall := CopyHandle(fCompressedData);			end		else			ExtractWall := nil;	end;	procedure TArtView.InstallObject (art: ObjectArtHandle);		var			buffer: Ptr;			size: longint;	begin		ClearCompressedData;		ClearGWorld;		if art <> nil then begin				fCompressedType := 'WOBJ';				fCompressedData := CopyHandle(art);				ShowWatch;				size := BigEndian(art^^.expandedSize);				buffer := NewPtr(size);				if buffer = nil then begin						OutOfMemory;						exit(InstallObject);					end;				HLock(Handle(art));				DLZSS(@art^^.data, buffer, size);				UnpackObject(buffer, size, fPixels, objectPixWidth);				HUnlock(Handle(art));				DisposPtr(buffer);				fNonEmpty := true;			end		else			fNonEmpty := false;		Invalidate;		fChanged := false;	end;	function TArtView.ExtractObject: ObjectArtHandle;		var			buffer: Handle;			size: longint;			art: ObjectArtHandle;			h: Handle;			result: OSErr;	begin		if fNonEmpty then begin				if fCompressedType <> 'WOBJ' then begin						DisposHandle(fCompressedData);						buffer := PackObject(fPixels, objectPixWidth, objectPixHeight);						if buffer <> nil then begin								size := GetHandleSize(buffer);								art := ObjectArtHandle(NewHandle(2));								if art = nil then									OutOfMemory								else begin										SetLittleEndian(art^^.expandedSize, size);										HLock(buffer);										h := LZSS(buffer^, size);										if h <> nil then begin												result := HandAndHand(h, Handle(art));												if result <> noErr then begin														OutOfMemory;														DisposHandle(Handle(art));														art := nil;													end;												fCompressedType := 'WOBJ';												fCompressedData := Handle(art);												DisposHandle(h);											end;									end;								DisposHandle(buffer);							end;					end;				ExtractObject := ObjectArtHandle(CopyHandle(fCompressedData));			end		else			ExtractObject := nil;	end;	procedure ShowPicture (pict: PicHandle);		var			win: WindowPtr;	begin		win := GetNewCWindow(128, nil, WindowPtr(-1));		ShowWindow(win);		SetPort(win);		DrawPicture(pict, pict^^.picFrame);		while not Button do			;		DisposeWindow(win);	end;{Wolf's DarkTable does silly things with pixel values 0 and 255, so we}{replace them by alternatives that have nearly identical clut entries.}	procedure ModifyBlackAndWhite (pixels: univ BytesPtr; width, height: longint);		var			i: longint;			pixel: integer;	begin		for i := 0 to width * height - 1 do begin				pixel := pixels^[i];				if pixel = $00 then					pixels^[i] := $1F				else if pixel = $FF then					pixels^[i] := $F0;			end;	end;	procedure TArtView.DoCopy;	begin		inherited DoCopy;		if fCompressedType <> 'NONE' then			WriteScrap(fCompressedType, fCompressedData);	end;	procedure TArtView.DoPaste;	begin		inherited DoPaste;{$IFC FALSE}		if fRemoveWhite then			ModifyBlackAndWhite(fPixels, wallPixWidth, wallPixHeight);{$ENDC}		ClearCompressedData;		if ProbeScrap('WWAL') then begin				fCompressedType := 'WWAL';				ReadScrap('WWAL', fCompressedData);			end		else if ProbeScrap('WOBJ') then begin				fCompressedType := 'WOBJ';				ReadScrap('WOBJ', fCompressedData);			end;	end;end.