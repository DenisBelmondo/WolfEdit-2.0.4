unit USpecialEffects;interface	uses		UMapCells;	function EditSpecialEffects (var cell: MapCell): boolean;implementation	uses		UDialog;	const		specialEffectsDlogID = 135;		flushDoorItem = 3;		northItem = 4;		westItem = 5;		southItem = 6;		eastItem = 7;		noDoorSideItem = 8;		firstQuarterItem = 9;	type		TSpecialEffectsDialog = object(TDialog)				fCell: MapCell;				procedure ItemHit (var e: EventInfo; itemNo: integer);				override;			end;	procedure TSpecialEffectsDialog.ItemHit (var e: EventInfo; itemNo: integer);	begin		inherited ItemHit(e, itemNo);		case itemNo of			flushDoorItem: 				EnableGroup(northItem, GetItemValue(flushDoorItem) <> 0);			otherwise				;		end;	end;	function EditSpecialEffects (var cell: MapCell): boolean;		var			dlog: TSpecialEffectsDialog;			i, item: integer;	begin		new(dlog);		with dlog do begin				IGetNewDialog(specialEffectsDlogID);				DefineGroup(northItem, eastItem);				SetItemValue(flushDoorItem, ord(cell.flushDoor));				SetItemValue(noDoorSideItem, ord(cell.noDoorSide));				if cell.flushDoor then					SetGroupSelection(northItem + cell.dir);				EnableGroup(northItem, cell.flushDoor);				for i := 0 to 3 do					SetItemValue(firstQuarterItem + i, 1 - band(1, bsr(cell.missingQuarters, i)));				dlog.Show;				item := dlog.DoModalDialog;				if item = ok then begin						cell.flushDoor := GetItemValue(flushDoorItem) <> 0;						cell.noDoorSide := GetItemValue(noDoorSideItem) <> 0;						if cell.flushDoor then							cell.dir := GetGroupSelection(northItem) - northItem;						cell.missingQuarters := 0;						for i := 0 to 3 do							if GetItemValue(firstQuarterItem + i) = 0 then								cell.missingQuarters := cell.missingQuarters + bsl(1, i);						EditSpecialEffects := true;					end				else					EditSpecialEffects := false;			end;		dlog.Free;	end;end.