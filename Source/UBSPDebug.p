unit UBSPDebug;interface	uses		UBSPTree;	procedure DrawBSPTree (tree: BSPTreePtr; cellSize, borderSize: integer);	procedure DBSP (tree: BSPTreePtr);implementation	const		bspPatListID = 128;		vSplitPatIndx = 2;		hSplitPatIndx = 3;		segThick = 6;		splitThick = 1;	procedure DrawBSPTree (tree: BSPTreePtr; cellSize, borderSize: integer);		var			pitch: integer;			n: integer;		function Coord (x: integer): integer;		begin			Coord := pitch * x div 2;		end;		procedure DrawSegment (p: SegmentPtr; pat: Pattern);			var				r: Rect;				vh, hv: VHSelect;		begin			vh := p^.dir;			hv := VHSelect(1 - ord(vh));			r.topLeft.vh[vh] := Coord(p^.ends[0]);			r.botRight.vh[vh] := Coord(p^.ends[1]) + borderSize;			case p^.face of				nw:  begin						r.topLeft.vh[hv] := Coord(p^.pos) - segThick;						r.botRight.vh[hv] := Coord(p^.pos) + borderSize;					end;				se:  begin						r.topLeft.vh[hv] := Coord(p^.pos);						r.botRight.vh[hv] := Coord(p^.pos) + segThick;					end;			end;			FillRect(r, pat);			FrameRect(r);		end;		procedure DrawSegments (p: SegmentPtr);			var				pat: Pattern;		begin			GetIndPattern(pat, sysPatListID, n);			n := n + 1;			while p <> nil do begin					DrawSegment(p, pat);					p := p^.next;				end;		end;		procedure DrawSplit (vh: VHSelect; pos: integer; b: Rect);			var				i: integer;				pat: Pattern;				r: Rect;				hv: VHSelect;		begin			hv := VHSelect(1 - ord(vh));			case vh of				v: 					i := vSplitPatIndx;				h: 					i := hSplitPatIndx;			end;			GetIndPattern(pat, bspPatListID, i);			r.topLeft.vh[vh] := Coord(b.topLeft.vh[vh]);			r.topLeft.vh[vh] := Coord(b.botRight.vh[vh]) + borderSize;			r.topLeft.vh[hv] := Coord(pos) - (splitThick - borderSize) div 2;			r.botRight.vh[hv] := r.topLeft.vh[hv] + splitThick;			FillRect(r, pat);		end;		procedure SplitRect (b: Rect; vh: VHSelect; pos: integer; var b0, b1: Rect);			var				hv: VHSelect;		begin			hv := VHSelect(1 - ord(vh));			b0 := b;			b1 := b;			b1.botRight.vh[hv] := pos;			b0.topLeft.vh[hv] := pos;		end;		procedure DrawTree (p: BSPTreePtr; b: Rect);			var				p0, p1: BSPTreePtr;				b0, b1: Rect;		begin			if p <> nil then begin					case p^.kind of						nonTerminal:  begin								p0 := p^.links[0];								p1 := p^.links[1];								if (p0 <> nil) | (p1 <> nil) then begin										SplitRect(b, p^.splitDir, p^.splitCoord, b0, b1);										DrawTree(p0, b0);										DrawTree(p1, b1);										DrawSplit(p^.splitDir, p^.splitCoord, b);									end;							end;						terminal: 							;					end;					DrawSegments(p^.segments);				end;		end;		procedure DrawRoot (p: BSPTreePtr);			var				b: Rect;		begin			SetRect(b, 0, 0, 128, 128);			DrawTree(p, b);		end;	begin		pitch := cellSize + borderSize;		n := 1;		PenNormal;		DrawRoot(tree);	end;	procedure DBSP (tree: BSPTreePtr);	begin		ShowDrawing;		DrawBSPTree(tree, 16, 1);	end;end.