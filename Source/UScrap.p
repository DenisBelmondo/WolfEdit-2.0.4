unit UScrap;interface	function ProbeScrap (scrapType: OSType): boolean;	procedure ReadScrap (scrapType: OSType; var h: univ Handle);	procedure WriteScrap (scrapType: OSType; h: univ Handle);	procedure ClearScrap;implementation	uses		UGoof;	function ProbeScrap (scrapType: OSType): boolean;		var			count, offset: longint;	begin		count := GetScrap(nil, scrapType, offset);		ProbeScrap := count >= 0;	end;	procedure ReadScrap (scrapType: OSType; var h: univ Handle);		var			count, offset: longint;		procedure Check (result: longint);		begin			if result < 0 then begin					ErrorAlert(gStdIDBase + clipReadFailedAlertID, '', result);					if h <> nil then begin							DisposHandle(h);							h := nil;							exit(ReadScrap);						end;				end;		end;	begin {ReadScrap}		h := NewHandle(0);		Check(MemError);		if h <> nil then			Check(GetScrap(h, scrapType, offset));	end;	procedure WriteScrap (scrapType: OSType; h: univ Handle);		procedure Check (result: longint);		begin			if result < 0 then begin					ErrorAlert(gStdIDBase + clipWriteFailedAlertID, '', result);					HUnlock(h);					exit(WriteScrap);				end;		end;	begin {WriteScrap}		HLock(h);		Check(PutScrap(GetHandleSize(h), scrapType, h^));		HUnlock(h);	end;	procedure ClearScrap;		var			result: longint;	begin		result := ZeroScrap;	end;end.