unit UBSP;interface	uses		UBSPTree, UMapCells;	function CreateBSPTree (var map: MapCellGrid; var tree: BSPTreePtr): OSErr;	procedure DisposeBSPTree (var p: BSPTreePtr);implementation	uses		UBSPDebug;{$D-}{$R-}	function NewSegment: SegmentPtr;	begin		NewSegment := SegmentPtr(NewPtr(sizeof(SegmentRecord)));	end;	procedure DisposeSegment (p: SegmentPtr);	begin		DisposPtr(Ptr(p));	end;	function NewBSPNode: BSPTreePtr;	begin		NewBSPNode := BSPTreePtr(NewPtr(sizeof(BSPTreeNode)));	end;	procedure DisposeBSPNode (p: BSPTreePtr);	begin		DisposPtr(Ptr(p));	end;	procedure DisposeSegmentList (var list: SegmentPtr);		var			p, q: SegmentPtr;	begin		p := list;		while p <> nil do begin				q := p;				p := p^.next;				DisposeSegment(q);			end;		list := nil;	end;	procedure DisposeBSPTree (var p: BSPTreePtr);	begin		if p <> nil then begin				case p^.kind of					nonterminal:  begin							DisposeBSPTree(p^.links[0]);							DisposeBSPTree(p^.links[1]);						end;					terminal: 						;				end;				DisposeSegmentList(p^.segments);				DisposeBSPNode(p);			end;		p := nil;	end;	procedure CreateSegments (var map: MapCellGrid; var segments: SegmentPtr);		type			QuarterMapPtr = ^QuarterMap;			QuarterMap = packed array[0..127, 0..127] of MapCell;		var			qmap: QuarterMapPtr;		procedure AddSegment (seg: SegmentRecord);			var				p: SegmentPtr;		begin			p := NewSegment;			if p = nil then				exit(CreateSegments);			p^ := seg;			p^.next := segments;			segments := p;		end;		procedure ScanWall (r0, c0, nr, nc, fr, fc: integer; dir: VHSelect; face: SegmentFacing);			var				row, col, i, seggrid: integer;				seg: SegmentRecord;			procedure InitSeg;				var					grid: integer;					inFront, behind: Point;					hv: VHSelect;			begin				SetPt(behind, c0, r0);				SetPt(inFront, c0 + fc, r0 + fr);				hv := VHSelect(1 - ord(dir));				seg.dir := dir;				seg.face := face;				case dir of					v:  begin							seggrid := behind.h div 2 + 64;						end;					h: 						seggrid := behind.v div 2;				end;				case face of					nw: 						seg.pos := behind.vh[hv];					se: 						seg.pos := inFront.vh[hv];				end;				seg.area := 0;			end;			procedure NextCell;			begin				row := row + nr;				col := col + nc;				i := i + 1;			end;			function Wall (r, c: integer): boolean;			begin				Wall := IsWall(qmap^[r, c]);			end;			function Empty (r, c: integer): boolean;				var					code: MapCell;			begin				code := qmap^[r, c];				Empty := not IsWall(code) & not code.noDoorSide & not IsDoor(code);			end;			function CurEnd: integer;			begin				case dir of					h:			{CurEnd := 2 * col;}						CurEnd := col;					v:			{CurEnd := 2 * row;}						CurEnd := row;				end;			end;			procedure DoWallSegment;			begin				seg.ends[0] := CurEnd;				seg.area := qmap^[row + fr, col + fc].area;				while (i < 128) & Wall(row, col) & Empty(row + fr, col + fc) do					NextCell;				seg.ends[1] := CurEnd;				seg.grid := seggrid;				AddSegment(seg);			end;			procedure DoDoorSideSegment;				var					cell: MapCell;			begin				seg.ends[0] := CurEnd;				cell := qmap^[row + fr, col + fc];				seg.area := cell.area;				if cell.noDoorSide then					seg.grid := seggrid				else					seg.grid := $80;				NextCell;				seg.ends[1] := CurEnd;				AddSegment(seg);			end;		begin {ScanWall}			InitSeg;			row := r0;			col := c0;			i := 0;			while (i < 128) do begin					while (i < 128) & not (Wall(row, col) & not Wall(row + fr, col + fc)) do						NextCell;					if i < 128 then begin							if Empty(row + fr, col + fc) then								DoWallSegment							else								DoDoorSideSegment;						end;				end;		end;{$PUSH}{$D+}		procedure MakeQMap;			var				row, col, qrow, qcol, a: integer;				code0, code1: MapCell;			function Quarter (mask: integer): MapCell;			begin				if BAND(code1.missingQuarters, mask) = 0 then					Quarter := code1				else					Quarter := code0;			end;		begin {MakeQMap}			qmap := QuarterMapPtr(NewPtr(sizeof(QuarterMap)));			if MemError <> noErr then				exit(CreateSegments);			qrow := 0;			for row := 0 to 63 do begin					qcol := 0;					for col := 0 to 63 do begin							code1 := map[row, col];							code0 := code1;							code0.wall := 0;			  {$IFC FALSE}							if code1.missingQuarters <> 0 then begin									writeln('MakeQMap: missingQuarters at ', row : 1, ',', col : 1);								end;			  {$ENDC}							qmap^[qrow, qcol] := Quarter(1);							qmap^[qrow, qcol + 1] := Quarter(2);							qmap^[qrow + 1, qcol] := Quarter(4);							qmap^[qrow + 1, qcol + 1] := Quarter(8);							if IsDoor(code1) then								case BAND(code1.wall, 1) of									0:  begin											if col > 0 then begin													a := map[row, col - 1].area;													qmap^[qrow, qcol].area := a;													qmap^[qrow + 1, qcol].area := a;												end;											if col < 63 then begin													a := map[row, col + 1].area;													qmap^[qrow, qcol + 1].area := a;													qmap^[qrow + 1, qcol + 1].area := a;												end;										end;									1:  begin											if row > 0 then begin													a := map[row - 1, col].area;													qmap^[qrow, qcol].area := a;													qmap^[qrow, qcol + 1].area := a;												end;											if col < 63 then begin													a := map[row + 1, col].area;													qmap^[qrow + 1, qcol].area := a;													qmap^[qrow + 1, qcol + 1].area := a;												end;										end;								end;							qcol := qcol + 2;						end;					qrow := qrow + 2;				end;		end;{$POP}		procedure ScanWalls;			var				row, col: integer;		begin			for row := 0 to 127 do begin					if row > 0 then						ScanWall(row, 0, 0, 1, -1, 0, h, nw);					if row < 127 then						ScanWall(row, 0, 0, 1, 1, 0, h, se);				end;			for col := 0 to 127 do begin					if col > 0 then						ScanWall(0, col, 1, 0, 0, -1, v, nw);					if col < 127 then						ScanWall(0, col, 1, 0, 0, 1, v, se);				end;		end;		procedure ScanForDoors;			var				numDoors: integer;				row, col, code: integer;			procedure AddDoorSegment (pos, end0, end1: integer; dir: VHSelect; face: SegmentFacing; code, area: integer);				var					s: SegmentRecord;			begin				s.pos := pos;				s.ends[0] := end0;				s.ends[1] := end1;				s.dir := dir;				s.face := face;				s.grid := code;				s.area := area;				AddSegment(s);			end;			procedure AddDoorSegments (code: MapCell);				var					item: integer;					door, adj: Point;					vh, hv: VHSelect;					x, y: integer;					doorCode, sideCode: integer;					areas: array[nw..se] of integer;					f: SegmentFacing;					flush: integer;	{$IFC FALSE}				function SideSegmentCode (face: SegmentFacing): integer;					var						n: integer;				begin					if code.noDoorSide then begin							case vh of								v: 									n := row;								h: 									n := 64 + col;							end;							case face of								nw: 									n := n - 1;								se: 									n := n + 1;							end;						end					else						n := $80;					SideSegmentCode := n;				end;	{$ENDC}				function DoorFlushing: integer;				begin					if code.flushDoor then						case code.dir of							sdNorth, sdWest: 								DoorFlushing := 0;							sdEast, sdSouth: 								DoorFlushing := 2;						end					else						DoorFlushing := 1;				end;			begin {AddDoorSegments}				item := ExtractWallOrDoor(code);				vh := VHSelect(BAND(item, $01));				hv := VHSelect(1 - ord(vh));				SetPt(door, col, row);				x := door.vh[hv] * 2;				y := door.vh[vh] * 2;				for f := nw to se do begin						adj.vh[vh] := door.vh[vh];						adj.vh[hv] := door.vh[hv] - 1 + 2 * ord(f);						areas[f] := map[adj.vh[v], adj.vh[h]].area;					end;				numDoors := numDoors + 1;				doorCode := numDoors + $80;				flush := DoorFlushing;				AddDoorSegment(x + flush, y, y + 2, vh, nw, doorCode, areas[nw]);				AddDoorSegment(x + flush, y, y + 2, vh, se, doorCode, areas[se]);		{$IFC FALSE}				sideCode := SideSegmentCode(se);				AddDoorSegment(y, x, x + 1, hv, se, sideCode, areas[nw]);				AddDoorSegment(y, x + 1, x + 2, hv, se, sideCode, areas[se]);				sideCode := SideSegmentCode(nw);				AddDoorSegment(y + 2, x, x + 1, hv, nw, sideCode, areas[nw]);				AddDoorSegment(y + 2, x + 1, x + 2, hv, nw, sideCode, areas[se]);		{$ENDC}			end;			procedure AddSecretDoorSegPair (pos0, pos1, end0, end1: integer; dir: VHSelect; face: SegmentFacing; grid, area: integer);				var					seg: SegmentRecord;			begin				seg.dir := dir;				seg.face := face;				seg.ends[0] := end0;				seg.ends[1] := end1;				seg.grid := grid;				seg.area := area;				seg.pos := pos0;				AddSegment(seg);				seg.pos := pos1;				AddSegment(seg);			end;			procedure AddSecretDoorSegments (code: MapCell);				var					x, y, area: integer;			begin				x := col * 2;				y := row * 2;				area := code.area;				case code.dir of					sdNorth: 						AddSecretDoorSegPair(y, y + 2, x, x + 2, h, se, row, area);					sdSouth: 						AddSecretDoorSegPair(y, y + 2, x, x + 2, h, nw, row, area);					sdWest: 						AddSecretDoorSegPair(x, x + 2, y, y + 2, v, se, col + 64, area);					sdEast: 						AddSecretDoorSegPair(x, x + 2, y, y + 2, v, nw, col + 64, area);				end;			end;			procedure CheckForDoor (code: MapCell);			begin				if IsDoor(code) then					AddDoorSegments(code)				else if IsSecretDoor(code) then					AddSecretDoorSegments(code);			end;		begin {ScanForDoors}			numDoors := 0;			for row := 1 to 62 do				for col := 1 to 62 do					CheckForDoor(map[row, col]);		end;	begin {CreateSegments}		segments := nil;		MakeQMap;		ScanWalls;		ScanForDoors;		DisposPtr(Ptr(qmap));	end;	function SeeEachOther (p, q: SegmentPtr): boolean;		procedure See (s: SegmentPtr; coord: integer);			var				seen: Boolean;		begin			case s^.face of				se: 					seen := coord >= s^.pos;				nw: 					seen := coord <= s^.pos;			end;			if not seen then begin					SeeEachOther := false;					exit(SeeEachOther);				end;		end;	begin		if p^.dir = q^.dir then begin				See(p, q^.pos);				See(q, p^.pos);			end		else begin				See(p, q^.ends[0]);				See(p, q^.ends[1]);				See(q, p^.ends[0]);				See(q, p^.ends[1]);			end;		SeeEachOther := true;	end;	function AllSeeEachOther (segments: SegmentPtr): boolean;		var			p, q: SegmentPtr;	begin		p := segments;		while p <> nil do begin				q := p^.next;				while q <> nil do begin						if not SeeEachOther(p, q) then begin								AllSeeEachOther := false;								exit(AllSeeEachOther);							end;						q := q^.next;					end;				p := p^.next;			end;		AllSeeEachOther := true;	end;	procedure SegmentsToTree (var segs: SegmentPtr; var tree: BSPTreePtr);		procedure NewNode (var p: BSPTreePtr; kind: BSPNodeType);		begin			p := NewBSPNode;			if p = nil then				exit(SegmentsToTree);			p^.kind := kind;			p^.segments := nil;			if kind = nonterminal then begin					p^.links[0] := nil;					p^.links[1] := nil;				end;		end;		type			SplittingDecision = (goLeft, goRight, splitIt);		function FindSplitting (seg, knife: SegmentPtr): SplittingDecision;			var				s: SplittingDecision;		begin			if seg^.dir = knife^.dir then begin					if seg^.pos < knife^.pos then						s := goLeft					else if seg^.pos > knife^.pos then						s := goRight					else						case seg^.face of							nw: 								s := goLeft;							se: 								s := goRight;						end;				end			else begin					if seg^.ends[1] <= knife^.pos then						s := goLeft					else if seg^.ends[0] >= knife^.pos then						s := goRight					else						s := splitIt;				end;			FindSplitting := s;		end;		type			SplitStats = record					knife: SegmentPtr;					count: array[SplittingDecision] of integer;					doorsSplit: integer;				end;		procedure TrySplit (segs, knife: SegmentPtr; var stats: SplitStats);			var				p: SegmentPtr;				action: SplittingDecision;			procedure Inc (var i: integer);			begin				i := i + 1;			end;		begin {TrySplit}			stats.knife := knife;			stats.count[goLeft] := 0;			stats.count[goRight] := 0;			stats.count[splitIt] := 0;			stats.doorsSplit := 0;			p := segs;			while p <> nil do begin					action := FindSplitting(p, knife);					Inc(stats.count[action]);					if (action = splitIt) & (p^.grid >= $81) then						Inc(stats.doorsSplit);					p := p^.next;				end;		end;		function Unbalance (var s: SplitStats): integer;		begin			Unbalance := abs(s.count[goLeft] - s.count[goRight]);		end;		function BetterSplit (var s1, s2: SplitStats): boolean;			var				u1, u2: integer;		begin			u1 := Unbalance(s1);			u2 := Unbalance(s2);			if s1.doorsSplit < s2.doorsSplit then				BetterSplit := true			else if s1.doorsSplit > s2.doorsSplit then				BetterSplit := false			else if u1 < u2 then				BetterSplit := true			else if u1 > u2 then				BetterSplit := false			else				BetterSplit := s1.count[splitIt] < s2.count[splitIt];		end;		function FindBestSplit (segs: SegmentPtr): SegmentPtr;			var				stats, bestStats: SplitStats;				p: SegmentPtr;		begin			p := segs;			TrySplit(segs, p, bestStats);			p := p^.next;			while p <> nil do begin					TrySplit(segs, p, stats);					if BetterSplit(stats, bestStats) then						bestStats := stats;					p := p^.next;				end;			FindBestSplit := bestStats.knife;		end;		procedure SplitSegment (seg0, knife, seg1: SegmentPtr);		begin			seg1^ := seg0^;			seg1^.next := nil;			seg0^.ends[1] := knife^.pos;			seg1^.ends[0] := knife^.pos;		end;		procedure MoveSegment (var src, dst: SegmentPtr);			var				p: SegmentPtr;		begin			p := src;			src := src^.next;			p^.next := dst;			dst := p;		end;		procedure SplitSegmentList (var src: SegmentPtr; knife: SegmentPtr; var dst0, dst1: SegmentPtr);			var				tmp: SegmentPtr;		begin			while src <> nil do				case FindSplitting(src, knife) of					goLeft: 						MoveSegment(src, dst0);					goRight: 						MoveSegment(src, dst1);					splitIt:  begin							tmp := NewSegment;							if tmp = nil then								exit(SegmentsToTree);							SplitSegment(src, knife, tmp);							MoveSegment(src, dst0);							MoveSegment(tmp, dst1);						end;				end;		end;		procedure SplitNode (var node: BSPTreePtr);			var				knife: SegmentPtr;		begin			knife := FindBestSplit(node^.segments);			node^.splitDir := knife^.dir;			node^.splitCoord := knife^.pos;			NewNode(node^.links[0], nonterminal);			NewNode(node^.links[1], nonterminal);			SplitSegmentList(node^.segments, knife, node^.links[1]^.segments, node^.links[0]^.segments);		end;		procedure BuildTree (var node: BSPTreePtr);			var				p: BSPTreePtr;		begin	  {DBSP(node);}			if AllSeeEachOther(node^.segments) then				node^.kind := terminal			else begin					SplitNode(node);		  {DBSP(node);}					BuildTree(node^.links[0]);					BuildTree(node^.links[1]);				end;		end;	begin {SegmentsToTree}		NewNode(tree, nonterminal);		tree^.segments := segs;		segs := nil;		BuildTree(tree);	end;	function CreateBSPTree (var map: MapCellGrid; var tree: BSPTreePtr): OSErr;		var			segs: SegmentPtr;		procedure Check (result: OSErr);		begin			if result <> noErr then begin					DisposeSegmentList(segs);					DisposeBSPTree(tree);					CreateBSPTree := result;					exit(CreateBSPTree);				end;		end;	begin		tree := nil;		segs := nil;		CreateSegments(map, segs);		Check(MemError);		SegmentsToTree(segs, tree);		Check(MemError);		DisposeSegmentList(segs);		CreateBSPTree := noErr;	end;end.