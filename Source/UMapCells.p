unit UMapCells;interface	const		sdNorth = 0;		sdWest = 1;		sdSouth = 2;		sdEast = 3;		mapScrapType = 'W3dM';	type		QuarterSet = 0..$F;		MapCell = packed record				wall: 0..255;				obj: 0..255;				area: 0..255;				case integer of					0: (							flushDoor: boolean;							noDoorSide: boolean;							missingQuarters: QuarterSet;							dir: 0..3;					);					1: (							flags: 0..255;					);			end;		MapCellGrid = array[0..63, 0..63] of MapCell;		MapCellsHandle = ^MapCellsPtr;		MapCellsPtr = ^MapCellsRecord;		MapCellsRecord = record				bounds: Rect;				cells: array[0..4095] of MapCell;			end;		TMapCells = object				fH: MapCellsHandle;				procedure IMapCells (itsBounds: Rect);				procedure IFromScrap;				procedure Free;				procedure GetBounds (var r: Rect);				procedure Position (topLeft: Point);				function GetCell (cell: Point): MapCell;				procedure SetCell (cell: Point; code: MapCell);				procedure CopyToGrid (var grid: MapCellGrid);				procedure CopyFromGrid (var grid: MapCellGrid);				procedure WriteToScrap;				function CellIndex (cell: Point): integer;			end;	function AndCode (code1, code2: MapCell): MapCell;	function OrCode (code1, code2: MapCell): MapCell;	function NotCode (code: MapCell): MapCell;	function EqualCode (code1, code2: MapCell): boolean;	procedure ClearCell (var code: MapCell);	function IsWall (code: MapCell): boolean;	function IsObject (code: MapCell): boolean;	function IsDoor (code: MapCell): boolean;	function IsGuard (code: MapCell): boolean;	function IsTreasure (code: MapCell): boolean;	function IsSecretDoor (code: MapCell): boolean;	function ExtractWallOrDoor (code: MapCell): integer;	function ExtractObject (code: MapCell): integer;	function ExtractObjectExtra (code: MapCell): integer;	function ExtractArea (code: MapCell): integer;	procedure InsertWallOrDoor (var code: MapCell; item: integer);	procedure InsertObject (var code: MapCell; item: integer);	procedure InsertObjectExtra (var code: MapCell; item: integer);	procedure InsertArea (var code: MapCell; item: integer);implementation{$D-}{$PUSH}{$D+}	procedure TMapCells.IMapCells (itsBounds: Rect);		var			numCells: longint;	begin		numCells := longint(itsBounds.right - itsBounds.left) * longint(itsBounds.bottom - itsBounds.top);		fH := MapCellsHandle(NewHandle(sizeof(Rect) + numCells * sizeof(MapCell)));		fH^^.bounds := itsBounds;	end;{$POP}	procedure TMapCells.IFromScrap;		var			len, offset: longint;			p: PScrapStuff;	begin		p := InfoScrap;		fH := MapCellsHandle(NewHandle(0));		len := GetScrap(Handle(fH), mapScrapType, offset);	end;	procedure TMapCells.Free;	begin		if fH <> nil then			DisposHandle(Handle(fH));	end;	procedure TMapCells.GetBounds (var r: Rect);	begin		r := fH^^.bounds;	end;	procedure TMapCells.Position (topLeft: Point);	begin		with fH^^ do			OffsetRect(bounds, topleft.h - bounds.topLeft.h, topLeft.v - bounds.topLeft.v);	end;	function TMapCells.GetCell (cell: Point): MapCell;	begin		GetCell := fH^^.cells[CellIndex(cell)];	end;	procedure TMapCells.SetCell (cell: Point; code: MapCell);	begin		if PtInRect(cell, fH^^.bounds) then			fH^^.cells[CellIndex(cell)] := code;	end;	function TMapCells.CellIndex (cell: Point): integer;	begin		with fH^^ do			CellIndex := (cell.v - bounds.top) * (bounds.right - bounds.left) + (cell.h - bounds.left);	end;	procedure TMapCells.CopyToGrid (var grid: MapCellGrid);		var			row, col, rowIndex, index, width: integer;	begin		with fH^^ do begin				rowIndex := 0;				width := bounds.right - bounds.left;				for row := bounds.top to bounds.bottom - 1 do begin						index := rowIndex;						for col := bounds.left to bounds.right - 1 do begin								grid[row, col] := cells[index];								index := index + 1;							end;						rowIndex := rowIndex + width;					end;			end;	end;	procedure TMapCells.CopyFromGrid (var grid: MapCellGrid);		var			row, col, rowIndex, index, width: integer;	begin		with fH^^ do begin				rowIndex := 0;				width := bounds.right - bounds.left;				for row := bounds.top to bounds.bottom - 1 do begin						index := rowIndex;						for col := bounds.left to bounds.right - 1 do begin								cells[index] := grid[row, col];								index := index + 1;							end;						rowIndex := rowIndex + width;					end;			end;	end;{$IFC FALSE}	procedure CopyMapCells (r: Rect; src, dst: TMapCells);		var			row, col: integer;			cell: Point;	begin		if SectRect(src.fH^^.bounds, r, r) then			if SectRect(dst.fH^^.bounds, r, r) then				for row := r.top to r.bottom - 1 do begin						cell.v := row;						for col := r.left to r.right - 1 do begin								cell.h := col;								dst.SetCell(cell, src.GetCell(cell));							end;					end;	end;	procedure TMapCells.CopyTo (other: TMapCells);	begin		CopyMapCells(fH^^.bounds, self, other);	end;	procedure TMapCells.CopyFrom (other: TMapCells);	begin		CopyMapCells(fH^^.bounds, other, self);	end;{$ENDC}	procedure TMapCells.WriteToScrap;		var			result: longint;	begin		result := ZeroScrap;		HLock(Handle(fH));		result := PutScrap(GetHandleSize(Handle(fH)), mapScrapType, Ptr(fH^));		HUnlock(Handle(fH));	end;	function AndCode (code1, code2: MapCell): MapCell;	begin		AndCode := MapCell(BAND(longint(code1), longint(code2)));	end;	function OrCode (code1, code2: MapCell): MapCell;	begin		OrCode := MapCell(BOR(longint(code1), longint(code2)));	end;	function NotCode (code: MapCell): MapCell;	begin		NotCode := MapCell(BNOT(longint(code)));	end;	function EqualCode (code1, code2: MapCell): boolean;	begin		EqualCode := (code1.wall = code2.wall) & (code1.obj = code2.obj) & (code1.dir = code2.dir);	end;	procedure ClearCell (var code: MapCell);	begin		code := MapCell(0);	end;	function IsWall (code: MapCell): boolean;	begin		IsWall := (BAND(code.wall, $C0) = $80) & not IsSecretDoor(code);	end;	function IsObject (code: MapCell): boolean;	begin		IsObject := ExtractObject(code) <> 0;	end;	function IsDoor (code: MapCell): boolean;	begin		IsDoor := BAND(code.wall, $C0) = $C0;	end;	function IsGuard (code: MapCell): boolean;	begin		case ExtractObject(code) of			$6C..$8F: 				IsGuard := true;			otherwise				IsGuard := false;		end;	end;	function IsTreasure (code: MapCell): boolean;	begin		case ExtractObject(code) of			$30..$33: 				IsTreasure := true;			otherwise				IsTreasure := false;		end;	end;	function IsSecretDoor (code: MapCell): boolean;	begin		IsSecretDoor := code.obj = $62;	end;	function ExtractWallOrDoor (code: MapCell): integer;	begin		if IsSecretDoor(code) then			ExtractWallOrDoor := 0		else			ExtractWallOrDoor := code.wall;	end;	function ExtractObject (code: MapCell): integer;	begin		ExtractObject := code.obj;	end;	function ExtractObjectExtra (code: MapCell): integer;	begin		ExtractObjectExtra := BAND(code.wall, $7F);	end;	function ExtractArea (code: MapCell): integer;	begin		ExtractArea := code.area;	end;	procedure InsertWallOrDoor (var code: MapCell; item: integer);	begin		code.wall := item;	end;	procedure InsertObject (var code: MapCell; item: integer);	begin		code.obj := item;	end;	procedure InsertObjectExtra (var code: MapCell; item: integer);	begin		code.wall := BOR(item, $80);	end;	procedure InsertArea (var code: MapCell; item: integer);	begin		code.area := item;	end;end.