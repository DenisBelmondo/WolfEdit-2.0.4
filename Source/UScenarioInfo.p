unit UScenarioInfo;interface	uses		UDialog, UWolfDoc;	procedure EditScenarioInfo (mapList: TMapListDoc);implementation	uses		UMusic, UScrap;	const		scenarioInfoDlogID = 141;		outOfMemoryAlrtID = 148;		titleMusicItem = 3;		interMusicItem = 4;		pictItem = 5;	type		TScenarioInfoDialog = object(TDialog)				fCurrentItem: integer;				fPict: PicHandle;				procedure IScenarioInfoDialog;				procedure Free;				override;				procedure Load (mapList: TMapListDoc);				procedure Unload (mapList: TMapListDoc);				procedure SetCurrentItem (itemNo: integer);				procedure FrameItem (itemNo: integer; pat: Pattern);				procedure SetupMenus;				override;				procedure DoMenuCommand (cmdNumber: integer);				override;				procedure DoCopy;				procedure DoPaste;				procedure DoClear;				procedure DrawUserItem (itemNo: integer);				override;				procedure ItemHit (var e: EventInfo; itemNo: integer);				override;			end;	procedure TScenarioInfoDialog.IScenarioInfoDialog;	begin		IGetNewDialog(scenarioInfoDlogID);		fCurrentItem := 0;		fPict := nil;		SetDismissItems([ok, cancel]);	end;	procedure TScenarioInfoDialog.Free;	begin		DisposHandle(Handle(fPict));		inherited Free;	end;	procedure TScenarioInfoDialog.Load (mapList: TMapListDoc);	begin		SetTitle(mapList.fFileName);		SetUpMusicMenu(mapList.fVersion.encounter, mapList.fMusic);	{$IFC FALSE}		with mapList do			if fName <> nil then begin					HLock(Handle(fName));					SetItemText(nameItem, fName^^);					HUnlock(Handle(fName));				end;    {$ENDC}		if mapList.fPict <> nil then begin				fPict := mapList.fPict;				if HandToHand(Handle(fPict)) <> noErr then begin						fPict := nil;						DoAlert(outOfMemoryAlrtID);					end;			end;		SetItemValue(titleMusicItem, SongIDToMenuItem(mapList.fTitleMusic, mapList.fMusic));		SetItemValue(interMusicItem, SongIDToMenuItem(mapList.fInterMusic, mapList.fMusic));	end;	procedure TScenarioInfoDialog.Unload (mapList: TMapListDoc);  {$IFC FALSE}		var			s: Str255;  {$ENDC}	begin		DisposHandle(Handle(mapList.fPict));		mapList.fPict := fPict;		fPict := nil;   {$IFC FALSE}		GetItemText(nameItem, s);		DisposHandle(Handle(mapList.fName));		mapList.fName := StringHandle(NewHandle(length(s) + 1));		if MemError = noErr then			mapList.fName^^ := s		else			DoAlert(outOfMemoryAlrtID);    {$ENDC}		mapList.fTitleMusic := MenuItemToSongID(GetItemValue(titleMusicItem), mapList.fMusic);		mapList.fInterMusic := MenuItemToSongID(GetItemValue(interMusicItem), mapList.fMusic);		mapList.Changed;	end;	procedure TScenarioInfoDialog.SetCurrentItem (itemNo: integer);	begin		if fCurrentItem <> itemNo then begin				if fCurrentItem = pictItem then					FrameItem(pictItem, white);				fCurrentItem := itemNo;				if fCurrentItem = pictItem then					FrameItem(pictItem, black);			end;	end;	procedure TScenarioInfoDialog.FrameItem (itemNo: integer; pat: Pattern);		var			r: Rect;			oldState: PenState;	begin		Focus;		GetPenState(oldState);		GetItemBox(itemNo, r);		InsetRect(r, -3, -3);		PenPat(pat);		PenSize(2, 2);		FrameRect(r);		SetPenState(oldState);	end;	procedure TScenarioInfoDialog.SetupMenus;	begin		if ProbeScrap('PICT') then			EnableCmd(pasteCmd);		if fCurrentItem = pictItem then begin				if fPict <> nil then begin						EnableCmd(cutCmd);						EnableCmd(copyCmd);						EnableCmd(clearCmd);					end;			end		else			inherited SetupMenus;	end;	procedure TScenarioInfoDialog.DoMenuCommand (cmdNumber: integer);	begin		case cmdNumber of			pasteCmd: 				if ProbeScrap('PICT') then					DoPaste				else					inherited DoMenuCommand(cmdNumber);			cutCmd, copyCmd, clearCmd: 				if fCurrentItem = pictItem then					case cmdNumber of						cutCmd:  begin								DoCopy;								DoClear;							end;						copyCmd: 							DoCopy;						clearCmd: 							DoClear;					end				else					inherited DoMenuCommand(cmdNumber);		end;	end;	procedure TScenarioInfoDialog.DoCopy;	begin		WriteScrap('PICT', fPict);	end;	procedure TScenarioInfoDialog.DoPaste;	begin		DoClear;		ReadScrap('PICT', fPict);	end;	procedure TScenarioInfoDialog.DoClear;		var			r: Rect;	begin		DisposHandle(Handle(fPict));		fPict := nil;		GetItemBox(pictItem, r);		InvalidateRect(r);	end;	procedure TScenarioInfoDialog.DrawUserItem (itemNo: integer);		var			f, r: Rect;			oldPen: PenState;	begin		GetPenState(oldPen);		GetItemBox(pictItem, r);		if fPict <> nil then begin				f := fPict^^.picFrame;				OffsetRect(f, r.left - f.left, r.top - f.top);				DrawPicture(fPict, f);			end		else			EraseRect(r);		PenNormal;		InsetRect(r, -1, -1);		FrameRect(r);		SetPenState(oldPen);	end;	procedure TScenarioInfoDialog.ItemHit (var e: EventInfo; itemNo: integer);	begin		case itemNo of			pictItem: 				SetCurrentItem(itemNo);			otherwise				inherited ItemHit(e, itemNo);		end;	end;	procedure EditScenarioInfo (mapList: TMapListDoc);		var			dlog: TScenarioInfoDialog;	begin		new(dlog);		dlog.IScenarioInfoDialog;		dlog.Load(mapList);		dlog.Show;		if dlog.DoModalDialog = ok then			dlog.Unload(mapList);		dlog.Free;	end;end.