unit UAbout;interface	procedure IUAbout;	procedure ShowAboutBox;implementation	uses		UGoof, UXWindow, UScreen;	const		aboutBoxWindID = 130;		smallAboutBoxWindID = 132;		aboutPictListID = 128;	type		TAboutBox = object(TXWindow)				fAboutView: TAboutView;				fScrollBar: ControlHandle;				procedure IAboutBox;				procedure Free;				override;				procedure CtrlOperated (theControl: ControlHandle; partCode: integer);				override;			end;		TAboutView = object(TView)				fPictNum: integer;				fPict: PicHandle;				procedure IAboutView;				procedure Free;				override;				procedure SetPict (n: integer);				procedure Draw;				override;			end;		PictListHandle = ^PictListPtr;		PictListPtr = ^PictListRecord;		PictListRecord = record				numPicts: integer;				pictIDs: array[1..999] of integer;			end;	var		gAboutBox: TAboutBox;		gAboutPicts: PictListHandle;	procedure TAboutBox.IAboutBox;		var			r: Rect;			opts: FrameOptions;			id: integer;			aboutView: TAboutView;	begin		if IsSmallScreen then			id := smallAboutBoxWindID		else			id := aboutBoxWindID;		IGetNewCWindow(nil, id, [wCloseOnGoAway]);		new(aboutView);		aboutView.IAboutView;		fAboutView := aboutView;		opts := [];		r := fBounds;		OffsetRect(r, -r.left, -r.top);		if IsSmallScreen then			Place(fAboutView, nil, nil, 0, 0, r.right, r.bottom - 24, [frmVScroll, frmBorder])		else			Place(fAboutView, nil, nil, 8, 8, natural, natural, []);		r.top := fAboutView.fFrame.fBounds.bottom;		InsetRect(r, r.right div 3, (r.bottom - r.top - 16) div 2);		fScrollBar := NewCtrl(self, r, '', true, 1, 1, gAboutPicts^^.numPicts, scrollBarProc);		Show;	end;	procedure TAboutBox.Free;	begin		gAboutBox := nil;		inherited Free;	end;	procedure TAboutBox.CtrlOperated (theControl: ControlHandle; partCode: integer);		var			pt: Point;			ctl: ControlHandle;	begin		if theControl = fScrollBar then begin				case partCode of					inUpButton, inPageUp: 						SetCtlValue(fScrollBar, GetCtlValue(fScrollbar) - 1);					inDownButton, inPageDown: 						SetCtlValue(fScrollBar, GetCtlValue(fScrollbar) + 1);					inThumb: 						;					otherwise						;				end;				with fAboutView.fFrame do begin						ctl := fScrollBars[v];						if ctl <> nil then begin								FocusOnContainer;								SetPt(fScrollOffset, 0, 0);								SetCtlValue(ctl, 0);							end;					end;				fAboutView.SetPict(GetCtlValue(fScrollBar));				fAboutView.Invalidate;			end;	end;	procedure TAboutView.IAboutView;	begin		fPict := nil;		SetPict(1);		IView(nil, nil, fPict^^.picFrame);	end;	procedure TAboutView.Free;	begin		if fPict <> nil then			ReleaseResource(Handle(fPict));		inherited Free;	end;	procedure TAboutView.SetPict (n: integer);	begin		if fPict <> nil then			ReleaseResource(Handle(fPict));		fPict := nil;		fPictNum := n;		with gAboutPicts^^ do			if (n >= 1) & (n <= numPicts) then				fPict := PicHandle(GetResource('PICT', pictIDs[n]));	end;	procedure TAboutView.Draw;	begin		EraseRect(fExtent);		if fPict <> nil then			DrawPicture(fPict, fPict^^.picFrame);	end;	procedure IUAbout;	begin		gAboutBox := nil;		gAboutPicts := PictListHandle(GetResource('PIC#', aboutPictListID));	end;	procedure ShowAboutBox;	begin		if gAboutBox = nil then begin				new(gAboutBox);				gAboutBox.IAboutBox;			end;		gAboutBox.Select;	end;end.