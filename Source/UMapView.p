unit UMapView;interface	uses		UGoof, UList, UPalette, UScrap, UWolfDoc, UMapCellsView, UMapPalette;{$SETC MonitorDrawCell = FALSE}	const		numTools = 7;		selectTool = 0;		pencilTool = 1;		eraserTool = 2;		dropperTool = 3;		paintPotTool = 4;		rectangleTool = 5;		soundTool = 6;		quarterPencilTool = 7;		toolCursIDBase = 128;		handCursID = 258;	type		TMapView = object(TMapCellsView)				fMap: TMap;				fMagnification: integer;				fPalette: TMapPalette;				fTools: TPalette;				fFloating: TMapCells;				fUndo: TMapViewUndo;				procedure IMapView (itsMap: TMap);				procedure Free;				override;				procedure Close;				function CurrentCode: MapCell;				function CurrentTool: integer;				procedure SetMagnification (n: integer);				procedure Key (var e: EventInfo);				override;				procedure Click (var e: EventInfo);				override;				procedure TMapView.MakeFloating (clearUnder: boolean);				procedure TMapView.DoDrag (e: EventInfo; cell: Point);				procedure TMapView.DoPencil (cell: Point);				procedure TMapView.PencilCell (cell: Point; initCode, pencilCode, pencilMask: MapCell);				procedure TMapView.DoEraser (cell: Point);				procedure TMapView.DoDropper (cell: Point);				procedure TMapView.DoPaintPot (cell: Point);				procedure TMapView.DoRectangle (r: Rect);				procedure TMapView.DoSound (cell: Point);				function TrackCell (var cell: Point): boolean;				procedure TMapView.SetCell (cell: Point; code: MapCell);		{$IFC MonitorDrawCell}				procedure TMapView.DrawCell (cell: Point; r: Rect; var hilite: boolean);				override;		{$ENDC}				function GetCellForDrawing (cell: Point): MapCell;				override;				procedure TMapView.SetupMenus;				override;				procedure TMapView.DoMenuCommand (cmdNumber: integer);				override;				procedure TMapView.DoUndo;				procedure TMapView.DoCut;				procedure TMapView.DoCopy;				procedure TMapView.DoPaste;				procedure TMapView.DoClear;				procedure TMapView.DoFlipHorizontal;				procedure TMapView.DoFlipVertical;				procedure TMapView.RotateSelection (procedure RotateRC (row, col: integer; r2: Rect; var p2: Point); rot: integer);				procedure TMapView.DoRotateLeft;				procedure TMapView.DoRotateRight;				procedure TMapView.DoSpecialEffects;				procedure TMapView.DoGetInfo;				procedure TMapView.DoLevelStatus;				procedure TMapView.ClearCells (r: Rect);				procedure TMapView.FillCells (r: Rect; cell: MapCell);				procedure SaveForUndo (r: Rect);				procedure SaveCellForUndo (cell: Point);				procedure SaveAllForUndo;				procedure DropFloating;				procedure DiscardFloating;				procedure DiscardUndo;				procedure TMapView.UpdateCursor;				procedure TMapView.Idle;				override;			end;		TMapViewUndo = object(TObject)				fNext: TMapViewUndo;				fCells: TMapCells;			end;	procedure IUMapView;implementation	uses{$IFC Demo}		UDemo, {$ENDC}		HexIO, UCursors, UMapListDoc, UMapListView, USoundDialog, {}		USpecialEffects, ULevelStatus;	const		minCellSize = 16;		fontNum = geneva;		fontSize = 9;		toolIconIDBase = 128;		wallPatListIDBase = 129;		flipHorizontalCmd = 350;		flipVerticalCmd = 351;		rotateLeftCmd = 352;		rotateRightCmd = 353;		levelStatusCmd = 360;		specialEffectsCmd = 409;{$IFC NOT Demo}	procedure DoQuarterPencil (v: TMapView; cell: Point);		var			code: MapCell;			r1, r2, r3: Rect;			p: Point;			quarter: integer;	begin		with v do begin				DiscardUndo;				SaveCellForUndo(cell);				code := fMap.GetCell(cell);				CellToRect(cell, r1);				SetRect(r2, 0, 0, 1, 1);				p := gLastEvent.where;				MapPt(p, r1, r2);				quarter := BSL(1, p.v * 2 + p.h);				code.missingQuarters := BXOR(code.missingQuarters, quarter);				fMap.SetCell(cell, code);				SetRect(r3, p.h, p.v, p.h + 1, p.v + 1);				SetRect(r2, 0, 0, 2, 2);				MapRect(r3, r2, r1);				InvalidateRect(r3);				fMap.Changed;			end;	end;{$ENDC}	procedure TMapView.IMapView (itsMap: TMap);		var			i: integer;			cells: TMapCells;			palette: TMapPalette;			tools: TPalette;	begin		cells := nil;		if itsMap <> nil then			cells := itsMap.fCells;		IMapCellsView(cells, [listMultiSel, listMarquee], itsMap.fMapList);		fMap := itsMap;		if itsMap <> nil then			itsMap.fView := self;		fPalette := nil;		fTools := nil;		fFloating := nil;		fUndo := nil;		SetMagnification(1);		new(palette);		palette.IMapPalette(itsMap.fMapList);		fPalette := palette;		new(tools);		tools.IPalette(32, 32, 1, numTools, true);		fTools := tools;		for i := 0 to numTools - 1 do			fTools.SetCellIcon(i, GetResource('ICON', toolIconIDBase + i));	end;	procedure TMapView.Free;	begin		if fMap <> nil then			fMap.fView := nil;		DiscardFloating;		DiscardUndo;		inherited Free;	end;	procedure TMapView.Close;	begin		if fMap <> nil then begin				DropFloating;				fMap.Close;			end;	end;	function TMapView.CurrentCode: MapCell;		var			code, mask: MapCell;	begin		fPalette.GetCurrentCodeAndMask(code, mask);		CurrentCode := code;	end;	function TMapView.CurrentTool: integer;		var			tool: integer;	begin		tool := fTools.GetSelection;		if gLastEvent.theOptionKey then begin{$IFC NOT Demo}				if gLastEvent.theCmdKey and (tool = pencilTool) then					tool := quarterPencilTool				else{$ENDC}					case tool of						pencilTool, paintPotTool, rectangleTool: 							tool := dropperTool;						otherwise							;					end;			end;		CurrentTool := tool;	end;	procedure TMapView.SetMagnification (n: integer);		var			size: integer;			r: Rect;	begin		fMagnification := n;		size := n * minCellSize;		SetCellSize(size, size);	end;{$IFC MonitorDrawCell}	procedure TMapView.DrawCell (cell: Point; r: Rect; var hilite: boolean);	begin		if Button then			writeln('TMapView.DrawCell([', cell.h : 1, ',', cell.v : 1, '])');		inherited DrawCell(cell, r, hilite);	end;{$ENDC}	procedure TMapView.Key (var e: EventInfo);	begin		if (e.theChar = chr(8)) | (e.theChar = chr($7F)) then			DoClear;	end;	procedure TMapView.Click (var e: EventInfo);		var			tool: integer;			cell: Point;	begin		if FindCell(e.where, cell) then begin				tool := CurrentTool;				case tool of					selectTool: 						if PtInRect(cell, fSelection) then							DoDrag(e, cell)						else begin								DropFloating;								inherited Click(e);							end;					pencilTool: 						DoPencil(cell);					eraserTool: 						DoEraser(cell);					dropperTool: 						DoDropper(cell);					paintPotTool: 						DoPaintPot(cell);					rectangleTool:  begin							DropFloating;							inherited Click(e);							DoRectangle(fSelection);						end;					soundTool: 						DoSound(cell);{$IFC NOT Demo}					quarterPencilTool: 						DoQuarterPencil(self, cell);{$ENDC}					otherwise						;				end;			end;	end;	procedure TMapView.MakeFloating (clearUnder: boolean);		var			stone: MapCell;			floating: TMapCells;	begin		if (fFloating = nil) & not EmptyRect(fSelection) then begin				new(floating);				floating.IMapCells(fSelection);				fFloating := floating;				fMap.CopyTo(fFloating);				if clearUnder then begin						ClearCell(stone);						stone.wall := $81;						DiscardUndo;						SaveForUndo(fSelection);						FillCells(fSelection, stone);					end;			end	end;	procedure TMapView.DoDrag (e: EventInfo; cell: Point);		var			cell2: Point;			rgn1, rgn2: RgnHandle;			b, r1, r2, cr1, cr2: Rect;	begin		rgn1 := NewRgn;		rgn2 := NewRgn;		if fFloating = nil then			MakeFloating(not e.theOptionKey)		else if e.theOptionKey then begin				DiscardUndo;				SaveForUndo(fSelection);				fMap.CopyFrom(fFloating);			end;		cell2 := cell;		while TrackCell(cell2) do begin				fFloating.GetBounds(b);				CellsToRect(b, r1);				OffsetRect(b, cell2.h - cell.h, cell2.v - cell.v);				CellsToRect(b, r2);				fFloating.Position(b.topLeft);				ClearSelection;				ForeColor(blackColor);				BackColor(whiteColor);				if SectRect(thePort^.clipRgn^^.rgnBBox, r1, cr1) then begin						cr2 := cr1;						OffsetRect(cr2, r2.left - r1.left, r2.top - r1.top);						CopyBits(thePort^.portBits, thePort^.portBits, cr1, cr2, srcCopy, nil);					end;				RectRgn(rgn1, r1);				RectRgn(rgn2, r2);				UnionRgn(rgn1, rgn2, rgn1);				RectRgn(rgn2, cr2);				DiffRgn(rgn1, rgn2, rgn1);				InvalidateRgn(rgn1);				SetSelectionRect(b);				Update;				cell := cell2;			end;		DisposeRgn(rgn1);		DisposeRgn(rgn2);	end;	procedure TMapView.DoPencil (cell: Point);		var			initCode, pencilCode, pencilMask: MapCell;	begin		DiscardUndo;		initCode := fMap.GetCell(cell);		fPalette.GetCurrentCodeAndMask(pencilCode, pencilMask);		if gLastEvent.theShiftKey then begin				if pencilCode.wall = 0 then					pencilMask.wall := 0;				if pencilCode.obj = 0 then					pencilMask.obj := 0;			end;		repeat			PencilCell(cell, initCode, pencilCode, pencilMask);		until not TrackCell(cell);		fMap.Changed;	end;	procedure TMapView.PencilCell (cell: Point; initCode, pencilCode, pencilMask: MapCell);		var			pencilItem: integer;			code: MapCell;	begin		code := fCells.GetCell(cell);		if EqualCode(pencilCode, AndCode(initCode, pencilMask)) then			code := AndCode(code, NotCode(pencilMask))		else			code := OrCode(pencilCode, AndCode(code, NotCode(pencilMask)));		SaveCellForUndo(cell);		SetCell(cell, code);	end;	procedure TMapView.DoEraser (cell: Point);		var			empty: MapCell;	begin		DiscardUndo;		ClearCell(empty);		repeat			SaveCellForUndo(cell);			SetCell(cell, empty);		until not TrackCell(cell);		fMap.Changed;	end;	procedure TMapView.DoDropper (cell: Point);	begin		fPalette.SelectByExample(fCells.GetCell(cell));	end;	procedure TMapView.DoPaintPot (cell: Point);		var			initCode, paintCode: MapCell;		procedure Fill (row, col: integer);			var				cell: Point;				code: MapCell;		begin			SetPt(cell, col, row);			code := fCells.GetCell(cell);			if EqualCode(code, initCode) then begin					SetCell(cell, paintCode);					if row > 0 then						Fill(row - 1, col);					if row < 63 then						Fill(row + 1, col);					if col > 0 then						Fill(row, col - 1);					if col < 63 then						Fill(row, col + 1);				end;		end;	begin {DoPaintPot}		initCode := fCells.GetCell(cell);		paintCode := CurrentCode;		if not EqualCode(paintCode, initCode) then begin				ChangeCursor(gWatch);				DiscardUndo;				SaveAllForUndo;				Fill(cell.v, cell.h);				fMap.Changed;			end;	end;	procedure TMapView.DoRectangle (r: Rect);		var			border: MapCell;			x, y: integer;		procedure SetBorder (x, y: integer);			var				cell: Point;		begin			SetPt(cell, x, y);			fMap.SetCell(cell, border);		end;	begin {TMapView.DoRectangle}		if not EmptyRect(r) then begin				DiscardUndo;				SaveForUndo(r);				ClearCells(r);				border := CurrentCode;				for x := r.left to r.right - 1 do begin						SetBorder(x, r.top);						SetBorder(x, r.bottom - 1);					end;				for y := r.top + 1 to r.bottom - 2 do begin						SetBorder(r.left, y);						SetBorder(r.right - 1, y);					end;				fMap.Changed;				InvalidateCells(r);			end;	end;	procedure TMapView.DoSound (cell: Point);		var			code: MapCell;	begin		code := fCells.GetCell(cell);		if EditSoundArea(code) then begin				SetCell(cell, code);				fMap.Changed;			end;	end;	procedure TMapView.SetCell (cell: Point; code: MapCell);		var			item: integer;	begin		item := ExtractObject(code);		if (item >= $13) & (item <= $16) & fMap.fStartPosSet then			InvalidateCell(fMap.fStartPos);		fMap.SetCell(cell, code);		UpdateCell(cell);	end;	function TMapView.GetCellForDrawing (cell: Point): MapCell;	begin		if (fFloating <> nil) & (PtInRect(cell, fFloating.fH^^.bounds)) then			GetCellForDrawing := fFloating.GetCell(cell)		else			GetCellForDrawing := inherited GetCellForDrawing(cell);	end;  {		Track the mouse until it enters a different cell or		}  {		the button is released. Returns true if a new cell is	}  {		entered with the button down.									}	function TMapView.TrackCell (var cell: Point): boolean;		var			mouse, cell0: Point;	begin		cell0 := cell;		while StillDown do begin				AutoScroll;				GetMouse(mouse);				if FindCell(mouse, cell) then					if not EqualPt(cell, cell0) then begin							TrackCell := true;							exit(TrackCell);						end;			end;		TrackCell := false;	end;	procedure TMapView.DoUndo;		var			r: Rect;			p, q: TMapViewUndo;	begin		DropFloating;		p := fUndo;		fUndo := nil;		while p <> nil do begin				q := p;				p := p.fNext;				q.fCells.GetBounds(r);				SaveForUndo(r);				fMap.CopyFrom(q.fCells);				q.fCells.Free;				q.Free;				InvalidateCells(r);			end;		ClearSelection;	end;	procedure TMapView.DoCut;	begin		DoCopy;		DoClear;	end;	procedure TMapView.DoCopy;		var			r: Rect;			c: TMapCells;			pict: PicHandle;			row, col: integer;			p: Point;			hilite: boolean;	begin		r := fSelection;		if fFloating <> nil then			fFloating.WriteToScrap		else begin				new(c);				c.IMapCells(r);				fMap.CopyTo(c);				c.WriteToScrap;				c.Free;			end;		if gLastEvent.theOptionKey then begin				Focus;				with fSelection do					SetRect(r, 16 * left, 16 * top, 16 * right, 16 * bottom);				pict := OpenPicture(r);				if pict <> nil then begin						for row := fSelection.top to fSelection.bottom - 1 do							for col := fSelection.left to fSelection.right - 1 do begin									SetPt(p, col, row);									SetRect(r, 16 * col, 16 * row, 16 * (col + 1), 16 * (row + 1));									hilite := false;									DrawCell(p, r, hilite);								end;						ClosePicture;						WriteScrap('PICT', pict);						DisposHandle(Handle(pict));					end;			end;	end;	procedure TMapView.DoPaste;		var			r, cells: Rect;			p: Point;			floating: TMapCells;	begin		DropFloating;		DiscardUndo;		new(floating);		floating.IFromScrap;		fFloating := floating;		if not EmptyRect(fSelection) then			fFloating.Position(fSelection.topLeft);		fFloating.GetBounds(cells);		CellsToRect(cells, r);		SetPt(p, r.right - r.left, r.bottom - r.top);		if fFrame <> nil then			fFrame.RevealRect(r, p);		SetSelectionRect(cells);		InvalidateRect(r);	end;	procedure TMapView.DoClear;		var			r: Rect;	begin		r := fSelection;		if fFloating <> nil then			DiscardFloating		else begin				DiscardUndo;				SaveForUndo(r);				ClearCells(r);				fMap.Changed;			end;		ClearSelection;		InvalidateCells(r);	end;	procedure TMapView.DoSpecialEffects;		var			r: Rect;			cell0, cell: MapCell;			c: Point;			row, col: integer;	begin{$IFC Demo}		OnlyInFullVersion;{$ELSEC}		DropFloating;		r := fSelection;		cell0 := fMap.GetCell(r.topLeft);		if EditSpecialEffects(cell0) then begin				DiscardUndo;				SaveForUndo(r);				for row := r.top to r.bottom - 1 do					for col := r.left to r.right - 1 do begin							SetPt(c, col, row);							cell := fMap.GetCell(c);							cell.flushDoor := cell0.flushDoor;							cell.noDoorSide := cell0.noDoorSide;							cell.missingQuarters := cell0.missingQuarters;							if cell0.flushDoor then								cell.dir := cell0.dir;							fMap.SetCell(c, cell);						end;				InvalidateCells(fSelection);				fMap.Changed;			end;{$ENDC}	end;	procedure TMapView.DoGetInfo;	begin		GetInfoForLevel(fMap.fMapList.fView, fMap.fLevelNumber);	end;	procedure TMapView.ClearCells (r: Rect);		var			empty: MapCell;			row, col: integer;	begin		ClearCell(empty);		FillCells(r, empty);		for row := r.top to r.bottom - 1 do			for col := r.left to r.right - 1 do				fMap.SetRowCol(row, col, empty);	end;	procedure TMapView.FillCells (r: Rect; cell: MapCell);		var			row, col: integer;	begin		for row := r.top to r.bottom - 1 do			for col := r.left to r.right - 1 do				fMap.SetRowCol(row, col, cell);	end;	procedure TMapView.SaveForUndo (r: Rect);		var			u: TMapViewUndo;			c: TMapCells;	begin		new(u);		u.fNext := fUndo;		fUndo := u;		new(c);		c.IMapCells(r);		u.fCells := c;		fMap.CopyTo(u.fCells);	end;	procedure TMapView.SaveCellForUndo (cell: Point);		var			cells: Rect;	begin		CellToCells(cell, cells);		SaveForUndo(cells);	end;	procedure TMapView.SaveAllForUndo;		var			cells: Rect;	begin		SetRect(cells, 0, 0, 64, 64);		SaveForUndo(cells);	end;	procedure TMapView.DropFloating;		var			r: Rect;	begin		if fFloating <> nil then begin				fFloating.GetBounds(r);				SaveForUndo(r);				fMap.CopyFrom(fFloating);				fMap.Changed;				DiscardFloating;			end;	end;	procedure TMapView.DiscardUndo;		var			u: TMapViewUndo;	begin		while fUndo <> nil do begin				u := fUndo;				fUndo := u.fNext;				u.fCells.Free;				u.Free;			end;	end;	procedure TMapView.DiscardFloating;	begin		if fFloating <> nil then begin				fFloating.Free;				fFloating := nil;			end;	end;	procedure TMapView.SetupMenus;		var			len, offset: longint;	begin		if (fUndo <> nil) | (fFloating <> nil) then			EnableCmd(undoCmd);		if not EmptyRect(fSelection) then begin				EnableCmd(cutCmd);				EnableCmd(copyCmd);				EnableCmd(clearCmd);				EnableCmd(specialEffectsCmd);				EnableCmd(flipHorizontalCmd);				EnableCmd(flipVerticalCmd);				EnableCmd(rotateLeftCmd);				EnableCmd(rotateRightCmd);			end;		len := GetScrap(nil, mapScrapType, offset);		if len >= 0 then			EnableCmd(pasteCmd);		EnableCmd(levelStatusCmd);		EnableCmd(getLevelInfoCmd);		EnableCmd(newLevelCmd);		inherited SetupMenus;	end;	procedure TMapView.DoMenuCommand (cmdNumber: integer);	begin		case cmdNumber of			undoCmd: 				DoUndo;			cutCmd: 				DoCut;			copyCmd: 				DoCopy;			pasteCmd: 				DoPaste;			clearCmd: 				DoClear;			flipHorizontalCmd: 				DoFlipHorizontal;			flipVerticalCmd: 				DoFlipVertical;			rotateLeftCmd: 				DoRotateLeft;			rotateRightCmd: 				DoRotateRight;			specialEffectsCmd: 				DoSpecialEffects;			levelStatusCmd: 				DoLevelStatus;			getLevelInfoCmd: 				DoGetInfo;			newLevelCmd: 				fMap.fMapList.fView.DoMenuCommand(cmdNumber);		{CreateLevel(fMap.fMapList.fView);}			otherwise begin					DropFloating;					ClearSelection;					inherited DoMenuCommand(cmdNumber);				end;		end;	end;	function HFlipCell (cell: MapCell): MapCell;	begin		if (cell.obj = $14) | (cell.obj = $16) then			cell.obj := BXOR(cell.obj, 2);		if IsSecretDoor(cell) & (BAND(cell.dir, 1) = 1) then			cell.dir := BXOR(cell.dir, 2);		HFlipCell := cell;	end;	function VFlipCell (cell: MapCell): MapCell;	begin		if (cell.obj = $13) | (cell.obj = $15) then			cell.obj := BXOR(cell.obj, 6);		if IsSecretDoor(cell) & (BAND(cell.dir, 1) = 0) then			cell.dir := BXOR(cell.dir, 2);		VFlipCell := cell;	end;	function RotateCell (cell: MapCell; r: integer): MapCell;	begin		if (cell.obj >= $13) & (cell.obj <= $16) then			cell.obj := (cell.obj - $13 + r) mod 4 + $13;		if odd(r) & IsDoor(cell) then begin				cell.wall := BXOR(cell.wall, 1);				cell.obj := BXOR(cell.obj, 1);			end;		if IsSecretDoor(cell) then			cell.dir := (cell.dir + 4 - r) mod 4;		RotateCell := cell;	end;	procedure SwapMapCells (cells: TMapCells; row1, col1, row2, col2: integer; function Modify (cell: MapCell): MapCell);		var			temp: MapCell;			p1, p2: Point;	begin		SetPt(p1, col1, row1);		SetPt(p2, col2, row2);		temp := cells.GetCell(p1);		cells.SetCell(p1, Modify(cells.GetCell(p2)));		cells.SetCell(p2, Modify(temp));	end;	procedure TMapView.DoFlipHorizontal;		var			row, off: integer;	begin		MakeFloating(true);		if fFloating <> nil then begin				for row := fSelection.top to fSelection.bottom - 1 do					for off := 0 to (fSelection.right - fSelection.left + 1) div 2 - 1 do						SwapMapCells(fFloating, row, fSelection.left + off, row, fSelection.right - off - 1, HFlipCell);				InvalidateCells(fSelection);			end;	end;	procedure TMapView.DoFlipVertical;		var			col, off: integer;	begin		MakeFloating(true);		if fFloating <> nil then begin				for col := fSelection.left to fSelection.right - 1 do					for off := 0 to (fSelection.bottom - fSelection.top + 1) div 2 - 1 do						SwapMapCells(fFloating, fSelection.top + off, col, fSelection.bottom - off - 1, col, VFlipCell);				InvalidateCells(fSelection);			end;	end;	procedure TMapView.RotateSelection (procedure RotateRC (row, col: integer; r2: Rect; var p2: Point); rot: integer);		var			newCells: TMapCells;			row, col: integer;			r1, r2: Rect;			p1, p2: Point;	begin		MakeFloating(true);		r1 := fSelection;		SetRect(r2, 0, 0, r1.bottom - r1.top, r1.right - r1.left);		OffsetRect(r2, r1.left, r1.top);		new(newCells);		newCells.IMapCells(r2);		for row := 0 to r1.bottom - r1.top - 1 do			for col := 0 to r1.right - r1.left - 1 do begin					SetPt(p1, r1.left + col, r1.top + row);					RotateRC(row, col, r2, p2);					newCells.SetCell(p2, RotateCell(fFloating.GetCell(p1), rot));				end;		fFloating.Free;		fFloating := newCells;		SetSelectionRect(r2);		InvalidateCells(r1);		InvalidateCells(r2);	end;	procedure RotateRCLeft (row, col: integer; r2: Rect; var p2: Point);	begin		SetPt(p2, r2.left + row, r2.bottom - col - 1);	end;	procedure RotateRCRight (row, col: integer; r2: Rect; var p2: Point);	begin		SetPt(p2, r2.right - row - 1, r2.top + col);	end;	procedure TMapView.DoRotateLeft;	begin		RotateSelection(RotateRCLeft, 3);	end;	procedure TMapView.DoRotateRight;	begin		RotateSelection(RotateRCRight, 1);	end;	procedure TMapView.DoLevelStatus;	begin		ShowLevelStatus(fMap);	end;	procedure TMapView.UpdateCursor;		var			tool: integer;			pt, cell: Point;			cursID: integer;			h: CursHandle;	begin		tool := CurrentTool;		cursID := toolCursIDBase + tool;		if (tool = selectTool) & not EmptyRect(fSelection) then begin				Focus;				GetMouse(pt);				if FindCell(pt, cell) & PtInRect(cell, fSelection) then					cursID := handCursID;			end;		h := GetCursor(cursID);		fFrame.SetCursorHandle(h);	end;	procedure TMapView.Idle;		var			tool: integer;	begin		tool := fTools.GetSelection;		if (tool <> selectTool) & not EmptyRect(fSelection) then begin				DropFloating;				ClearSelection;			end;		inherited Idle;	end;	procedure TMapListDoc.SetEncounter (newEncounter: integer);		var			i: integer;	begin		gEncounter := newEncounter;		fVersion.encounter := newEncounter;		fImagesChanged := true;		UpdateImageViews;	end;{$IFC FALSE}	procedure TMapListDoc.UpdateImageViews;		var			i: integer;	begin		if fImagesChanged then begin				for i := 1 to fNumLevels do					with fIndex^^[i] do						if map <> nil then							with TMapView(map.fView) do begin									Invalidate;									fPalette.ImagesChanged;								end;				fImagesChanged := false;			end;	end;{$ENDC}end.