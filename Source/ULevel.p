unit ULevel;interface	const	{BSP node flags}		bspTerminal = $80;			{Terminal node?}		bspNontermKnown = $01;	{Known flag bits for nonterminal nodes:}		bspSplitDir = $01;			{Direction of split for nonterminal node...}		bspSplitH = $00;				{...horizontal}		bspSplitV = $01;				{...vertical}		bspTermKnown = $43;		{Known flag bits for terminal nodes:}		bspLastSeg = $40;			{Last segment of terminal node}		bspSegType = $03;			{Type of segment...}		bspFaceEast = 0;				{... east facing wall}		bspFaceSouth = 1;				{...south facing wall}		bspFaceWest = 2;				{...west facing wall}		bspFaceNorth = 3;				{... north facing wall}	{Object codes and resource IDs}		firstWallCode = $81;		lastWallCode = $9D;		firstObjectCode = $17;		lastEditableObjectCode = $3A;		lastObjectCode = $3B;		firstSpriteBrgrID = 428;		firstObjectBrgrID = 562;		lastObjectBrgrID = firstObjectBrgrID + lastEditableObjectCode - firstObjectCode;		lastSpriteBrgrID = 601;		firstMiscBrgrID = 133;		titleImageBrgrID = 133;		titlePalleteBrgrID = 134;		soundEffectListBrgrID = 135;		darkTableBrgrID = 136;		intermissionImageBrgrID = 139;		intermissionPaletteBrgrID = 140;		intermissionAnimationBrgrID = 141;		interface320BrgrID = 142;		interface512BrgrID = 143;		interface640BrgrID = 144;		interfacePaletteID = 145;		getPsychedBrgrID = 148;		lastMiscBrgrID = 148;		levelNameStrID = 1;		levelPictID = 1;	type		Byte = 0..255;		LittleEndianWord = packed record				lo, hi: Byte;			end;		LevelHandle = ^LevelPtr;		LevelPtr = ^LevelRecord;		LevelRecord = record				case integer of					0: (							map: packed array[0..63, 0..63] of Byte;							zones: packed array[0..63] of Byte;							numObjects: LittleEndianWord;							objOffset: LittleEndianWord;							numBSPEntries: LittleEndianWord;							bspOffset: LittleEndianWord;					);					1: (							bytes: packed array[0..16383] of Byte;					);			end;		ObjectPtr = ^ObjectEntry;		ObjectEntry = packed record				x, y: Byte;				code, code2: Byte;			end;		BSPNodeType = (nonterminal, terminal);		BSPEntryPtr = ^BSPEntry;		BSPEntry = packed record				coord0: Byte;				flags: Byte;				case BSPNodeType of					nonterminal: (							links: array[0..1] of LittleEndianWord;					);					terminal: (							coord1, coord2: Byte;							grid: Byte;							area: Byte;					);			end;		MapListEntry = record				nextLevel: integer;				altNextLevel: integer;				parTime: integer;				majorFloor: integer;				minorFloor: integer;			end;		LevelInfoHandle = ^LevelInfoPtr;		LevelInfoPtr = ^LevelInfoRecord;		LevelInfoRecord = record				mapListEntry: MapListEntry;				music: integer;			end;		MapListHandle = ^MapListPtr;		MapListPtr = ^MapListRecord;		MapListRecord = record				numLevels: integer;				firstLevelID: integer;				entries: array[1..999] of MapListEntry;			end;		MusicListHandle = ^MusicListPtr;		MusicListPtr = ^MusicListRecord;		MusicListRecord = record				title: integer;				betweenLevels: integer;				levels: array[1..999] of integer;			end;		WallListEntry = packed record				darkFlag: boolean;				mirrorFlag: boolean;				brgrID: 0..$3FFF;			end;		WallListHandle = ^WallListPtr;		WallListPtr = ^WallListRecord;		WallListRecord = record				numEntries: integer;				entries: array[0..63] of WallListEntry;			end;	function BigEndian (w: LittleEndianWord): integer;	procedure SetLittleEndian (var w: LittleEndianWord; i: integer);	function GetObject (h: LevelHandle; var offset: longint; var obj: ObjectEntry): boolean;	procedure GetBSPEntry (h: LevelHandle; num: integer; var entry: BSPEntry);	procedure PutObject (h: LevelHandle; var offset: longint; obj: ObjectEntry);	procedure PutBSPEntry (h: LevelHandle; num: integer; entry: BSPEntry);	procedure DisposeLevel (h: LevelHandle);	function NewLevelInfo: LevelInfoHandle;	procedure DisposeLevelInfo (h: LevelInfoHandle);	function NewMapList (numLevels: integer): MapListHandle;	procedure DisposeMapList (h: MapListHandle);	function NewMusicList (numLevels: integer): MusicListHandle;	procedure DisposeMusicList (h: MusicListHandle);implementation	function BigEndian (w: LittleEndianWord): integer;	begin		BigEndian := BSL(w.hi, 8) + w.lo;	end;	procedure SetLittleEndian (var w: LittleEndianWord; i: integer);	begin		w.hi := BSR(i, 8);		w.lo := BAND(i, $FF);	end;	procedure NextObject (var offset: longint; obj: ObjectEntry);	begin		if obj.code = $62 then			offset := offset + 4		else			offset := offset + 3;	end;	function GetObject (h: LevelHandle; var offset: longint; var obj: ObjectEntry): boolean;		var			p: longint;	begin		p := BigEndian(h^^.objOffset) + offset;		if p < BigEndian(h^^.bspOffset) then begin				obj := ObjectPtr(@h^^.bytes[p])^;				GetObject := true;				NextObject(offset, obj);			end		else			GetObject := false;	end;	procedure PutObject (h: LevelHandle; var offset: longint; obj: ObjectEntry);		var			p: longint;			q: ObjectPtr;	begin		p := BigEndian(h^^.objOffset) + offset;		q := ObjectPtr(@h^^.bytes[p]);		q^ := obj;		NextObject(offset, obj);	end;	procedure GetBSPEntry (h: LevelHandle; num: integer; var entry: BSPEntry);		var			p: longint;	begin		p := BigEndian(h^^.bspOffset) + 6 * num;		entry := BSPEntryPtr(@h^^.bytes[p])^;	end;	procedure PutBSPEntry (h: LevelHandle; num: integer; entry: BSPEntry);		var			p: longint;			q: BSPEntryPtr;	begin		p := BigEndian(h^^.bspOffset) + 6 * num;		q := BSPEntryPtr(@h^^.bytes[p]);		q^ := entry;	end;	procedure DisposeLevel (h: LevelHandle);	begin		DisposHandle(Handle(h));	end;	function NewLevelInfo: LevelInfoHandle;	begin		NewLevelInfo := LevelInfoHandle(NewHandle(sizeof(LevelInfoRecord)));	end;	procedure DisposeLevelInfo (h: LevelInfoHandle);	begin		DisposHandle(Handle(h));	end;	function NewMapList (numLevels: integer): MapListHandle;	begin		NewMapList := MapListHandle(NewHandle(4 + 10 * numLevels));	end;	procedure DisposeMapList (h: MapListHandle);	begin		DisposHandle(Handle(h));	end;	function NewMusicList (numLevels: integer): MusicListHandle;	begin		NewMusicList := MusicListHandle(NewHandle((2 + numLevels) * sizeof(integer)));	end;	procedure DisposeMusicList (h: MusicListHandle);	begin		DisposHandle(Handle(h));	end;end.