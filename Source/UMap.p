unit UMap;interface	uses		UWolfDoc;implementation	uses		UCreateLevel;	const		noStartPosAlrtID = 130;	procedure TMap.IMap (itsMapList: TMapListDoc; itsLevelNumber: integer);		var			row, col: integer;			bounds: Rect;			cell: Point;			init: MapCell;			pt: Point;			cells: TMapCells;	begin		IEvtHandler(itsMapList);		fMapList := itsMapList;		fLevelNumber := itsLevelNumber;		fChanged := false;		fView := nil;		SetRect(bounds, 0, 0, 64, 64);		SetPt(fStartPos, 0, 0);		fStartPosSet := false;		new(cells);		cells.IMapCells(bounds);		fCells := cells;		ClearCell(init);		InsertWallOrDoor(init, $81);		for row := 0 to 63 do begin				cell.v := row;				for col := 0 to 63 do begin						cell.h := col;						fCells.SetCell(cell, init);					end;			end;{$IFC FALSE}		ClearCell(init);		init.obj := $6C;		SetRowCol(63, 61, init);		ClearCell(init);		init.wall := $81;		init.obj := $62;		SetRowCol(63, 62, init);		ClearCell(init);		init.obj := $32;		SetRowCol(63, 63, init);{$ELSEC}		ClearCell(init);		init.obj := $14; {Start}		SetPt(pt, 1, 1);		SetCell(pt, init);		ClearCell(init);		init.wall := $81;		init.obj := $62; {Secret Door}		init.dir := 3;		SetRowCol(1, 2, init);		ClearCell(init);		SetRowCol(1, 3, init);		ClearCell(init);		init.obj := $6C; {Brown Guard}		SetRowCol(2, 3, init);		ClearCell(init);		init.obj := $32; {Treasure}		SetRowCol(2, 4, init);{$ENDC}	end;	procedure TMap.Free;	begin		if fView <> nil then			fView.fFrame.fWindow.Free;		if fMapList <> nil then			fMapList.fIndex^^[fLevelNumber].map := nil;		if fCells <> nil then			fCells.Free;		inherited Free;	end;	procedure TMap.Close;	begin		fMapList.CloseLevel(fLevelNumber);	end;	procedure TMap.SetupMenus;	begin		EnableCmd(closeCmd);		inherited SetupMenus;	end;	procedure TMap.LoadFromResource (h: LevelHandle);		var			row, col, x, y, i: integer;			p: longint;			e: ObjectEntry;			b: BSPEntry;			empty: MapCell;			map: MapCellGrid;		procedure PokeItem (item: integer; var code: MapCell);		begin			code := empty;			if BAND(item, $80) <> 0 then				InsertWallOrDoor(code, item);		end;		procedure PokeObject (var e: ObjectEntry; var code: MapCell);			var				room: integer;		begin			if e.code = $FF then begin					room := h^^.map[e.y, e.x];					code.area := h^^.zones[room] + 1;				end			else if BAND(e.code, $F0) = $E0 then				code.missingQuarters := BAND(e.code, $F)			else begin					InsertObject(code, e.code);					if (e.code >= $13) & (e.code <= $16) then begin							SetPt(fStartPos, e.x, e.y);							fStartPosSet := true;						end;					if e.code = $62 then						InsertObjectExtra(code, e.code2);				end;			if IsDoor(code) then				code.noDoorSide := true;		end;		procedure CheckSecretDoor (row, col, dir: integer);			var				code: MapCell;		begin			if (row >= 0) & (col >= 0) then begin					code := map[row, col];					if IsSecretDoor(code) then						map[row, col].dir := dir;				end;		end;		procedure CheckSpecial (row, col, grid, dir: integer);			var				code: MapCell;		begin			if (row >= 0) & (col >= 0) then begin					code := map[row, col];					if IsDoor(code) then begin							if grid >= $81 then begin									code.flushDoor := true;									code.dir := dir;								end							else if grid = $80 then								code.noDoorSide := false;						end;					map[row, col] := code;				end;		end;	begin		ClearCell(empty);		for row := 0 to 63 do			for col := 0 to 63 do				PokeItem(h^^.map[row, col], map[row, col]);		p := 0;		while GetObject(h, p, e) do			PokeObject(e, map[e.y, e.x]);		for i := 0 to BigEndian(h^^.numBSPEntries) - 1 do begin				GetBSPEntry(h, i, b);				if ((BAND(b.flags, bspTerminal) <> 0) & not odd(b.coord0)) then begin						y := b.coord0 div 2;						x := b.coord1 div 2;						case BAND(b.flags, bspSegType) of							bspFaceNorth:  begin									CheckSecretDoor(y, x, sdSouth);									CheckSpecial(y - 1, x, b.grid, sdSouth);								end;							bspFaceSouth:  begin									CheckSecretDoor(y - 1, x, sdNorth);									CheckSpecial(y, x, b.grid, sdNorth);								end;							bspFaceEast:  begin									CheckSecretDoor(x, y - 1, sdWest);									CheckSpecial(x, y, b.grid, sdWest);								end;							bspFaceWest:  begin									CheckSecretDoor(x, y, sdEast);									CheckSpecial(x, y - 1, b.grid, sdEast);								end;						end;					end;			end;		fCells.CopyFromGrid(map);	end;	function TMap.CreateResource (var h: LevelHandle; name: string): OSErr;	begin		if not fStartPosSet then begin				ParamText(name, '', '', '');				if Ask(noStartPosAlrtID) = cancel then begin						CreateResource := suppressErr;						exit(CreateResource);					end;			end;{CreateResource := CreateLevelFromMap(fCells, h, name, fMapList.fVersion.encounter < 3);}		CreateResource := CreateLevelFromMap(fCells, h, name, true);	end;	procedure TMap.Changed;	begin		fChanged := true;		fMapList.Changed;	end;	function TMap.GetCell (cell: Point): MapCell;	begin		GetCell := fCells.GetCell(cell);	end;	procedure TMap.SetCell (cell: Point; code: MapCell);		var			item: integer;			oldCode: MapCell;	begin		item := ExtractObject(code);		if (item >= $13) & (item <= $16) then begin				if fStartPosSet then begin						oldCode := fCells.GetCell(fStartPos);						InsertObject(oldCode, 0);						fCells.SetCell(fStartPos, oldCode);					end;				fStartPos := cell;				fStartPosSet := true;			end		else if fStartPosSet & EqualPt(cell, fStartPos) then			fStartPosSet := false;		fCells.SetCell(cell, code);	end;	function TMap.GetRowCol (row, col: integer): MapCell;		var			cell: Point;	begin		cell.v := row;		cell.h := col;		GetRowCol := fCells.GetCell(cell);	end;	procedure TMap.SetRowCol (row, col: integer; code: MapCell);		var			cell: Point;	begin		cell.v := row;		cell.h := col;		fCells.SetCell(cell, code);	end;	procedure TMap.CopyFrom (src: TMapCells);		var			r: Rect;			cell: Point;			row, col: integer;	begin		src.GetBounds(r);		for row := r.top to r.bottom - 1 do begin				cell.v := row;				for col := r.left to r.right - 1 do begin						cell.h := col;						SetCell(cell, src.GetCell(cell));					end;			end;	end;	procedure TMap.CopyTo (dst: TMapCells);		var			r: Rect;			cell: Point;			row, col: integer;	begin		dst.GetBounds(r);		for row := r.top to r.bottom - 1 do begin				cell.v := row;				for col := r.left to r.right - 1 do begin						cell.h := col;						dst.SetCell(cell, GetCell(cell));					end;			end;	end;end.