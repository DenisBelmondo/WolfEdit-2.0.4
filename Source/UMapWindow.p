unit UMapWindow;interface	uses		UGoof, UXWindow, UScreen, UWolfDoc, UMapView;	type		TMapWindow = object(TXWindow)				fMapView: TMapView;				fImageViewsNeedUpdating: boolean;				procedure IMapWindow (itsMap: TMap);				procedure Close;				override;				procedure SetupMenus;				override;				procedure DoMenuCommand (cmdNumber: integer);				override;				procedure UpdateCursor (pt: Point);				override;				procedure UpdateTitle;				override;				procedure Activate;				override;				procedure InvalidateImageViews;				procedure UpdateImageViews;			end;implementation	uses		UWolfDoc, UMapCellsView;	const		mapWindID = 128;		smallMapWindID = 131;	procedure TMap.MakeWindow;		var			win: TMapWindow;	begin		new(win);		win.IMapWindow(self);	end;	procedure TMapWindow.IMapWindow (itsMap: TMap);		var			fop: FrameOptions;			i: integer;			vh: VHSelect;			mapList: TMapListDoc;			id: integer;			mapView: TMapView;	begin		fMapView := nil;		fImageViewsNeedUpdating := false;		mapList := nil;		if itsMap <> nil then			mapList := itsMap.fMapList;		if IsSmallScreen then			id := smallMapWindID		else			id := mapWindID;		IGetNewCWindow(mapList, id, [wGoAwayBox, wGrowBox, wCloseOnGoAway]);		new(mapView);		mapView.IMapView(itsMap);		fMapView := mapView;		if fMapView.fPalette <> nil then			Place(fMapView.fPalette, nil, nil, 0, 0, natural, natural, [frmBorder]);		if fMapView.fTools <> nil then			Place(fMapView.fTools, nil, fMapView.fPalette, 0, 1, natural, natural, [frmBorder]);		fop := [frmHScroll, frmVScroll, frmHResize, frmVResize, frmGrowBox, frmBorder];		Place(fMapView, fMapView.fTools, fMapView.fPalette, 1, 1, fill, fill, fop);		for vh := v to h do			fMapView.fFrame.fLineSize.vh[vh] := (fMapView.fCellSize.vh[vh] + fMapView.fBorderSize.vh[vh]);		fTarget := fMapView;		UpdateTitle;		Show;	end;	procedure TMapWindow.Close;	begin		if fMapView <> nil then			fMapView.Close;	end;	procedure TMapWindow.SetupMenus;		var			cmd: integer;	begin		fMapView.fPalette.SetupPaletteMenus(fMapView.fMap.fMapList.fVersion.encounter);		inherited SetupMenus;	end;	procedure TMapWindow.DoMenuCommand (cmdNumber: integer);		var			encounter: integer;	begin		if not fMapView.fPalette.SelectByCommand(cmdNumber) then			inherited DoMenuCommand(cmdNumber);	end;	procedure TMapWindow.UpdateCursor (pt: Point);		var			tool: integer;	begin		fMapView.UpdateCursor;		inherited UpdateCursor(pt);	end;	procedure TMapWindow.UpdateTitle;		var			map: TMap;			ml: TMapListDoc;	begin		if fMapView <> nil then begin				map := fMapView.fMap;				if map <> nil then begin						ml := map.fMapList;						if ml <> nil then							SetTitle(concat(ml.GetLevelName(map.fLevelNumber), ' of ', ml.fFileName));					end;			end;	end;	procedure TMapWindow.Activate;	begin		inherited Activate;		UpdateImageViews;	end;	procedure TMapWindow.InvalidateImageViews;	begin		fImageViewsNeedUpdating := true;		if fWMgrWindow = FrontWindow then			UpdateImageViews;	end;	procedure TMapWindow.UpdateImageViews;	begin		if fImageViewsNeedUpdating then begin				fMapView.Invalidate;				fMapView.fPalette.ImagesChanged;				fImageViewsNeedUpdating := false;			end;	end;	procedure TMapListDoc.UpdateImageViews;		procedure CheckWindow (win: TWindow);		begin			if member(win, TMapWindow) then				TMapWindow(win).InvalidateImageViews;		end;	begin {TMapListDoc.UpdateImageViews}		EachWindowDo(CheckWindow);	end;end.