unit UImageCache;interface	uses		ObjIntf, QDOffscreen;	const	{Wall views}		northSouthView = 0;		eastWestView = 1;		bothViews = 2;	type		CustomImageType = (wallImage, objectImage);		CustomMaskSet = set of 0..255;		CustomMaskArray = array[CustomImageType] of CustomMaskSet;		TImageCache = object(TObject)				fGWorld: GWorldPtr;				fCustomMask: CustomMaskArray;				fUserMask: CustomMaskArray;				procedure IImageCache;				procedure IImageCacheFrom (other: TImageCache);				procedure Free;				override;				procedure InstallDefaultImages;				procedure WithGWorld (procedure DoIt);				procedure PlotImage (imageNum: integer; r: Rect);				procedure PlotWall (code: integer; r: Rect);				procedure PlotObject (code, dir: integer; r: Rect);				procedure PlotSound (r: Rect);				procedure PlotUnknown (r: Rect);				procedure InstallWallImage (code, view: integer; gWorld: GWorldPtr);				procedure InstallDoorImage (code: integer; gWorld: GWorldPtr);				procedure InstallObjectImage (code: integer; gWorld: GWorldPtr);				procedure InstallImage (imageNum, view: integer; gWorld: GWorldPtr; dh, dv: integer);				function ExtractPicture: PicHandle;				procedure InstallPicture (pict: Pichandle);				function ExtractImagePict (imageType: CustomImageType; code: integer): PicHandle;				procedure InstallImagePict (pict: PicHandle; srcImageNum, dstImageNum: integer);			end;	{Variant object descriptors}		PMODHandle = ^PMODPtr;		PMODPtr = ^PMODRecord;		PMODRecord = record				itemType: integer;							{Wall or object}				firstCode, lastCode: integer;				{Range of codes to which it applies}				firstCmd, lastCmd: integer;				{Range of menu items}				entries: array[0..99] of record						encounter: integer;	{Encounter in which first available}						offset: integer;			{Code offset for each menu item}						cicnID: integer;			{cicn to overplot}					end;			end;		VariantObjectTable = array[$00..$FF] of record				baseObject: integer;				extraImage: integer;			end;	var		gDefaultImageCache: TImageCache;		gVariantObjectTable: VariantObjectTable;	procedure IUImageCache;	function GetImageNum (imageType: CustomImageType; code: integer): integer;	function WallAvailableIn (code: integer; encounter: integer): boolean;	function ObjectAvailableIn (code: integer; encounter: integer): boolean;implementation	uses		UGoof;	const		unknownCodeIconID = 257;		cellIconIDBase = 5000;		noMemForImageCacheAlrtID = 135;		cantCreateImageCacheAlrtID = 136;		soundCIconID = 258;	{IMAG resource entry types}		wallEntry = 1;		objEntry = 2;		dirObjEntry = 3;	type	{Table mapping wall codes to image table entries}		WallTableEntry = record				encounter: integer;			{Encounter available in}				imageNum: integer;			{Image table index}			end;		WallTableHandle = ^WallTablePtr;		WallTablePtr = ^WallTable;		WallTable = array[$00..$FF] of WallTableEntry;	{Table mapping object codes and directions to image table entries}		ObjectTableEntry = record				encounter: integer;							{Encounter available in}				imageNum: array[0..3] of integer;	{Image table index for each direction}			end;		ObjectTableHandle = ^ObjectTablePtr;		ObjectTablePtr = ^ObjectTable;		ObjectTable = array[$00..$FF] of ObjectTableEntry;	{Table of icons representing walls and objects}		ImageTableEntry = CIconHandle;		ImageTableHandle = ^ImageTablePtr;		ImageTablePtr = ^ImageTable;		ImageTable = array[0..999] of ImageTableEntry;	{Wall and object table initialisation resource}		IMAGEntry = record				code: integer;				{Wall or object code}				cicn: integer;				{cicn resource id}			end;		IMAGHandle = ^IMAGPtr;		IMAGPtr = ^IMAGRecord;		IMAGRecord = record				encounter: integer;		{Encounter available in}				entryType: integer;		{wallEntry, objEntry, dirObjEntry}				numEntries: integer;		{Number of entries to follow}				entries: array[1..999] of IMAGEntry;			end;	var		gWallTable: WallTableHandle;		gObjectTable: ObjectTableHandle;		gImageTable: ImageTableHandle;		gUnknownImageNum: integer;		gSoundImageNum: integer;		gNextImageNum: integer;{-------------------------- Unit Initialisation ------------------------}	procedure AllocateWallAndObjectTables;		var			i, j: integer;	begin		gWallTable := WallTableHandle(NewHandle(sizeof(WallTable)));		gObjectTable := ObjectTableHandle(NewHandle(sizeof(ObjectTable)));		for i := $00 to $FF do begin				with gWallTable^^[i] do begin						encounter := 0;						imageNum := 0;					end;				with gObjectTable^^[i] do begin						encounter := 0;						for j := 0 to 3 do							imageNum[j] := 0;					end;			end;	end;	procedure ForEachIMAG (procedure ProcessIMAG (imag: IMAGHandle));		var			i: integer;			h: Handle;	begin		i := 128;		while true do begin				h := GetResource('IMAG', i);				if h = nil then					exit(ForEachIMAG);				ProcessIMAG(IMAGHandle(h));				ReleaseResource(h);				i := i + 1;			end;	end;	procedure ForEachPMOD (procedure ProcessPMOD (pmod: PMODHandle));		var			i: integer;	begin		for i := 1 to CountResources('PMOD') do			ProcessPMOD(PMODHandle(GetIndResource('PMOD', i)));	end;	function CountImages: integer;		var			n: integer;		procedure CountIMAGEntries (imag: IMAGHandle);		begin			case imag^^.entryType of				wallEntry, objEntry: 					n := n + imag^^.numEntries;				dirObjEntry: 					n := n + 4 * imag^^.numEntries;			end;		end;		procedure CountPMODEntries (pmod: PMODHandle);		begin			with pmod^^ do				n := n + lastCmd - firstCmd + 1;		end;	begin {CountImages}		n := 0;		ForEachIMAG(CountIMAGEntries);		ForEachPMOD(CountPMODEntries);		CountImages := n;	end;	procedure AllocateImageTable;	begin		gImageTable := ImageTableHandle(NewHandle(1 + CountImages * sizeof(ImageTableEntry)));		gImageTable^^[0] := GetCIcon(unknownCodeIconID);		gNextImageNum := 1;	end;	function AllocateImage (cicn: integer): integer;	begin		if cicn > 0 then begin				AllocateImage := gNextImageNum;				gImageTable^^[gNextImageNum] := GetCIcon(cicn);				gNextImageNum := gNextImageNum + 1;			end		else			AllocateImage := -1;	end;	procedure InstallWallEntry (code: integer; itsEncounter, itsCicn: integer);	begin		with gWallTable^^[code] do begin				encounter := itsEncounter;				imageNum := AllocateImage(itsCicn);			end;	end;	procedure InstallObjEntry (code: integer; itsEncounter, itsCicn: integer);		var			itsImageNum: integer;			j: integer;	begin		itsImageNum := AllocateImage(itsCicn);		with gObjectTable^^[code] do begin				encounter := itsEncounter;				for j := 0 to 3 do					imageNum[j] := itsImageNum;			end;	end;	procedure InstallDirObjEntry (code: integer; itsEncounter, itsFirstCicn: integer);		var			j: integer;	begin		with gObjectTable^^[code] do begin				encounter := itsEncounter;				for j := 0 to 3 do					imageNum[j] := AllocateImage(itsFirstCicn + j);			end;	end;	procedure InitFromIMAG (imag: IMAGHandle);		var			encounter, i, t: integer;	begin		encounter := imag^^.encounter;		t := imag^^.entryType;		for i := 1 to imag^^.numEntries do			with imag^^.entries[i] do				case t of					wallEntry: 						InstallWallEntry(code, encounter, cicn);					objEntry: 						InstallObjEntry(code, encounter, cicn);					dirObjEntry: 						InstallDirObjEntry(code, encounter, cicn);				end;	end;	procedure InitTables;	begin		gSoundImageNum := AllocateImage(soundCIconID);		ForEachIMAG(InitFromIMAG);	end;	procedure GetImageCacheRect (imageNum: integer; var r: Rect);	begin		SetRect(r, 0, 0, 16, 16);		OffsetRect(r, 16 * imageNum, 0);	end;	function GetImageIcon (imageNum: integer): CIconHandle;	begin		GetImageIcon := gImageTable^^[imageNum];	end;	procedure InitVariantObjectTable;		var			i, cmd, code, image: integer;			pmod: PMODHandle;	begin		for i := 0 to 255 do			with gVariantObjectTable[i] do begin					baseObject := -1;					extraImage := -1;				end;		for i := 1 to CountResources('PMOD') do begin				pmod := PMODHandle(GetIndResource('PMOD', i));				HLock(Handle(pmod));				with pmod^^ do					for cmd := firstCmd to lastCmd do						with entries[cmd - firstCmd] do							if offset <> 0 then begin									image := AllocateImage(cicnID);									for code := firstCode to lastCode do										with gVariantObjectTable[code + offset] do begin												baseObject := code;												extraImage := image;											end;								end;				HUnlock(Handle(pmod));			end;	end;	procedure InitDefaultImageCache;	begin		new(gDefaultImageCache);		gDefaultImageCache.IImageCache;		gDefaultImageCache.InstallDefaultImages;	end;	procedure IUImageCache;	begin		AllocateWallAndObjectTables;		AllocateImageTable;		InitTables;		InitVariantObjectTable;		InitDefaultImageCache;	end;{---------------------------- Utilities ------------------------------}	function GetWallImageNum (code: integer): integer;	begin		GetWallImageNum := gWallTable^^[code].imageNum;	end;	function GetObjectImageNum (code, dir: integer): integer;	begin		GetObjectImageNum := gObjectTable^^[code].imageNum[dir];	end;	function GetImageNum (imageType: CustomImageType; code: integer): integer;	begin		case imageType of			wallImage: 				GetImageNum := GetWallImageNum(code);			objectImage: 				GetImageNum := GetObjectImageNum(code, 0);		end;	end;	function WallAvailableIn (code: integer; encounter: integer): boolean;	begin		WallAvailableIn := gWallTable^^[code].encounter <= encounter;	end;	function ObjectAvailableIn (code: integer; encounter: integer): boolean;	begin		ObjectAvailableIn := gObjectTable^^[code].encounter <= encounter;	end;	procedure ClearPort;	begin		EraseRect(thePort^.portRect);	end;{------------------------------- TImageCache Methods ------------------------------}	procedure TImageCache.IImageCache;		var			result: OSErr;			bounds: Rect;			gWorld: GWorldPtr;	begin		gWorld := nil;		SetRect(bounds, 0, 0, 16 * gNextImageNum, 16);	{writeln('TImageCache.IImagCache: ',FreeMem:1,' bytes free before creating GWorld');}		result := NewGWorld(gWorld, 0, bounds, nil, nil, []);		fGWorld := gWorld;	{writeln('TImageCache.IImagCache: ',FreeMem:1,' bytes free after creating GWorld');}		if (result <> noErr) | (fGWorld = nil) then begin				if result = memFullErr then					DoAlert(noMemForImageCacheAlrtID)				else					ErrorAlert(cantCreateImageCacheAlrtID, '', result);				ExitToShell;			end;		if not LockPixels(GetGWorldPixMap(fGWorld)) then			Panic('InitImageCache', 'LockPixels returned false');		WithGWorld(ClearPort);		HLock(Handle(self));		fCustomMask[wallImage] := [];		fCustomMask[objectImage] := [];		fUserMask[wallImage] := [];		fUserMask[objectImage] := [];		HUnlock(Handle(self));	end;	procedure TImageCache.IImageCacheFrom (other: TImageCache);		var			r: Rect;	begin		IImageCache;		r := fGWorld^.portRect;		CopyBits(BitMapPtr(GetGWorldPixMap(other.fGWorld)^)^, BitMapPtr(GetGWorldPixMap(fGWorld)^)^, r, r, srcCopy, nil);	end;	procedure TImageCache.Free;	begin		DisposeGWorld(fGWorld);	end;	procedure TImageCache.InstallDefaultImages;		var			imageNum: integer;			h: CIconHandle;			dr: Rect;		procedure CacheImageIcon;		begin			EraseRect(dr);			if h <> nil then				PlotCIcon(dr, h);		end;	begin {TImageCache.InstallDefaultImages}		if fGWorld <> nil then begin				for imageNum := 0 to gNextImageNum - 1 do begin						h := GetImageIcon(imageNum);						GetImageCacheRect(imageNum, dr);						WithGWorld(CacheImageIcon);					end;			end;	end;	procedure TImageCache.WithGWorld (procedure DoIt);		var			oldPort: GWorldPtr;			oldDev: GDHandle;	begin		GetGWorld(oldPort, oldDev);		SetGWorld(fGWorld, nil);		DoIt;		SetGWorld(oldPort, oldDev);	end;	procedure TImageCache.PlotImage (imageNum: integer; r: Rect);		var			sr: Rect;	begin		if fGWorld <> nil then begin				ForeColor(blackColor);				BackColor(whiteColor);				if imageNum >= 0 then begin						GetImageCacheRect(imageNum, sr);						CopyBits(BitMapPtr(fGWorld^.portPixMap^)^, thePort^.portBits, sr, r, transparent, nil);					end				else					EraseRect(r);			end		else			PlotCIcon(r, GetImageIcon(imageNum));	end;	procedure TImageCache.PlotWall (code: integer; r: Rect);	begin		PlotImage(GetWallImageNum(code), r);	end;	procedure TImageCache.PlotObject (code, dir: integer; r: Rect);	begin		PlotImage(GetObjectImageNum(code, dir), r);	end;	procedure TImageCache.PlotSound (r: Rect);	begin		PlotImage(gSoundImageNum, r);	end;	procedure TImageCache.PlotUnknown (r: Rect);	begin		PlotImage(gUnknownImageNum, r);	end;	procedure TImageCache.InstallWallImage (code, view: integer; gWorld: GWorldPtr);	begin		InstallImage(GetWallImageNum(code), view, gWorld, 0, 0);	end;	procedure TImageCache.InstallDoorImage (code: integer; gWorld: GWorldPtr);		var			shrink: Point;	begin		case BAND(code, 1) of			0: 				SetPt(shrink, 3, 0);			1: 				SetPt(shrink, 0, 3);		end;		InstallImage(GetObjectImageNum(code, 0), bothViews, gWorld, shrink.h, shrink.v);    {$IFC FALSE}		InstallImage(GetObjectImageNum(BAND(code, $FE), 0), bothViews, gWorld, 4, 0);		InstallImage(GetObjectImageNum(BOR(code, $01), 0), bothViews, gWorld, 0, 4);    {$ENDC}	end;	procedure TImageCache.InstallObjectImage (code: integer; gWorld: GWorldPtr);	begin		InstallImage(GetObjectImageNum(code, 0), bothViews, gWorld, 0, 0);	end;	function MakeViewMaskRgn (view: integer; r: Rect): RgnHandle;		var			rgn: RgnHandle;	begin		OpenRgn;		case view of			bothViews: 				FrameRect(r);			northSouthView:  begin					MoveTo(r.left, r.top);					LineTo(r.right, r.top);					LineTo(r.left, r.bottom);					LineTo(r.right, r.bottom);					LineTo(r.left, r.top);				end;			eastWestView:  begin					MoveTo(r.left, r.top);					LineTo(r.left, r.bottom);					LineTo(r.right, r.top);					LineTo(r.right, r.bottom);					LineTo(r.left, r.top);				end;		end;		rgn := NewRgn;		CloseRgn(rgn);		MakeViewMaskRgn := rgn;	end;	procedure TImageCache.InstallImage (imageNum, view: integer; gWorld: GWorldPtr; dh, dv: integer);		var			sr, dr: Rect;			srcPort: GWorldPtr;			maskRgn: RgnHandle;		procedure CopyTheImage;		begin			if srcPort <> nil then				CopyBits(BitMapPtr(GetGWorldPixMap(srcPort)^)^, BitMapPtr(GetGWorldPixMap(fGWorld)^)^, sr, dr, srcCopy, maskRgn)			else				EraseRgn(maskRgn);		end;	begin {InstallImage}		GetImageCacheRect(imageNum, dr);		maskRgn := MakeViewMaskRgn(view, dr);		if gWorld <> nil then begin				srcPort := gWorld;				sr := gWorld^.portRect;				InsetRect(dr, dh, dv);			end		else begin				if view = bothViews then					srcPort := nil				else					srcPort := gDefaultImageCache.fGWorld;				sr := dr;			end;		WithGWorld(CopyTheImage);		DisposeRgn(maskRgn);	end;	function TImageCache.ExtractPicture: PicHandle;		procedure MakePicture;			var				pict: PicHandle;				r: Rect;		begin			r := thePort^.portRect;			pict := OpenPicture(r);			CopyBits(thePort^.portBits, thePort^.portBits, r, r, srcCopy, nil);			ClosePicture;			ExtractPicture := pict;		end;	begin {ExtractPicture}		WithGWorld(MakePicture);	end;	procedure TImageCache.InstallPicture (pict: Pichandle);		procedure DrawThePict;		begin			DrawPicture(pict, pict^^.picFrame);		end;	begin {InstallPicture}		WithGWorld(DrawThePict);	end;	function TImageCache.ExtractImagePict (imageType: CustomImageType; code: integer): PicHandle;		procedure MakePicture;			var				imageNum: integer;				sr, dr: Rect;				pict: PicHandle;		begin			imageNum := GetImageNum(imageType, code);			GetImageCacheRect(imageNum, sr);			SetRect(dr, 0, 0, 16, 16);			pict := OpenPicture(dr);			CopyBits(thePort^.portBits, thePort^.portBits, sr, dr, srcCopy, nil);			ClosePicture;			ExtractImagePict := pict;		end;	begin {ExtractImagePict}		WithGWorld(MakePicture);	end;	procedure TImageCache.InstallImagePict (pict: PicHandle; srcImageNum, dstImageNum: integer);		procedure DrawThePict;			var				imageNum: integer;				pr, dr: Rect;		begin			pr := pict^^.picFrame;			OffsetRect(pr, 16 * (dstImageNum - srcImageNum), 0);			GetImageCacheRect(dstImageNum, dr);			ClipRect(dr);			DrawPicture(pict, pr);			ClipRect(thePort^.portRect);		end;	begin {InstallImagePict}		WithGWorld(DrawThePict);	end;end.