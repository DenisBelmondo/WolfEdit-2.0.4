unit UMapCellsView;interface	uses		UGoof, UList, UMapCells, UWolfDoc;	type		TMapCellsView = object(TList)				fCells: TMapCells;				fMapList: TMapListDoc;				procedure IMapCellsView (itsCells: TMapCells; opts: ListOptions; itsMapList: TMapListDoc);				procedure DrawCell (cell: Point; r: Rect; var hilite: boolean);				override;				function GetCellForDrawing (cell: Point): MapCell;			end;	procedure IUMapCellsView;implementation	procedure IUMapCellsView;	begin	end;{------------------------------- TMapCellsView Methods ------------------------------}	procedure TMapCellsView.IMapCellsView (itsCells: TMapCells; opts: ListOptions; itsMapList: TMapListDoc);		var			cellSize, borderSize: Point;			r: Rect;	begin		SetPt(cellSize, 16, 16);		SetPt(borderSize, 1, 1);		if itsCells <> nil then			itsCells.GetBounds(r)		else			SetRect(r, 0, 0, 17 * 64, 17 * 64);		IListX(cellSize, borderSize, r, opts);		fCells := itsCells;		fMapList := itsMapList;	end;	procedure PlotQuarteredWall (mapList: TMapListDoc; wall, mq: integer; r: Rect);		var			oldClip, newClip: RgnHandle;			i, j: integer;			s: Rect;	begin		oldClip := NewRgn;		newClip := NewRgn;		GetClip(oldClip);		OpenRgn;		for i := 0 to 1 do			for j := 0 to 1 do				if BAND(mq, BSL(1, j * 2 + i)) = 0 then begin						SetRect(s, i, j, i + 1, j + 1);						FrameRect(s);					end;		CloseRgn(newClip);		SetRect(s, 0, 0, 2, 2);		MapRgn(newClip, s, r);		SectRgn(oldClip, newClip, newClip);		SetClip(newClip);		mapList.PlotWall(wall, r);		SetClip(oldClip);		DisposeRgn(oldClip);		DisposeRgn(newClip);	end;	procedure TMapCellsView.DrawCell (cell: Point; r: Rect; var hilite: boolean);		var			code: MapCell;			s: string[8];	begin		code := GetCellForDrawing(cell);		if (code.wall = 0) or (code.missingQuarters <> 0) then			EraseRect(r);		if code.wall <> 0 then			if code.missingQuarters <> 0 then				PlotQuarteredWall(fMapList, code.wall, code.missingQuarters, r)			else				fMapList.PlotWall(code.wall, r);		if code.obj <> 0 then			fMapList.PlotObject(code.obj, code.dir, r);		if code.area <> 0 then begin				fMapList.PlotSound(r);				TextFont(geneva);				TextSize(9);				TextFace([]);				s := StringOf(code.area : 1);				MoveTo(r.right - StringWidth(s), r.bottom - 1);				DrawString(s);			end;	end;	function TMapCellsView.GetCellForDrawing (cell: Point): MapCell;	begin		GetCellForDrawing := fCells.GetCell(cell);	end;end.