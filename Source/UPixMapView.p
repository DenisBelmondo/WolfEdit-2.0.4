unit UPixMapView;interface	uses		QDOffscreen, UView, UScrap;	type		TPixMapView = object(TView)				fGWorld: GWorldPtr;				fPixMap: PixMapHandle;				fNonEmpty: boolean;				fChanged: boolean;				procedure IPixMapView (itsWidth, itsHeight: integer; itsCTab: CTabHandle);				procedure IPixMapViewX (itsExtent, itsBounds: Rect; itsCTab: CTabHandle);				procedure Free;				override;				procedure ClearGWorld;				procedure WithGWorld (procedure DoIt);				procedure Draw;				override;				procedure SetupMenus;				override;				procedure DoMenuCommand (cmdNumber: integer);				override;				procedure DoCopy;				procedure DoPaste;				procedure DoClear;			end;implementation{$IFC FALSE}	uses		UAnalysePict;{$ENDC}	procedure ClearPort;	begin		EraseRect(thePort^.portRect);	end;	procedure TPixMapView.IPixMapView (itsWidth, itsHeight: integer; itsCTab: CTabHandle);		var			r: Rect;	begin		SetRect(r, 0, 0, itsWidth, itsHeight);		IPixMapViewX(r, r, itsCTab);	end;	procedure TPixMapView.IPixMapViewX (itsExtent, itsBounds: Rect; itsCTab: CTabHandle);		var			result: OSErr;			b: boolean;			gWorld: GWorldPtr;			width: integer;	begin		IView(nil, nil, itsExtent);		result := NewGWorld(gWorld, 8, itsBounds, itsCTab, nil, []);		fGWorld := gWorld;		fPixMap := GetGWorldPixMap(fGWorld);	{--- Make sure rowBytes = width ---}		width := itsBounds.right - itsBounds.left;		with fPixMap^^ do			rowBytes := BOR(BAND(rowBytes, $C000), width);		b := LockPixels(fPixMap);		ClearGWorld;		fNonEmpty := false;		fChanged := false;	end;	procedure TPixMapView.Free;	begin		DisposeGWorld(fGWorld);		inherited Free;	end;	procedure TPixMapView.ClearGWorld;	begin		WithGWorld(ClearPort);	end;	procedure TPixMapView.WithGWorld (procedure DoIt);		var			oldPort: CGrafPtr;			oldDevice: GDHandle;	begin		GetGWorld(oldPort, oldDevice);		SetGWorld(fGWorld, nil);		DoIt;		SetGWorld(oldPort, oldDevice);	end;	procedure TPixMapView.Draw;		var			r: Rect;	begin		EraseRect(fExtent);		r := fGWorld^.portRect;		CopyBits(BitMapPtr(fPixMap^)^, thePort^.portBits, r, r, srcCopy, nil);	end;	procedure TPixMapView.SetupMenus;	begin		if fNonEmpty then begin				EnableCmd(cutCmd);				EnableCmd(copyCmd);				EnableCmd(clearCmd);			end;		if ProbeScrap('PICT') then			EnableCmd(pasteCmd);		inherited SetupMenus;	end;	procedure TPixMapView.DoMenuCommand (cmdNumber: integer);	begin		case cmdNumber of			cutCmd:  begin					DoCopy;					DoClear;				end;			copyCmd: 				DoCopy;			pasteCmd: 				DoPaste;			clearCmd: 				DoClear;			otherwise				inherited DoMenuCommand(cmdNumber);		end;	end;	procedure TPixMapView.DoCopy;		var			pict: PicHandle;		procedure MakeAPict;			var				r: Rect;		begin			r := fExtent;			pict := OpenPicture(r);			Draw;			ClosePicture;		end;	begin {TPixMapView.DoCopy}		WithGWorld(MakeAPict);{ShowPicture(pict);}		ClearScrap;		WriteScrap('PICT', pict);		KillPicture(pict);	end;	procedure TPixMapView.DoPaste;		var			pict: PicHandle;			r: Rect;		procedure DrawThePict;		begin			EraseRect(thePort^.portRect);			DrawPicture(pict, thePort^.portRect);		end;	begin {TPixMapView.DoPaste}		ReadScrap('PICT', pict);		if pict <> nil then begin				WithGWorld(DrawThePict);				Invalidate;				KillPicture(pict);				fNonEmpty := true;				fChanged := true;				if fDocument <> nil then					fDocument.Changed;			end;	end;	procedure TPixMapView.DoClear;	begin		if fNonEmpty then begin				ClearGWorld;				Invalidate;				fNonEmpty := false;				fChanged := true;				if fDocument <> nil then					fDocument.Changed;			end;	end;end.