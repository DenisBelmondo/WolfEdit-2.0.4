unit UView;interface	uses		ObjIntf, UGoof;implementation	procedure TView.IView (itsFrame: TFrame;									itsDocument: TDocument;									itsExtent: Rect);	begin		fFrame := nil;		fDocument := itsDocument;		fExtent := itsExtent;		fTarget := nil;		if itsFrame <> nil then			itsFrame.HaveView(self);	end;	procedure TView.Free;	begin		if fFrame <> nil then			fFrame.HaveView(nil);		inherited Free;	end;	procedure TView.MakeOwnWindow;		var			winOpts: WindowOptions;			frmOpts: FrameOptions;	begin		winOpts := [wGrowBox, wCloseOnGoAway];		frmOpts := [frmBorder, frmHResize, frmVResize, frmHScroll, frmVScroll];		MakeWindow(gIDBase + dfltWindowID, 0, 0, winOpts, frmOpts);	end;	procedure TView.MakeWindow (winID: integer;									width, height: integer;									winOpts: WindowOptions;									frmOpts: FrameOptions);		var			win: TWindow;			frame: TFrame;			fr, wr: Rect;			dh, dv: integer;	begin		if wGrowBox in winOpts then			frmOpts := frmOpts + [frmGrowBox];		if (frmVScroll in frmOpts) then			dh := 15		else			dh := 0;		if (frmHScroll in frmOpts) then			dv := 15		else			dv := 0;		New(win);		win.IWindow(fDocument, GetNewWindow(winID, nil, WindowPtr(-1)), winOpts, true);		win.DefaultPosition;		wr := win.fBounds;		fr.topLeft := wr.topLeft;		if width > 0 then begin				fr.right := width;				wr.right := fr.right + dh;			end		else			fr.right := wr.right - dh;		if height > 0 then begin				fr.bottom := height;				wr.bottom := fr.bottom + dv;			end		else			fr.bottom := wr.bottom - dv;		win.SetBounds(wr);		OffsetRect(fr, -fr.left, -fr.top);		New(frame);		frame.IFrame(win, fr, frmOpts);		frame.HaveView(self);		win.SetTarget(self);		win.Show;		win.Select;	{Why doesn't it always appear in front?}	end;	procedure TView.SetExtent (newExtent: Rect);		var			r1, r2: RgnHandle;			sectExtent: Rect;			junk: boolean;	begin		if not EqualRect(newExtent, fExtent) then begin				if fFrame <> nil then begin						Focus;						junk := SectRect(newExtent, fExtent, sectExtent);						r1 := NewRgn;						r2 := NewRgn;						RectRgn(r1, newExtent);						RectRgn(r2, fExtent);						UnionRgn(r1, r2, r2);						RectRgn(r1, sectExtent);						DiffRgn(r2, r1, r2);						InvalRgn(r2);						DisposeRgn(r1);						DisposeRgn(r2);					end;				fExtent := newExtent;				if fFrame <> nil then					fFrame.UpdateScrollRange;			end;	end;	procedure TView.BeInFrame;	begin		Invalidate;		if fFrame <> nil then begin				fNextHandler := fFrame;				if (fTarget <> nil) & (fFrame.fWindow.fTarget = fFrame.fWindow) then					fFrame.fWindow.SetTarget(fTarget);			end		else			fNextHandler := gDefaultTarget;	end;	procedure TView.ViewDocument (docToView: TDocument);	begin		fDocument := docToView;		Invalidate;	end;	procedure TView.Activate;	begin	{Override this}	end;	procedure TView.Deactivate;	begin	{Override this}	end;	procedure TView.Click (var e: EventInfo);	begin	{Override this}	end;	procedure TView.Draw;	begin	{Override this}	end;	procedure TView.Focus;	begin		if (fFrame <> nil) & (fFrame.fWMgrWindow <> nil) then			fFrame.Focus		else			SetPort(gDummyPort);	end;	procedure TView.Invalidate;	begin		if fFrame <> nil then begin				Focus;				InvalRect(fExtent);			end;	end;	procedure TView.InvalidateRect (badRect: Rect);	begin		if fFrame <> nil then			fFrame.InvalidateRect(badRect);	end;	procedure TView.InvalidateRgn (badRgn: RgnHandle);	begin		if fFrame <> nil then			fFrame.InvalidateRgn(badRgn);	end;	procedure TView.ValidateRect (goodRect: Rect);	begin		if fFrame <> nil then			fFrame.ValidateRect(goodRect);	end;	procedure TView.ValidateRgn (goodRgn: RgnHandle);	begin		if fFrame <> nil then			fFrame.ValidateRgn(goodRgn);	end;	procedure TView.AutoScroll;	begin		if fFrame <> nil then			fFrame.AutoScroll;	end;end.