unit UApplication;interface	uses		ObjIntf, UGoof, UInit;implementation{$SETC UseWaitNextEvent = TRUE}	const		menuBarID = 128;	var		dragRect: Rect;{********************** Procedures and Functions ********************}	procedure DisableAllCmds;		var			i, j, menuID: integer;			menu: MenuHandle;			curMark: char;	begin		for i := 1 to gCmdTable^^.theNumMenus do begin				menuID := gCmdTable^^.theMenus[i]^^.theMenuID;				menu := GetMHandle(menuID);				if menu <> nil then begin						for j := 1 to gCmdTable^^.theMenus[i]^^.theNumItems do							if gCmdTable^^.theMenus[i]^^.theItems[j] <> 0 then begin									DisableItem(menu, j);									GetItemMark(menu, j, curMark);									if (curMark = chr(noMark)) or (curMark = chr(checkMark)) then										CheckItem(menu, j, false);								end;					end;			end;	end;	procedure BuildCmdTable;		type			MBarRsrcHandle = ^MBarRsrcPtr;			MBarRsrcPtr = ^MBarRsrcRec;			MBarRsrcRec = record					theNumMenus: integer;					theRsrcIDs: array[1..255] of integer;				end;		var			menuNum, itemNum, numItems, lbPos, rbPos: integer;			menu: MenuHandle;			itemString: Str255;			cmdNumber: string[8];			cList: CmdListHandle;			mbar: MBarRsrcHandle;			numMenus: integer;	begin		mbar := MBarRsrcHandle(GetResource('MBAR', menuBarID));		numMenus := mbar^^.theNumMenus;		MakeCmdTable(numMenus);		for menuNum := 1 to mbar^^.theNumMenus do begin				menu := GetMenu(mbar^^.theRsrcIDs[menuNum]);				BuildCmdTableEntry(menuNum, menu);			end;		ReleaseResource(Handle(mbar));	end;	procedure InitMenuBar;		var			mbar: Handle;	begin		mbar := GetNewMBar(menuBarID);		SetMenuBar(mbar);		AddResMenu(GetMHandle(appleMenuID), 'DRVR');		DrawMenuBar;	end;{MenuKey seems to do annoying things like ignoring non-alphabetic}{characters. This version doesn't mess about with anything.}	function XMenuKey (ch: char): longint;		const			MenuList = $A1C;		type			MenuDataHandle = ^MenuDataPtr;			MenuDataPtr = ^MenuDataRec;			MenuDataRec = record					menuID: integer;					menuWidth: integer;					menuHeight: integer;					menuProc: Handle;					enableFlags: longint;					menuData: packed array[0..16383] of 0..255;				end;			MListHandlePtr = ^MListHandle;			MListHandle = ^MListPtr;			MListPtr = ^MListRec;			MListRec = record					theLastEntryOffset: integer;					j1, j2: integer;					theEntries: array[1..255] of record							theMHandle: MenuDataHandle;							j3: integer;						end;				end;		var			mList: MListHandle;			menuIndex, item, p: integer;	begin		if (ch >= 'a') & (ch <= 'z') then			ch := chr(ord(ch) + ord('A') - ord('a'));		mList := MListHandle(MListHandlePtr(MenuList)^);		with mList^^ do			for menuIndex := theLastEntryOffset div 6 downto 1 do				with theEntries[menuIndex].theMHandle^^ do begin						p := menuData[0] + 1;						item := 1;						while menuData[p] <> 0 do begin								p := p + menuData[p] + 2;								if chr(menuData[p]) = ch then begin										XMenuKey := BOR(BSL(menuID, 16), item);										Exit(XMenuKey);									end;								p := p + 3;								item := item + 1;							end;					end;		XMenuKey := 0;	end;{************************ Methods ************************}	procedure TApplication.IApplication (itsSignature: OSType);	begin		gAppResFile := CurResFile;		IEvtHandler(nil);		gApplication := self;		gDefaultTarget := self;		CommonInit;		InitMenuBar;		BuildCmdTable;		gCreator := itsSignature;	end;	procedure TApplication.SetupMenus;		var			win: WindowPtr;	begin		EnableCmd(aboutCmd);		EnableCmd(quitCmd);		win := FrontWindow;		if (win <> nil) & (WindowPeek(win)^.windowKind < 0) then begin				EnableCmd(closeCmd);				EnableCmd(undoCmd);				EnableCmd(cutCmd);				EnableCmd(copyCmd);				EnableCmd(pasteCmd);				EnableCmd(clearCmd);			end		else begin				EnableCmd(newCmd);				EnableCmd(openCmd);				if (gFrontWindow <> nil) & (WindowPeek(gFrontWindow.fWMgrWindow)^.goAwayFlag) then					EnableCmd(closeCmd);			end;		inherited SetupMenus;	end;	procedure TApplication.DoMenuCommand (cmdNumber: integer);		var			junk: boolean;	begin		case cmdNumber of			aboutCmd: 				DoAbout;			newCmd: 				DoNew;			openCmd: 				DoOpen;			closeCmd: 				DoClose;			undoCmd, cutCmd, copyCmd, pasteCmd, clearCmd: 				junk := SystemEdit(cmdNumber - undoCmd);			quitCmd: 				DoQuit;			otherwise				inherited DoMenuCommand(cmdNumber);		end;	end;	procedure TApplication.DoInitialDefault;	begin	{DoNew;}	end;	procedure TApplication.DoAbout;	begin	{Override this}	end;	procedure TApplication.DoNew;		var			document: TDocument;	begin		document := MakeOwnDocument;		document.DoNew;		document.MakeWindow;	end;	procedure TApplication.DoOpen;		var			document: TDocument;	begin		document := MakeOwnDocument;		if document.DoOpen then			document.MakeWindow;	end;	procedure TApplication.DoOpenFromFinder (forPrinting: boolean; info: AppFile);		var			document: TDocument;	begin		if not forPrinting then begin				document := MakeOwnDocument;				document.HaveFile(info.vRefNum, info.fName);				if document.Read then					document.MakeWindow;			end;	end;	procedure TApplication.DoClose;		var			win: WindowPeek;	begin		win := WindowPeek(FrontWindow);		if win^.windowKind < 0 then			CloseDeskAcc(win^.windowKind)		else if gFrontWindow <> nil then			gFrontWindow.GoAway;	end;	procedure TApplication.DoQuit;	begin		while gHeadDocument <> nil do begin				if not gHeadDocument.DoClose(true) then					Exit(DoQuit);			end;		ExitToShell;	end;	function TApplication.MakeOwnDocument: TDocument;	begin	{Override this}		Panic('TApplication.MakeOwnDocument', 'Not overridden');	end;	procedure TApplication.Run;		var			e: EventRecord;			junk: boolean;			message, count, i: integer;			info: AppFile;	begin		CountAppFiles(message, count);		if count > 0 then			for i := 1 to count do begin					GetAppFiles(i, info);					DoOpenFromFinder(message = appPrint, info);				end		else			DoInitialDefault;		while true do begin	{$IFC UseWaitNextEvent}				junk := WaitNextEvent(everyEvent, e, 0, nil);	{$ELSEC}				SystemTask;				junk := GetNextEvent(everyEvent, e);	{$ENDC}				DispatchEvent(e);			end;	end;	procedure TApplication.DispatchEvent (var e: EventRecord);	begin		gLastEventRecord := e;		with gLastEvent do begin				what := e.what;				when := e.when;				where := e.where;				theOptionKey := BAND(e.modifiers, optionKey) <> 0;				theAlphaLock := BAND(e.modifiers, alphaLock) <> 0;				theShiftKey := BAND(e.modifiers, shiftKey) <> 0;				theCmdKey := BAND(e.modifiers, cmdKey) <> 0;				theBtnState := BAND(e.modifiers, btnState) <> 0;				theActiveFlag := BAND(e.modifiers, activeFlag) <> 0;				case e.what of					mouseDown:  begin							if (e.when - gLastClickTime <= gDblTime) & WithinDblDist(e.where, gLastClickLoc) then								gNumClicks := gNumClicks + 1							else								gNumClicks := 1;							theNumClicks := gNumClicks;							gLastClickTime := e.when;							gLastClickLoc := e.where;						end;					keyDown, keyUp, autoKey:  begin							theChar := chr(BAND(e.message, charCodeMask));							theCode := BSR(BAND(e.message, keyCodeMask), 8);						end;					activateEvt, updateEvt: 						theWMgrWindow := WindowPtr(e.message);					diskEvt:  begin							theDrive := LoWord(e.message);							theResult := HiWord(e.message);						end;					networkEvt: 						theParamBlk := Handle(e.message);					otherwise						message := e.message;				end;			end;		HandleEvent(gLastEvent);	end;	procedure TApplication.HandleEvent (var e: EventInfo);	begin		case e.what of			nullEvent:  begin					SetupCursor(e.where);					gTarget.Idle;				end;			mouseDown: 				HandleMouseDown(e);			mouseUp: 				HandleMouseUp(e);			keyDown, autoKey: 				HandleKey(e);			keyUp: 				HandleKeyUp(e);			activateEvt: 				HandleActivate(e);			updateEvt: 				HandleUpdate(e);			diskEvt: 				HandleDiskEvt(e);			networkEvt: 				HandleNetworkEvt(e);			driverEvt: 				HandleDriverEvt(e);			app1Evt..app4Evt: 				HandleAppEvt(e);			otherwise				;		end;	end;	procedure TApplication.HandleMouseDown (var e: EventInfo);		var			wMgrWindow: WindowPtr;			code: integer;			window: TWindow;	begin		code := FindWindow(e.where, wMgrWindow);		window := RecoverWindow(wMgrWindow);		case code of			inSysWindow: 				SystemClick(gLastEventRecord, wMgrWindow);			inMenubar:  begin					DisableAllCmds;					gTarget.SetupMenus;					HandleMenuSelection(MenuSelect(e.where));					HiliteMenu(0);				end;			inDrag: 				if window <> nil then					window.Drag(e);			inGrow: 				if window <> nil then					window.Grow(e);			inGoAway: 				if window <> nil then					if TrackGoAway(wMgrWindow, e.where) then						window.GoAway;			inZoomIn, inZoomOut: 				if TrackBox(wMgrWindow, e.where, code) then					window.Zoom(code);			inContent: 				if window <> nil then begin						if wMgrWindow = FrontWindow then							window.Content(e)						else							SelectWindow(wMgrWindow);					end;			otherwise				;		end;	end;	procedure TApplication.HandleMouseUp (var e: EventInfo);	begin	end;	procedure TApplication.HandleKey (var e: EventInfo);	begin		if e.theCmdKey then begin				DisableAllCmds;				gTarget.SetupMenus;				HandleMenuSelection(MenuKey(e.theChar));				HiliteMenu(0);			end		else			gTarget.Key(e);	end;	procedure TApplication.HandleKeyUp (var e: EventInfo);	begin	end;	procedure TApplication.HandleActivate (var e: EventInfo);		var			window: TWindow;	begin		window := RecoverWindow(e.theWMgrWindow);		if window <> nil then			if e.theActiveFlag then				window.Activate			else				window.Deactivate;	end;	procedure TApplication.HandleUpdate (var e: EventInfo);		var			window: TWindow;	begin		window := RecoverWindow(e.theWMgrWindow);		if window <> nil then			window.Update;	end;	procedure TApplication.HandleDiskEvt (var e: EventInfo);	begin	end;	procedure TApplication.HandleNetworkEvt (var e: EventInfo);	begin	end;	procedure TApplication.HandleDriverEvt (var e: EventInfo);	begin	end;	procedure TApplication.HandleAppEvt (var e: EventInfo);	begin	{writeln('AppEvt: ', e.what : 1, e.message : 1);}	end;	procedure TApplication.HandleMenuSelection (menuAndItem: longint);		var			menu, item, junk: integer;			daName: Str255;	begin		menu := HiWord(menuAndItem);		item := LoWord(menuAndItem);		if menu <> 0 then			if (menu = appleMenuID) & (item > 2) then begin					GetItem(GetMHandle(appleMenuID), item, daName);					junk := OpenDeskAcc(daName);				end			else				gTarget.DoMenuCommand(MenuItemToCmd(menu, item));	end;	procedure TApplication.Idle;	begin{SetupCursor(gLastEvent.where);}	end;	procedure TApplication.Key (var e: EventInfo);	begin		if e.theCmdKey then begin				DisableAllCmds;				gTarget.SetupMenus;				HandleMenuSelection(MenuKey(e.theChar));				HiliteMenu(0);			end;	end;	function TApplication.WithinDblDist (p1, p2: Point): boolean;		var			d: integer;	begin		d := abs(p1.h - p2.h) + abs(p1.v - p2.v);		WithinDblDist := (d <= 5);	end;	procedure TApplication.EachDocumentDo (procedure DoToDoc (document: TDocument));		var			doc: TDocument;	begin		doc := gHeadDocument;		while doc <> nil do begin				DoToDoc(doc);				doc := doc.fNextDocument;			end;	end;end.