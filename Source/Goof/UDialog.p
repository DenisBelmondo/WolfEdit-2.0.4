unit UDialog;{Methods of TDialog}interface	uses		ObjIntf, UGoof;	type		ItemNumberSet = set of 1..31;		TCtrlGroup = object(TObject)				fNextGroup: TCtrlGroup;				fFirstItem, fLastItem: integer;				fCurrentItem: integer;			end;		TDialog = object(TWindow)				fHeadGroup: TCtrlGroup;				fDefaultItem: integer;				fDismissItems: ItemNumberSet;				fItemHit: integer;				fEnableEditCmds: boolean;				procedure TDialog.IDialog (itsDMgrDlog: DialogPtr; itsOptions: WindowOptions; disposeFlag: boolean);				procedure TDialog.INewDialog (boundsRect: Rect; title: Str255; procID: integer; items: Handle; itsOptions: WindowOptions);				procedure TDialog.IGetNewDialog (itsRsrcID: integer);				procedure TDialog.IDocDialog (itsDocument: TDocument; itsDMgrDlog: DialogPtr; itsOptions: WindowOptions; disposeFlag: boolean);				procedure TDialog.IDocNewDialog (itsDocument: TDocument; boundsRect: Rect; title: Str255; procID: integer; items: Handle; itsOptions: WindowOptions);				procedure TDialog.IDocGetNewDialog (itsDocument: TDocument; itsRsrcID: integer);				procedure TDialog.Free;				override;				procedure TDialog.DisposeWMgrWindow;				override;				procedure TDialog.InstallItemView (itemNo: integer; view: TView; opts: FrameOptions);				procedure TDialog.GetItem (itemNo: integer; var itemType: integer; var item: Handle; var box: Rect);				procedure TDialog.SetItem (itemNo: integer; itemType: integer; item: Handle; box: Rect);				function TDialog.GetCtrlItem (itemNo: integer): ControlHandle;				procedure TDialog.GetItemBox (itemNo: integer; var box: Rect);				procedure TDialog.SetItemBox (itemNo: integer; box: Rect);				procedure TDialog.GetItemText (itemNo: integer; var text: string);				procedure TDialog.SetItemText (itemNo: integer; text: string);				procedure TDialog.SelItemText (itemNo: integer; strtSel, endSel: integer);				procedure TDialog.SetItemNum (itemNo: integer; num: longint);				function TDialog.GetItemNum (itemNo: integer): longint;				function TDialog.GetItemNumInRange (itemNo: integer; var num: longint; min, max: longint): boolean;				function TDialog.GetItemValue (itemNo: integer): integer;				procedure TDialog.SetItemValue (itemNo: integer; value: integer);				procedure TDialog.GetItemMinMax (itemNo: integer; var min, max: integer);				procedure TDialog.SetItemMinMax (itemNo: integer; min, max: integer);				procedure TDialog.DefineGroup (firstItemNo, lastItemNo: integer);				function TDialog.GetGroupSelection (itemNo: integer): integer;				procedure TDialog.SetGroupSelection (itemNo: integer);				function TDialog.FindGroup (itemNo: integer): TCtrlGroup;				procedure TDialog.ShowItem (itemNo: integer);				procedure TDialog.HideItem (itemNo: integer);				procedure EnableItem (itemNo: integer; enabled: boolean);				procedure EnableGroup (itemNo: integer; enabled: boolean);				procedure TDialog.SetDefaultItem (itemNo: integer);				procedure TDialog.SetDismissItems (itemNos: ItemNumberSet);				procedure TDialog.InstallUserItemProcs;				procedure TDialog.SetupMenus;				override;				procedure TDialog.DoMenuCommand (cmdNumber: integer);				override;				procedure TDialog.Idle;				override;				procedure TDialog.Draw;				override;				procedure TDialog.Activate;				override;				procedure TDialog.Deactivate;				override;				procedure TDialog.Click (var e: EventInfo);				override;				procedure TDialog.Key (var e: EventInfo);				override;				procedure TDialog.FlashButton (itemNo: integer);				procedure TDialog.HandleEvent (var e: EventRecord);				function TDialog.DoModalDialog: integer;				procedure TDialog.ItemHit (var e: EventInfo; itemNo: integer);				procedure TDialog.DrawUserItem (itemNo: integer);			end;	procedure GetDlgIText (dlog: DialogPtr; itemNo: integer; var text: string);	procedure SetDlgIText (dlog: DialogPtr; itemNo: integer; text: Str255);	function GetDlgIValue (dlog: DialogPtr; itemNo: integer): integer;	procedure SetDlgIValue (dlog: DialogPtr; itemNo, value: integer);implementation	uses		HexIO;	const		returnKey = chr(13);		enterKey = chr(3);{******************** Procedures and Functions *******************}	procedure UserItemProc (theWindow: DialogPtr; itemNo: integer);		var			dlog: TDialog;	begin{$IFC DA AND NOT DAShell}		SetupA4;{$ENDC}		dlog := TDialog(GetWRefCon(theWindow) - 1);		dlog.DrawUserItem(itemNo);{$IFC DA AND NOT DAShell}		RestoreA4;{$ENDC}	end;	procedure GetDlgIText (dlog: DialogPtr; itemNo: integer; var text: string);		var			itemType: integer;			item: Handle;			box: Rect;			str: Str255;	begin		GetDItem(dlog, itemNo, itemType, item, box);		GetIText(item, str);		text := str;	end;	procedure SetDlgIText (dlog: DialogPtr; itemNo: integer; text: Str255);		var			itemType: integer;			item: Handle;			box: Rect;	begin		GetDItem(dlog, itemNo, itemType, item, box);		SetIText(item, text);	end;	function GetDlgIValue (dlog: DialogPtr; itemNo: integer): integer;		var			itemType: integer;			item: Handle;			box: Rect;	begin		GetDItem(dlog, itemNo, itemType, item, box);		GetDlgIValue := GetCtlValue(ControlHandle(item));	end;	procedure SetDlgIValue (dlog: DialogPtr; itemNo, value: integer);		var			itemType: integer;			item: Handle;			box: Rect;	begin		GetDItem(dlog, itemNo, itemType, item, box);		SetCtlValue(ControlHandle(item), value);	end;{***************** Methods ********************}	procedure TDialog.IDialog (itsDMgrDlog: DialogPtr; itsOptions: WindowOptions; disposeFlag: boolean);	begin		IDocDialog(nil, itsDMgrDlog, itsOptions, disposeFlag);	end;	procedure TDialog.IDocDialog (itsDocument: TDocument; itsDMgrDlog: DialogPtr; itsOptions: WindowOptions; disposeFlag: boolean);	begin		IWindow(itsDocument, itsDMgrDlog, itsOptions, disposeFlag);		fHeadGroup := nil;		fDefaultItem := 1;		fDismissItems := [];		fEnableEditCmds := false;		InstallUserItemProcs;	end;	procedure TDialog.INewDialog (boundsRect: Rect; title: Str255; procID: integer; items: Handle; itsOptions: WindowOptions);	begin		IDocNewDialog(nil, boundsRect, title, procID, items, itsOptions);	end;	procedure TDialog.IDocNewDialog (itsDocument: TDocument; boundsRect: Rect; title: Str255; procID: integer; items: Handle; itsOptions: WindowOptions);		var			dMgrDlog: DialogPtr;	begin		dMgrDlog := NewDialog(nil, boundsRect, title, wVisible in itsOptions, procID, WindowPtr(-1), wGoAwayBox in itsOptions, 0, items);		IDocDialog(itsDocument, dMgrDlog, itsOptions, true);	end;	procedure TDialog.IGetNewDialog (itsRsrcID: integer);	begin		IDocGetNewDialog(nil, itsRsrcID);	end;	procedure TDialog.IDocGetNewDialog (itsDocument: TDocument; itsRsrcID: integer);		var			dMgrDlog: DialogPtr;	begin		dMgrDlog := GetNewDialog(itsRsrcID, nil, WindowPtr(-1));		IDocDialog(itsDocument, dMgrDlog, [wCloseOnGoAway], true);	end;	procedure TDialog.Free;		var			group, nextGroup: TCtrlGroup;	begin		group := fHeadGroup;		while group <> nil do begin				nextGroup := group.fNextGroup;				group.Free;				group := nextGroup;			end;		inherited Free;	end;	procedure TDialog.DisposeWMgrWindow;	begin		if fDisposeWindow then			DisposDialog(fWMgrWindow)		else			CloseDialog(fWMgrWindow);	end;	procedure TDialog.InstallItemView (itemNo: integer; view: TView; opts: FrameOptions);		var			bounds: Rect;			frame: TFrame;	begin		GetItemBox(itemNo, bounds);		new(frame);		frame.IFrame(self, bounds, opts);		frame.HaveView(view);	end;	procedure TDialog.GetItem (itemNo: integer; var itemType: integer; var item: Handle; var box: Rect);	begin		GetDItem(fWMgrWindow, itemNo, itemType, item, box);	end;	procedure TDialog.SetItem (itemNo: integer; itemType: integer; item: Handle; box: Rect);	begin		Focus;		SetDItem(fWMgrWindow, itemNo, itemType, item, box);	end;	function TDialog.GetCtrlItem (itemNo: integer): ControlHandle;		var			itemType: integer;			item: Handle;			box: Rect;	begin		GetItem(itemNo, itemType, item, box);		if BitAnd(itemType, $7C) <> ctrlItem then			item := nil;		GetCtrlItem := ControlHandle(item);	end;	procedure TDialog.GetItemBox (itemNo: integer; var box: Rect);		var			itemType: integer;			item: Handle;	begin		GetItem(itemNo, itemType, item, box);	end;	procedure TDialog.SetItemBox (itemNo: integer; box: Rect);		var			itemType: integer;			item: Handle;			oldBox: Rect;	begin		Focus;		GetItem(itemNo, itemType, item, oldBox);		SetItem(itemNo, itemType, item, box);	end;	procedure TDialog.GetItemText (itemNo: integer; var text: string);	begin		GetDlgIText(fWMgrWindow, itemNo, text);	end;	procedure TDialog.SetItemText (itemNo: integer; text: string);	begin		Focus;		SetDlgIText(fWMgrWindow, itemNo, text);	end;	procedure TDialog.SelItemText (itemNo: integer; strtSel, endSel: integer);	begin		SelIText(fWMgrWindow, itemNo, strtSel, endSel);		fEnableEditCmds := true;	end;	procedure TDialog.SetItemNum (itemNo: integer; num: longint);		var			str: Str255;	begin		Focus;		NumToString(num, str);		SetItemText(itemNo, str);	end;	function TDialog.GetItemNum (itemNo: integer): longint;		var			str: Str255;			num: longint;	begin		GetItemText(itemNo, str);		StringToNum(str, num);		GetItemNum := num;	end;	function TDialog.GetItemNumInRange (itemNo: integer; var num: longint; min, max: longint): boolean;		var			str: Str255;	begin		GetItemText(itemNo, str);		StringToNum(str, num);		GetItemNumInRange := (num >= min) & (num <= max);	end;	function TDialog.GetItemValue (itemNo: integer): integer;	begin		GetItemValue := GetCtlValue(GetCtrlItem(itemNo));	end;	procedure TDialog.SetItemValue (itemNo: integer; value: integer);	begin		Focus;		SetCtlValue(GetCtrlItem(itemNo), value);	end;	procedure TDialog.GetItemMinMax (itemNo: integer; var min, max: integer);		var			ctrl: ControlHandle;	begin		ctrl := GetCtrlItem(itemNo);		min := GetCtlMin(ctrl);		max := GetCtlMax(ctrl);	end;	procedure TDialog.SetItemMinMax (itemNo: integer; min, max: integer);		var			ctrl: ControlHandle;	begin		Focus;		ctrl := GetCtrlItem(itemNo);		SetCtlMin(ctrl, min);		SetCtlMax(ctrl, max);	end;	procedure TDialog.DefineGroup (firstItemNo, lastItemNo: integer);		var			group: TCtrlGroup;	begin		New(group);		with group do begin				fFirstItem := firstItemNo;				fLastItem := lastItemNo;				fCurrentItem := firstItemNo;				fNextGroup := fHeadGroup;			end;		fHeadGroup := group;		SetItemValue(firstItemNo, 1);	end;	function TDialog.GetGroupSelection (itemNo: integer): integer;		var			group: TCtrlGroup;	begin		group := FindGroup(itemNo);		if group <> nil then			GetGroupSelection := group.fCurrentItem		else			GetGroupSelection := 0;	end;	procedure TDialog.SetGroupSelection (itemNo: integer);		var			group: TCtrlGroup;	begin		group := FindGroup(itemNo);		if group <> nil then begin				if itemNo <> group.fCurrentItem then begin						SetItemValue(group.fCurrentItem, 0);						SetItemValue(itemNo, 1);						group.fCurrentItem := itemNo;					end;			end;	end;	function TDialog.FindGroup (itemNo: integer): TCtrlGroup;		var			group: TCtrlGroup;	begin		group := fHeadGroup;		while (group <> nil) & not ((group.fFirstItem <= itemNo) & (itemNo <= group.fLastItem)) do			group := group.fNextGroup;		FindGroup := group;	end;	procedure TDialog.ShowItem (itemNo: integer);	begin		Focus;		ShowDItem(fWMgrWindow, itemNo);	end;	procedure TDialog.HideItem (itemNo: integer);	begin		Focus;		HideDItem(fWMgrWindow, itemNo);	end;	procedure TDialog.EnableItem (itemNo: integer; enabled: boolean);		var			state: integer;	begin		if enabled then			state := 0		else			state := 255;		Focus;		HiliteControl(GetCtrlItem(itemNo), state);	end;	procedure TDialog.EnableGroup (itemNo: integer; enabled: boolean);		var			group: TCtrlGroup;			i: integer;	begin		group := FindGroup(itemNo);		if group <> nil then			for i := group.fFirstItem to group.fLastItem do				EnableItem(i, enabled);	end;	procedure TDialog.SetDismissItems (itemNos: ItemNumberSet);	begin		fDismissItems := itemNos;	end;	procedure TDialog.SetupMenus;	begin		if fEnableEditCmds then begin				EnableCmd(undoCmd);				EnableCmd(cutCmd);				EnableCmd(copyCmd);				EnableCmd(pasteCmd);				EnableCmd(clearCmd);			end;		inherited SetupMenus;	end;	procedure TDialog.SetDefaultItem (itemNo: integer);	begin		fDefaultItem := itemNo;	end;	procedure TDialog.InstallUserItemProcs;		type			IntPtr = ^integer;			IntHandle = ^IntPtr;		var			dlog: DialogPtr;			numItems, itemNo, itemType: integer;			item: Handle;			box: Rect;	begin		dlog := fWMgrWindow;		numItems := IntHandle(DialogPeek(dlog)^.items)^^ + 1;		for itemNo := 1 to numItems do begin				GetDItem(dlog, itemNo, itemType, item, box);				if (itemNo <= 31) & (BitAnd(itemType, $7F) = ctrlItem + btnCtrl) then					fDismissItems := fDismissItems + [itemNo];				if BitAnd(itemType, $7F) = userItem then begin						item := @UserItemProc;						SetDItem(dlog, itemNo, itemType, item, box);					end;			end;	end;	procedure TDialog.DoMenuCommand (cmdNumber: integer);		var			junk: boolean;	begin		case cmdNumber of			cutCmd:  begin					DlgCut(fWMgrWindow);					junk := DoTEToScrap;				end;			copyCmd:  begin					DlgCopy(fWMgrWindow);					junk := DoTEToScrap;				end;			pasteCmd:  begin					if DoTEFromScrap then						DlgPaste(fWMgrWindow);				end;			clearCmd: 				DlgDelete(fWMgrWindow);			otherwise				inherited DoMenuCommand(cmdNumber);		end;	end;	procedure TDialog.Idle;	begin		HandleEvent(gLastEventRecord);		inherited Idle;	end;	procedure TDialog.Draw;		var			itemType: integer;			item: Handle;			box: Rect;	begin		DrawDialog(fWMgrWindow);		if fDefaultItem <> 0 then begin				GetItem(fDefaultItem, itemType, item, box);				if BitAnd(itemType, $7F) = ctrlItem + btnCtrl then begin						PenSize(3, 3);						InsetRect(box, -4, -4);						FrameRoundRect(box, 16, 16);					end;			end;	end;	procedure TDialog.Activate;	begin		inherited Activate;		HandleEvent(gLastEventRecord);	end;	procedure TDialog.Deactivate;	begin		HandleEvent(gLastEventRecord);		inherited Deactivate;	end;	procedure TDialog.ItemHit (var e: EventInfo; itemNo: integer);		const			radioButton = ctrlItem + radCtrl;			checkBox = ctrlItem + chkCtrl;		var			itemType: integer;			item: Handle;			box: Rect;	begin		fItemHit := itemNo;		GetItem(itemNo, itemType, item, box);		case itemType of			radioButton: 				SetGroupSelection(itemNo);			checkBox: 				SetItemValue(itemNo, 1 - GetItemValue(itemNo));			otherwise				;		end;	end;	procedure TDialog.Click (var e: EventInfo);	begin		HandleEvent(gLastEventRecord);	end;	procedure TDialog.Key (var e: EventInfo);	begin		if ((e.theChar = returnKey) | (e.theChar = enterKey)) & (fDefaultItem <> 0) then begin				FlashButton(fDefaultItem);				ItemHit(e, fDefaultItem);			end		else			HandleEvent(gLastEventRecord);	end;	procedure TDialog.FlashButton (itemNo: integer);		var			ctrl: ControlHandle;			time: longint;	begin		ctrl := GetCtrlItem(itemNo);		if ctrl <> nil then begin				Focus;				HiliteControl(ctrl, 1);				time := TickCount + 5;				repeat				until TickCount >= time;				HiliteControl(ctrl, 0);			end;	end;	procedure TDialog.HandleEvent (var e: EventRecord);		var			dlog: DialogPtr;			itemNo, iType: integer;			hit: boolean;			iHandle: Handle;			iRect: Rect;	begin		if IsDialogEvent(gLastEventRecord) then begin				hit := DialogSelect(e, dlog, itemNo);				if hit then begin						ItemHit(gLastEvent, itemNo);						GetItem(itemNo, iType, iHandle, iRect);						fEnableEditCmds := iType = editText;					end;			end;	end;	function TDialog.DoModalDialog: integer;		var			e: EventRecord;			win: WindowPtr;			code: integer;			junk: boolean;			oldHandler: TEvtHandler;		function HitDismissItem: boolean;		begin			HLock(Handle(self));			HitDismissItem := fItemHit in fDismissItems;			HUnlock(Handle(self));		end;	begin {TDialog.DoModalDialog}		HiliteMenu(0);		oldHandler := fNextHandler;		fNextHandler := nil;		fItemHit := 0;		while not HitDismissItem do begin				junk := WaitNextEvent(everyEvent - diskMask, e, 1, nil);				if e.what = mouseDown then begin						code := FindWindow(e.where, win);						if (win <> FrontWindow) & (code <> inMenuBar) then begin								SysBeep(5);								Cycle;							end;					end;				gApplication.DispatchEvent(e)			end;		fNextHandler := oldHandler;		DoModalDialog := fItemHit;	end;	procedure TDialog.DrawUserItem (itemNo: integer);	begin	{Override this}	end;end.