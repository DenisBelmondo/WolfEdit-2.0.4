unit UFrame;{Methods of TFrame}interface	uses		ObjIntf, UGoof;implementation	procedure CtrlActionProc (theControl: ControlHandle; partCode: integer);		var			ctrlClient: TFrame;			oldFocus: TFrame;	begin{$IFC DA AND NOT DAShell}		SetupA4;{$ENDC}		oldFocus := gCurrentFocus;		ctrlClient := TFrame(GetCRefCon(theControl) - 1);		case partCode of			inUpButton, inDownButton, inPageUp, inPageDown: 				ctrlClient.Scroll(theControl, partCode);			otherwise				;		end;		oldFocus.Focus;{$IFC DA AND NOT DAShell}		RestoreA4;{$ENDC}	end;	procedure TFrame.IFrame (itsContainer: TFrame; itsBounds: Rect; itsOptions: FrameOptions);		var			hsRect, vsRect: Rect;	begin		if itsContainer <> nil then			IEvtHandler(itsContainer)		else			IEvtHandler(gDefaultTarget);		fOptions := itsOptions;		fContainer := itsContainer;		fWMgrWindow := nil;		fNextFrame := nil;		fHeadFrame := nil;		fView := nil;		fCursor := nil;		fControls := nil;		SetPt(fScrollOffset, 0, 0);		SetRect(fScrollRange, 0, 0, 0, 0);		fScrollBars[v] := nil;		fScrollBars[h] := nil;		SetPt(fLineSize, 16, 16);		fBounds := itsBounds;		fHasBorder := frmBorder in itsOptions;		fWantResizing[h] := frmHResize in itsOptions;		fWantResizing[v] := frmVResize in itsOptions;		if fContainer <> nil then begin				fWindow := fContainer.fWindow;				fWMgrWindow := fContainer.fWMgrWindow;				fContainer.AddFrame(self);			end;		CalcScrollBarRects(hsRect, vsRect);		if frmHScroll in itsOptions then			fScrollBars[h] := fContainer.NewCtrl(self, hsRect, '', false, 0, 0, 0, scrollBarProc);		if frmVScroll in itsOptions then			fScrollBars[v] := fContainer.NewCtrl(self, vsRect, '', false, 0, 0, 0, scrollBarProc);	end;	procedure TFrame.CalcScrollBarRects (var hsRect, vsRect: Rect);	begin		SetRect(hsRect, fBounds.left - 1, fBounds.bottom, fBounds.right + 1, fBounds.bottom + 16);		SetRect(vsRect, fBounds.right, fBounds.top - 1, fBounds.right + 16, fBounds.bottom + 1);		if not (frmHScroll in fOptions) & (frmGrowBox in fOptions) then			vsRect.bottom := vsRect.bottom - 15;		if (frmHScroll in fOptions) & not (frmGrowBox in fOptions) then			vsRect.bottom := vsRect.bottom + 16;	end;	procedure TFrame.Free;		var			vhs: VHSelect;	begin		if fView <> nil then			fView.Free;		while fHeadFrame <> nil do			fHeadFrame.free;		if fControls <> nil then begin				Focus;				KillControls(fWMgrWindow);			end;		for vhs := v to h do			if fScrollBars[vhs] <> nil then				fContainer.DisposeCtrl(fScrollBars[vhs]);		if fContainer <> nil then			fContainer.RemoveFrame(self);		if gCurrentFocus = self then			gCurrentFocus := nil;		DisposeWMgrWindow;		inherited Free;	end;	procedure TFrame.DisposeWMgrWindow;	begin	{This method must do nothing in a TFrame}	end;	procedure GetBorderRect (frame: TFrame; var r: Rect);	begin		with frame do begin				r := fBounds;				if fHasBorder then					InsetRect(r, -1, -1);			end;	end;	procedure InvalFrameAndBorder (frame: TFrame);		var			r: Rect;	begin		GetBorderRect(frame, r);		frame.fContainer.Focus;		InvalRect(r);	end;	procedure TFrame.AddFrame (frameToAdd: TFrame);	begin		frameToAdd.fNextFrame := fHeadFrame;		fHeadFrame := frameToAdd;		frameToAdd.fContainer := self;		frameToAdd.fNextHandler := self;		InvalFrameAndBorder(frameToAdd);	end;	procedure TFrame.RemoveFrame (frameToRemove: TFrame);		var			frameBefore: TFrame;	begin		InvalFrameAndBorder(frameToRemove);		if fHeadFrame = frameToRemove then			fHeadFrame := frameToRemove.fNextFrame		else begin				frameBefore := fHeadFrame;				while frameBefore.fNextFrame <> frameToRemove do					frameBefore := frameBefore.fNextFrame;				frameBefore.fNextFrame := frameToRemove.fNextFrame;			end;		frameToRemove.fContainer := nil;		frameToRemove.fNextFrame := nil;		if frameToRemove.fNextHandler = self then			frameToRemove.fNextHandler := gDefaultTarget;	end;	procedure TFrame.HaveView (viewToHave: TView);	begin		if viewToHave <> fView then begin				if fView <> nil then					fView.fFrame := nil;				fView := viewToHave;				if fView <> nil then begin						fView.fFrame := self;						fView.BeInFrame;					end;				UpdateScrollRange;				Invalidate;			end;	end;	procedure TFrame.ContainerToLocal (var pt: Point);	begin		SubPt(fBounds.topLeft, pt);		AddPt(fScrollOffset, pt);	end;	procedure TFrame.Content (var e: EventInfo);		var			subFrame: TFrame;			ctrl: ControlHandle;			part: integer;			refCon: longint;			ctrlClient: TFrame;	begin		ContainerToLocal(e.where);		subFrame := FindFrame(e.where);		if subFrame <> nil then			subFrame.Content(e)		else begin				Focus;				part := FindControl(e.where, fWMgrWindow, ctrl);				if ctrl <> nil then					refCon := GetCRefCon(ctrl);				if (part <> 0) & odd(refCon) then begin						ctrlClient := TFrame(refCon - 1);						part := ctrlClient.TrackCtrl(ctrl, part, e.where);						if part <> 0 then							ctrlClient.CtrlOperated(ctrl, part);					end				else					Click(e);			end;	end;	function TFrame.TrackCtrl (theControl: ControlHandle; partCode: integer; startPt: Point): integer;	begin		case partCode of			inThumb: 				TrackCtrl := TrackControl(theControl, startPt, nil);			otherwise				TrackCtrl := TrackControl(theControl, startPt, @CtrlActionProc);		end;	end;	procedure TFrame.Activate;		procedure ActivateFrame (frame: TFrame);		begin			frame.Activate;		end;	begin {TFrame.Activate}		ShowScrollBars(true);		if fView <> nil then			fView.Activate;		EachFrameDo(ActivateFrame);	end; {TFrame.Activate}	procedure TFrame.Deactivate;		procedure DeactivateFrame (frame: TFrame);		begin			frame.Deactivate;		end;	begin {TFrame.Deactivate}		ShowScrollBars(false);		if fView <> nil then			fView.Deactivate;		EachFrameDo(DeactivateFrame);	end; {TFrame.Deactivate}	procedure TFrame.ShowScrollBars (showThem: boolean);		var			vhs: VHSelect;			scrollBar: ControlHandle;	begin		for vhs := v to h do begin				scrollBar := fScrollBars[vhs];				if scrollBar <> nil then begin						FocusOnContainer;						if showThem then							ShowControl(scrollBar)						else							HideControl(scrollBar);					end;			end;	end;	procedure TFrame.Update;		var			oldClip: RgnHandle;		procedure DrawBorder (frame: TFrame);			var				r: Rect;		begin			if frame.fHasBorder then begin					r := frame.fBounds;					InsetRect(r, -1, -1);					FrameRect(r);				end;		end;		procedure UpdateFrame (frame: TFrame);		begin			frame.Update;		end;		procedure ClipToBackground;			var				rgn: RgnHandle;			procedure ClipOutRect (r: Rect);			begin				RectRgn(gTempRgn, r);				DiffRgn(rgn, gTempRgn, rgn);			end;			procedure ClipOutFrame (frame: TFrame);				var					r: Rect;			begin				GetBorderRect(frame, r);				ClipOutRect(r);			end;			procedure ClipOutControls;				var					ctrl: ControlHandle;			begin				ctrl := fControls;				while ctrl <> nil do begin						ClipOutRect(ctrl^^.contrlRect);						ctrl := ctrl^^.nextControl;					end;			end;		begin {ClipToBackground}			rgn := NewRgn;			CopyRgn(thePort^.clipRgn, rgn);			EachFrameDo(ClipOutFrame);			if fView <> nil then				ClipOutRect(fView.fExtent);			ClipOutControls;			SetClip(rgn);			DisposeRgn(rgn);		end;		procedure SaveClip;		begin			oldClip := NewRgn;			CopyRgn(thePort^.clipRgn, oldClip);		end;		procedure RestoreClip;		begin			SetClip(oldClip);			DisposeRgn(oldClip);		end;	begin {TFrame.Update}		Focus;		SaveClip;		ClipToBackground;		EraseRect(thePort^.portRect);		RestoreClip;		Draw;		Focus;		PenNormal;		EachFrameDo(DrawBorder);		EachFrameDo(UpdateFrame);	end; {TFrame.Update}	procedure TFrame.Click (var e: EventInfo);	begin		if fView <> nil then			fView.Click(e);	end;	procedure TFrame.Draw;		var			oldOrigin, newOrigin, offset: Point;	begin		DrawControls(fWMgrWindow);		if fView <> nil then			fView.Draw;	end;	procedure TFrame.Focus;		var			r: Rect;			offset: Point;			thePort: GrafPtr;	begin		if gCurrentFocus <> self then begin				FocusOnContainer;				GetPort(thePort);				r := fBounds;				offset := thePort^.portRect.topLeft;				SubPt(r.topLeft, offset);				AddPt(fScrollOffset, offset);				SetOrigin(offset.h, offset.v);				offset := fScrollOffset;				SubPt(r.topLeft, offset);				CopyRgn(thePort^.clipRgn, gTempRgn);				OffsetRgn(gTempRgn, offset.h, offset.v);				OffsetRect(r, offset.h, offset.v);				ClipRect(r);				SectRgn(gTempRgn, thePort^.clipRgn, gTempRgn);				SetClip(gTempRgn);				WindowPeek(fWMgrWindow)^.controlList := fControls;				gCurrentFocus := self;			end;	end;	function TFrame.InFocus: boolean;		var			thePort: GrafPtr;	begin		GetPort(thePort);		InFocus := (gCurrentFocus = self) and (thePort = fWMgrWindow);	end;	procedure TFrame.FocusOnContainer;	begin		fContainer.Focus;	end;	procedure TFrame.SetBounds (newBounds: Rect);		var			oldBounds, sectBounds, hsRect, vsRect: Rect;			oldSize, newSize: Point;			rgn: RgnHandle;			junk: boolean;		procedure TellToResize (frame: TFrame);		begin			frame.ContainerResized(oldSize, newSize);		end;	begin {TFrame.SetBounds}		if not EqualRect(oldBounds, newBounds) then begin				oldBounds := fBounds;				fBounds := newBounds;				oldSize := oldBounds.botRight;				SubPt(oldBounds.topLeft, oldSize);				newSize := newBounds.botRight;				SubPt(newBounds.topLeft, newSize);				if fContainer <> nil then begin						FocusOnContainer;						junk := SectRect(oldBounds, newBounds, sectBounds);						if fHasBorder then begin								InsetRect(oldBounds, -1, -1);								InsetRect(newBounds, -1, -1);							end;						rgn := NewRgn;						RectRgn(rgn, oldBounds);						RectRgn(gTempRgn, newBounds);						UnionRgn(rgn, gTempRgn, gTempRgn);						RectRgn(rgn, sectBounds);						DiffRgn(gTempRgn, rgn, gTempRgn);						InvalRgn(gTempRgn);						DisposeRgn(rgn);						CalcScrollBarRects(hsRect, vsRect);						if fScrollBars[v] <> nil then							with vsRect do begin									MoveControl(fScrollBars[v], left, top);									SizeControl(fScrollBars[v], right - left, bottom - top);								end;						if fScrollBars[h] <> nil then							with hsRect do begin									MoveControl(fScrollBars[h], left, top);									SizeControl(fScrollBars[h], right - left, bottom - top);								end;					end;				UpdateScrollRange;				if not EqualPt(oldSize, newSize) then					EachFrameDo(TellToResize);			end;	end; {TFrame.SetBounds}	procedure TFrame.ContainerResized (oldSize, newSize: Point);		var			deltaSize: Point;			newBounds: Rect;			vh: VHSelect;	begin		for vh := v to h do			if fWantResizing[vh] then				deltaSize.vh[vh] := newSize.vh[vh] - oldSize.vh[vh]			else				deltaSize.vh[vh] := 0;		newBounds := fBounds;		AddPt(deltaSize, newBounds.botRight);		SetBounds(newBounds);	end;	function TFrame.FindFrame (pt: Point): TFrame;		var			frame: TFrame;	begin		frame := fHeadFrame;		while frame <> nil do begin				if PtInRect(pt, frame.fBounds) then					Leave;				frame := frame.fNextFrame;			end;		FindFrame := frame;	end;	procedure TFrame.EachFrameDo (procedure DoToFrame (frame: TFrame));		var			frame: TFrame;	begin		frame := fHeadFrame;		while frame <> nil do begin				DoToFrame(frame);				frame := frame.fNextFrame;			end;	end;	procedure TFrame.Invalidate;	begin		if fContainer <> nil then begin				FocusOnContainer;				InvalRect(fBounds);			end;	end;	procedure TFrame.InvalidateRect (badRect: Rect);	begin		Focus;		InvalRect(badRect);	end;	procedure TFrame.InvalidateRgn (badRgn: RgnHandle);	begin		Focus;		InvalRgn(badRgn);	end;	procedure TFrame.ValidateRect (goodRect: Rect);	begin		Focus;		ValidRect(goodRect);	end;	procedure TFrame.ValidateRgn (goodRgn: RgnHandle);	begin		Focus;		ValidRgn(goodRgn);	end;	procedure TFrame.UpdateCursor (pt: Point);		var			subFrame: TFrame;	begin		ContainerToLocal(pt);		subFrame := FindFrame(pt);		if subFrame <> nil then			subFrame.UpdateCursor(pt)		else if gCurrentCursor <> fCursor then begin				if fCursor <> nil then					SetCursor(fCursor^^)				else					InitCursor;				gCurrentCursor := fCursor;			end;	end;	procedure TFrame.SetCursorHandle (newCursor: CursHandle);	begin		fCursor := newCursor;	end;	function TFrame.NewCtrl (itsClient: TFrame; boundsRect: Rect; title: string; visible: boolean; value: integer; min, max: integer; procID: integer): ControlHandle;		var			ctrl: ControlHandle;			refCon: longint;	begin		Focus;		if itsClient <> nil then			refCon := longint(itsClient) + 1		else			refCon := 0;		ctrl := NewControl(fWMgrWindow, boundsRect, title, visible, value, min, max, procID, refCon);		fControls := WindowPeek(fWMgrWindow)^.controlList;		NewCtrl := ctrl;	end;	procedure TFrame.DisposeCtrl (theControl: ControlHandle);	begin		Focus;		DisposeControl(theControl);	end;	procedure TFrame.CtrlOperated (theControl: ControlHandle; partCode: integer);	begin		if (theControl = fScrollBars[h]) | (theControl = fScrollBars[v]) then			SyncScrolling;	end;	procedure TFrame.UpdateScrollRange;		var			newRange: Rect;			r: integer;			scrollBar: ControlHandle;			vhs: VHSelect;	begin		if fView = nil then			SetRect(newRange, 0, 0, 0, 0)		else begin				newRange.topLeft := fView.fExtent.topLeft;				for vhs := v to h do begin						r := fView.fExtent.botRight.vh[vhs] - fView.fExtent.topLeft.vh[vhs];						r := r - (fBounds.botRight.vh[vhs] - fBounds.topLeft.vh[vhs]);						if r < 0 then							r := 0;						newRange.botRight.vh[vhs] := newRange.topLeft.vh[vhs] + r;					end;			end;		if not EqualRect(fScrollRange, newRange) then begin				for vhs := v to h do begin						scrollBar := fScrollBars[vhs];						if scrollBar <> nil then begin								fContainer.Focus;								SetCtlMin(scrollBar, newRange.topLeft.vh[vhs]);								SetCtlMax(scrollBar, newRange.botRight.vh[vhs]);							end;					end;				fScrollRange := newRange;				SyncScrolling;			end;	end;	procedure TFrame.SyncScrolling;		var			newOffset: Point;			vhs: VHSelect;			scrollBar: ControlHandle;	begin		for vhs := v to h do begin				scrollBar := fScrollBars[vhs];				if scrollBar <> nil then					newOffset.vh[vhs] := GetCtlValue(scrollBar)				else					newOffset.vh[vhs] := 0;			end;		ScrollTo(newOffset);	end;	procedure TFrame.ScrollTo (pt: Point);		var			vhs: VHSelect;			scrollBar: ControlHandle;			r: Rect;			newOffset, delta: Point;			e: EventRecord;			thePort: GrafPtr;			oldClipRgn: RgnHandle;	begin		with fScrollRange do			for vhs := v to h do				pt.vh[vhs] := Min(Max(pt.vh[vhs], topLeft.vh[vhs]), botRight.vh[vhs]);		newOffset := pt;		if not EqualPt(fScrollOffset, newOffset) then begin				if fContainer <> nil then begin						FocusOnContainer;						for vhs := v to h do begin								scrollBar := fScrollBars[vhs];								if scrollBar <> nil then									SetCtlValue(scrollBar, newOffset.vh[vhs]);							end;					end;				oldClipRgn := NewRgn;				Focus;				GetPort(thePort);				delta := fScrollOffset;				SubPt(newOffset, delta);				r := fBounds;				OffsetRect(r, fScrollOffset.h - r.left, fScrollOffset.v - r.top);				ScrollRect(r, delta.h, delta.v, gTempRgn);				SetOrigin(thePort^.portRect.left - delta.h, thePort^.portRect.top - delta.v);				OffsetRgn(thePort^.clipRgn, -delta.h, -delta.v);				OffsetRgn(WindowPeek(thePort)^.updateRgn, delta.h, delta.v);				OffsetRgn(gTempRgn, -delta.h, -delta.v);				GetClip(oldClipRgn);				SectRgn(thePort^.clipRgn, gTempRgn, thePort^.clipRgn);				fScrollOffset := newOffset;				if fWindow.Visible then					Draw;				SetPort(thePort);				SetClip(oldClipRgn);				DisposeRgn(oldClipRgn);			end;	end;	procedure TFrame.ScrollBy (deltaPt: Point);	begin		AddPt(fScrollOffset, deltaPt);		ScrollTo(deltaPt);	end;	procedure TFrame.Scroll (theControl: ControlHandle; partCode: integer);		var			vhs: VHSelect;			amount: integer;			pt: Point;			lineAmount, pageSize, linesPerPage, pageAmount: integer;	begin		if theControl = fScrollBars[v] then			vhs := v		else			vhs := h;		lineAmount := fLineSize.vh[vhs];		pageSize := fBounds.botRight.vh[vhs] - fBounds.topLeft.vh[vhs];		linesPerPage := pageSize div lineAmount;		pageAmount := (linesPerPage - 1) * lineAmount;		if pageAmount < 0 then			pageAmount := pageSize;		case partCode of			inUpButton: 				amount := -lineAmount;			inDownButton: 				amount := lineAmount;			inPageUp: 				amount := -pageAmount;			inPageDown: 				amount := pageAmount;		end;		SetPt(pt, 0, 0);		pt.vh[vhs] := amount;		AddPt(fScrollOffset, pt);		ScrollTo(pt);	end;	procedure TFrame.RevealRect (rectToReveal: Rect; minToSee: Point);		var			minAmt: integer;			viewedRect: Rect;			deltaPt: Point;			vhs: VHSelect;			coord: integer;	begin		GetViewedRect(viewedRect);		for vhs := v to h do begin				minAmt := Min(LengthRect(fBounds, vhs), minToSee.vh[vhs]);				coord := rectToReveal.topLeft.vh[vhs] + minAmt - viewedRect.botRight.vh[vhs];				if coord <= 0 then					coord := Min(0, rectToReveal.botRight.vh[vhs] - minAmt - viewedRect.topLeft.vh[vhs]);				deltaPt.vh[vhs] := coord;			end;		ScrollBy(deltaPt);	end;	procedure TFrame.GetViewedRect (var viewedRect: Rect);	begin		viewedRect := fBounds;		OffsetRect(viewedRect, fScrollOffset.h - viewedRect.left, fScrollOffset.v - viewedRect.top);	end;	procedure TFrame.AutoScroll;		var			vhs: VHSelect;			m, delta: Point;	begin		Focus;		GetMouse(m);		SubPt(fScrollOffset, m);		AddPt(fBounds.topLeft, m);		SetPt(delta, 0, 0);		for vhs := v to h do			if m.vh[vhs] < fBounds.topLeft.vh[vhs] then				delta.vh[vhs] := -fLineSize.vh[vhs]			else if m.vh[vhs] > fBounds.botRight.vh[vhs] then				delta.vh[vhs] := fLineSize.vh[vhs];		if (delta.h <> 0) | (delta.v <> 0) then			ScrollBy(delta);	end;end.