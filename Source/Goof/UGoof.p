unit UGoof;{Greg's Object-Oriented Framework for the Macintosh}interface	uses		ObjIntf;	const	{--- Menu IDs ---}		appleMenuID = 1;	{--- Command Numbers ---}		aboutCmd = 101;		newCmd = 201;		openCmd = 202;		closeCmd = 203;		saveCmd = 204;		saveAsCmd = 205;		revertCmd = 206;		quitCmd = 207;		undoCmd = 301;		cutCmd = 303;		copyCmd = 304;		pasteCmd = 305;		clearCmd = 306;	{--- Resource IDs ---}{$IFC NOT DA}		gIDBase = 128;			{Base of application-defined resource IDs}		gStdIDBase = 8192;	{Base of Goof standard resource IDs}{$ENDC}	{The following are relative to gStdIDBase}		clipReadFailedAlertID = 0;			{"Couldn't read the clipboard"}		clipWriteFailedAlertID = 1;			{"Couldn't write to the clipboard"}		couldntOpenAlertID = 2;			{"Couldn't open ^0 (error number ^1)"}		saveBeforeClosingAlertID = 3;	{"Save changes made to ^0 before closing?"}		deleteOldFileAlertID = 4;			{"Okay to delete old copy of ^0 before saving?"}		diskFullAlertID = 5;					{"Not enough room on the disk to save ^0."}		couldntSaveAlertID = 6;			{"Couldn't save ^0 (error number ^1)"}		revertAlertID = 7;					{"Revert to last saved version of ^0?"}		saveBeforeQuittingAlertID = 8;	{"Save changes made to ^0 before quitting?"}		dfltWindowID = 0;		saveAsPromptStrID = 0;			{"Save '^0' as:"}{$IFC DA}		daMenuID = 0;{$ENDC}	{--- Dialog item numbers ---}		yes = 1;		no = 3;	{--- Result  codes ---}		suppressErr = 32767;		{Return this from TDocument.ReadFromFile/WriteToFile to}									{suppress display of error alert}	type		WindowOption = (wGoAwayBox, wGrowBox, wVisible, wCloseOnGoAway);		WindowOptions = set of WindowOption;		CmdListHandle = ^CmdListPtr;		CmdListPtr = ^CmdList;		CmdList = record				theMenuID: integer;				theNumItems: integer;				theItems: array[1..255] of integer;			end;		CmdTableHandle = ^CmdTablePtr;		CmdTablePtr = ^CmdTable;		CmdTable = record				theNumMenus: integer;				theMenus: array[1..255] of CmdListHandle;			end;		EventInfo = record				what: integer;				when: longint;				where: Point;				theOptionKey, theAlphaLock, theShiftKey, theCmdKey, theBtnState, theActiveFlag: boolean;				case integer of					mouseDown: (							theNumClicks: integer;					);					keyDown, keyUp, autoKey: (							theChar: char;							theCode: integer;					);					activateEvt, updateEvt: (							theWMgrWindow: WindowPtr;					);					diskEvt: (							theDrive, theResult: integer;					);					networkEvt: (							theParamBlk: Handle;					);					nullEvent, mouseUp, driverEvt, app1Evt..app4Evt: (							message: longint;					);			end;		TEvtHandler = object(TObject)				fNextHandler: TEvtHandler;				procedure TEvtHandler.IEvtHandler (itsNextHandler: TEvtHandler);				procedure TEvtHandler.Free;				override;				procedure TEvtHandler.BecomeTarget;				procedure TEvtHandler.SetupMenus;				procedure TEvtHandler.DoMenuCommand (cmdNumber: integer);				procedure TEvtHandler.Idle;				procedure TEvtHandler.Key (var e: EventInfo);				procedure TEvtHandler.HiliteSelection (entering: boolean);			end;{$IFC NOT DA}		TApplication = object(TEvtHandler)				procedure TApplication.IApplication (itsSignature: OSType);				procedure TApplication.SetupMenus;				override;				procedure TApplication.DoMenuCommand (cmdNumber: integer);				override;				procedure TApplication.DoInitialDefault;				procedure TApplication.DoAbout;				procedure TApplication.DoNew;				procedure TApplication.DoOpen;				procedure TApplication.DoOpenFromFinder (forPrinting: boolean; info: AppFile);				procedure TApplication.DoClose;				procedure TApplication.DoQuit;				function TApplication.MakeOwnDocument: TDocument;				procedure TApplication.Run;				procedure TApplication.DispatchEvent (var e: EventRecord);				procedure TApplication.HandleEvent (var e: EventInfo);				procedure TApplication.HandleMouseDown (var e: EventInfo);				procedure TApplication.HandleMouseUp (var e: EventInfo);				procedure TApplication.HandleKey (var e: EventInfo);				procedure TApplication.HandleKeyUp (var e: EventInfo);				procedure TApplication.HandleActivate (var e: EventInfo);				procedure TApplication.HandleUpdate (var e: EventInfo);				procedure TApplication.HandleDiskEvt (var e: EventInfo);				procedure HandleNetworkEvt (var e: EventInfo);				procedure HandleDriverEvt (var e: EventInfo);				procedure HandleAppEvt (var e: EventInfo);				procedure TApplication.HandleMenuSelection (menuAndItem: longint);				procedure TApplication.Idle;				override;				procedure TApplication.Key (var e: EventInfo);				override;				function TApplication.WithinDblDist (p1, p2: Point): boolean;				procedure TApplication.EachDocumentDo (procedure DoToDoc (document: TDocument));			end;{$ENDC}{$IFC DA}		TDA = object(TEvtHandler)				procedure TDA.IDA (itsSignature: OSType);				procedure TDA.ReOpen;				procedure TDA.Close;				procedure TDA.Harakiri;				procedure TDA.Free;				override;				procedure TDA.AccEvent (e: EventRecord);				procedure TDA.AccRun;				procedure TDA.AccCursor (e: EventRecord);				procedure TDA.AccMenu (menuID, itemNo: integer);				procedure TDA.AccUndo;				procedure TDA.AccCut;				procedure TDA.AccCopy;				procedure TDA.AccPaste;				procedure TDA.AccClear;				procedure TDA.Idle (e: EventRecord);				override;				procedure TDA.DoSetupMenus;				procedure TDA.SetupMenus;				override;				procedure TDA.DoMenuCommand (cmdNumber: integer);				override;				procedure TDA.DoNew;				procedure TDA.DoOpen;				function TDA.MakeOwnDocument: TDocument;			end;{$ENDC}		FrameOption = ({}			frmBorder, frmGrowBox,{}			frmHResize, frmVResize, {}			frmHScroll, frmVScroll);		FrameOptions = set of FrameOption;		TFrame = object(TEvtHandler)				fContainer: TFrame;			{Frame that contains us}				fWindow: TWindow;			{TWindow that contains us}				fWMgrWindow: WindowPtr;	{fWMgrWindow of our fWindow}				fClipRgn: RgnHandle;			{Saved clip region when out of focus}				fNextFrame: TFrame;		{Next frame in our fContainer's subframe list}				fHeadFrame: TFrame;		{First frame in our subframe list}				fBounds: Rect;					{Our bounds in our fContainer's coordinate system}				fHasBorder: boolean;			{Whether to draw a border outside our fBounds}				fWantResizing: array[VHSelect] of boolean;	{Whether to change size when our fContainer does}				fView: TView;					{The view we are displaying, if any}				fCursor: CursHandle;		{Our cursor}				fControls: ControlHandle;	{Controls that belong to us}				fScrollOffset: Point;			{Scroll offset of top left corner}				fScrollRange: Rect;			{Range of scroll offset}				fScrollBars: array[VHSelect] of ControlHandle;	{Our scroll bars}				fLineSize: Point;				{Amount to scroll when scroll arrow clicked}				fOptions: FrameOptions;		{Init/Free}				procedure TFrame.IFrame (itsContainer: TFrame; itsBounds: Rect; itsOptions: FrameOptions);				procedure TFrame.CalcScrollBarRects (var hsRect, vsRect: Rect);				procedure TFrame.Free;				override;				procedure TFrame.DisposeWMgrWindow;		{Hierarchy management}				procedure TFrame.AddFrame (frameToAdd: TFrame);				procedure TFrame.RemoveFrame (frameToRemove: TFrame);				procedure TFrame.HaveView (viewToHave: TView);				procedure TFrame.ContainerToLocal (var pt: Point);		{The following is sent from our owner in its coordinates}				procedure TFrame.Content (var e: EventInfo);				function TFrame.TrackCtrl (theControl: ControlHandle; partCode: integer; startPt: Point): integer;		{The following are sent from our owner in global coordinates}				procedure TFrame.Activate;				procedure TFrame.Deactivate;				procedure TFrame.ShowScrollBars (showThem: boolean);				procedure TFrame.Update;		{The following are generated for users in our coordinate system with focus on us}				procedure TFrame.Click (var e: EventInfo);				procedure TFrame.Draw;		{Focusing}				procedure TFrame.Focus;				function TFrame.InFocus: boolean;				procedure TFrame.FocusOnContainer;		{Position and size control}				procedure TFrame.SetBounds (newBounds: Rect);				procedure TFrame.ContainerResized (oldSize, newSize: Point);		{Misc}				function TFrame.FindFrame (pt: Point): TFrame;				procedure TFrame.EachFrameDo (procedure DoToFrame (frame: TFrame));				procedure TFrame.Invalidate;				procedure TFrame.InvalidateRect (badRect: Rect);				procedure TFrame.InvalidateRgn (badRgn: RgnHandle);				procedure TFrame.ValidateRect (goodRect: Rect);				procedure TFrame.ValidateRgn (goodRgn: RgnHandle);				procedure TFrame.UpdateCursor (pt: Point);				procedure TFrame.SetCursorHandle (newCursor: CursHandle);				function TFrame.NewCtrl (itsClient: TFrame; boundsRect: Rect; title: string; visible: boolean; value: integer; min, max: integer; procID: integer): ControlHandle;				procedure TFrame.DisposeCtrl (theControl: ControlHandle);				procedure TFrame.CtrlOperated (theControl: ControlHandle; partCode: integer);				procedure TFrame.UpdateScrollRange;				procedure TFrame.SyncScrolling;				procedure TFrame.ScrollTo (pt: Point);				procedure TFrame.ScrollBy (deltaPt: Point);				procedure TFrame.Scroll (theControl: ControlHandle; partCode: integer);				procedure TFrame.RevealRect (rectToReveal: Rect; minToSee: Point);				procedure TFrame.GetViewedRect (var viewedRect: Rect);				procedure TFrame.AutoScroll;			end;		TView = object(TEvtHandler)				fFrame: TFrame;				{The frame that is displaying us, if any}				fExtent: Rect;					{Our extent}				fDocument: TDocument;		{The document that we are viewing}				fTarget: TEvtHandler;		{Target to set when we're put in a frame}				procedure TView.IView (itsFrame: TFrame; itsDocument: TDocument; itsExtent: Rect);				procedure TView.Free;				override;				procedure TView.MakeOwnWindow;				procedure TView.MakeWindow (winID: integer; width, height: integer; winOpts: WindowOptions; frmOpts: FrameOptions);				procedure TView.SetExtent (newExtent: Rect);				procedure TView.BeInFrame;				procedure TView.ViewDocument (docToView: TDocument);				procedure TView.Activate;				procedure TView.Deactivate;				procedure TView.Click (var e: EventInfo);				procedure TView.Draw;				procedure TView.Focus;				procedure TView.Invalidate;				procedure TView.InvalidateRect (badRect: Rect);				procedure TView.InvalidateRgn (badRgn: RgnHandle);				procedure TView.ValidateRect (goodRect: Rect);				procedure TView.ValidateRgn (goodRgn: RgnHandle);				procedure TView.AutoScroll;			end;		TDocument = object(TEvtHandler)				fNextDocument: TDocument;				fHeadWindow: TWindow;				fChanged: boolean;				fFileType: OSType;				fHasFile: boolean;				fVRefNum: integer;				fFileName: string[63];				fScratchName: string[63];				procedure TDocument.IDocument (itsFileType: OSType);				procedure TDocument.Free;				override;				procedure TDocument.MakeWindow;				function TDocument.MakeOwnView: TView;				procedure TDocument.AddWindow (winToAdd: TWindow);				procedure TDocument.RemoveWindow (winToRemove: TWindow);				procedure TDocument.EachWindowDo (procedure DoToWin (win: TWindow));				procedure TDocument.Changed;				procedure TDocument.SetupMenus;				override;				procedure TDocument.DoMenuCommand (cmdNumber: integer);				override;				procedure TDocument.DoNew;				function TDocument.DoOpen: boolean;				function TDocument.DoClose (quitting: boolean): boolean;				function TDocument.DoSave: boolean;				function TDocument.DoSaveAs: boolean;				procedure TDocument.DoRevert;				function TDocument.Read: boolean;				function TDocument.Write: boolean;				procedure TDocument.HaveFile (itsVRefNum: integer; itsFileName: string);				procedure TDocument.AugmentFileTypes (var numTypes: integer; var typeList: SFTypeList);				function TDocument.ReadFromFile (refNum: integer): OSErr;				function TDocument.WriteToFile (refNum: integer): OSErr;				function TDocument.GetDiskSpaceNeeded (var dataBytes, rsrcBytes: longint): OSErr;				procedure TDocument.DisposeContents;				function TDocument.MakeDefaultName: Str255;			end;		TWindow = object(TFrame)				fDocument: TDocument;			{The document we belong to}				fNextWindow: TWindow;		{Next window in the global window list}				fTarget: TEvtHandler;			{Target to set when activated}				fGrowBounds: Rect;				{Bounds for window resizing}				fCanResize: boolean;				{Does it have a grow box?}				fCloseOnGoAway: boolean;	{Close window on GoAway, or just hide it?}				fDisposeWindow: boolean;		{Do we own our fWMgrWindow?}		{Init/Free}				procedure TWindow.IWindow (itsDocument: TDocument; itsWMgrWindow: WindowPtr; itsOptions: WindowOptions; disposeFlag: boolean);				procedure TWindow.INewWindow (itsDocument: TDocument; boundsRect: Rect; title: Str255; procID: integer; itsOptions: WindowOptions);				procedure TWindow.IGetNewWindow (itsDocument: TDocument; itsRsrcID: integer; itsOptions: WindowOptions);				procedure TWindow.IGetNewCWindow (itsDocument: TDocument; itsRsrcID: integer; itsOptions: WindowOptions);				procedure TWindow.Free;				override;				procedure TWindow.DisposeWMgrWindow;				override;				procedure TWindow.SetTitle (title: string);				procedure TWindow.GetTitle (var title: string);				procedure TWindow.UpdateTitle;				procedure TWindow.ContainerToLocal (var pt: Point);				override;				procedure TWindow.Drag (var e: EventInfo);				procedure TWindow.Grow (var e: EventInfo);				procedure TWindow.GoAway;				procedure TWindow.Zoom (partCode: integer);				procedure TWindow.Activate;				override;				procedure TWindow.Deactivate;				override;				procedure TWindow.Update;				override;		{Focusing}				procedure TWindow.Focus;				override;		{Window manipulation}				procedure TWindow.Select;				procedure TWindow.Show;				procedure TWindow.Hide;				procedure TWindow.Close;				procedure TWindow.Move (hGlobal, vGlobal: integer);				procedure TWindow.Move3 (hGlobal, vGlobal: integer; front: boolean);				procedure TWindow.Size (w, h: integer);				procedure Size3 (w, h: integer; fUpdate: boolean);				procedure TWindow.PlaceBehind (behindWindow: TWindow);				procedure TWindow.SetBounds (newBounds: Rect);				override;		{Inquiry}				function TWindow.Visible: boolean;		{Misc}				procedure TWindow.InstallWDEF (newWDEF: Handle);				procedure ResetBounds;				procedure SetGrowBounds (newGrowBounds: Rect);				procedure TWindow.Invalidate;				override;				procedure TWindow.SetTarget (newTarget: TEvtHandler);				procedure TWindow.SetupMenus;				override;				procedure TWindow.DoMenuCommand (cmdNumber: integer);				override;				procedure TWindow.DefaultPosition;			end;{===================== Procedures and Functions =====================}	function Min (x, y: integer): integer;	function Max (x, y: integer): integer;	function LengthRect (r: Rect; vhs: VHSelect): integer;	procedure Panic (routine, trouble: Str255);	function Ask (id: integer): integer;	procedure DoAlert (id: integer);	procedure ErrorAlert (id: integer; param: string; result: OSErr);	function DoTEFromScrap: boolean;	function DoTEToScrap: boolean;	procedure CmdToMenuItem (cmdNumber: integer; var menu, item: integer);	function MenuItemToCmd (menu, item: integer): integer;	procedure CheckCmd (cmdNumber: integer; check: boolean);	procedure EnableCmd (cmdNumber: integer);	procedure DisableCmd (cmdNumber: integer);	procedure DisableAllItems (menu: MenuHandle);	procedure SetupCursor (pt: Point);	function RecoverWindow (wMgrWindow: WindowPtr): TWindow;{========================== Global Variables ======================}	var		gCmdTable: CmdTableHandle;	{Menu*item -> command number mapping}		gTarget: TEvtHandler;			{Object to send key & idle events to}		gDefaultTarget: TEvtHandler;	{gApplication or gDA, depending}		gDragBounds: Rect;				{Window dragging limits}		gHeadDocument: TDocument;	{Head of document list}		gTempRgn: RgnHandle;			{Region for miscellaneous use}		gCurrentFocus: TFrame;		{Frame currently in focus}		gDummyPort: GrafPtr;			{Zero-sized port to dump unwanted drawing operations}		gFrontWindow: TWindow;		{TWindow whose fWMgrWindow is the FrontWindow}		gCurrentCursor: CursHandle;	{Handle to current cursor, or nil}		gCreator: OSType;				{This application's signature}		gNextDocNumber: integer;		{Next number to give an untitled document}		gLastEvent: EventInfo;			{The last event retrieved by GetNextEvent}		gLastEventRecord: EventRecord;	{Ditto}		gDblTime: longint;				{Max double click interval}		gLastClickTime: longint;		{Time of last mouseDown event}		gLastClickLoc: Point;			{Position of last mouseDown event}		gNumClicks: integer;			{Number of successive clicks within gDblTime so far}		gWinPosRec: record			{Info for new window position generation:}				theLimits: Rect;					{Rect within which theNextPos roams}				theNextPos: Point;				{Next window topLeft position to use}				theIncrement: Point;				{Amount to add to theNextPos each time, mod theLimits}				theDefaultBotRight: Point;		{Where to put the window's botRight}			end;		gAppResFile: integer;{$IFC NOT DA}		gApplication: TApplication;{$ENDC}{$IFC DA}		gDA: TDA;		gDCtlEntry: DCtlPtr;		gAlreadyOpened: boolean;		gRealDA: boolean;		gIDBase: integer;		gStdIDBase: integer;		gWindow: TWindow;		gMenu: MenuHandle;{$ENDC}{========================== Implementation ======================}implementation	const		errorNumberStrID = 1;				{"Error number"}	function Min (x, y: integer): integer;	begin		if x < y then			Min := x		else			Min := y;	end;	function Max (x, y: integer): integer;	begin		if x > y then			Max := x		else			Max := y;	end;	function LengthRect (r: Rect; vhs: VHSelect): integer;	begin		LengthRect := r.botRight.vh[vhs] - r.topLeft.vh[vhs];	end;{$IFC NOT DA OR DAShell}	procedure Panic (routine, trouble: Str255);	begin		ShowText;		writeln('Panic: ', routine, ': ', trouble);		writeln('Press the mouse button...');		while not Button do			;		ExitToShell;	end;{$ELSEC}	procedure Panic (routine, trouble: Str255);		var			i: integer;	begin		for i := 1 to 5 do			SysBeep(10);	end;{$ENDC}	function Ask (id: integer): integer;		var			rsrc: Handle;			idStr: Str255;			oldResFile: integer;	begin		oldResFile := CurResFile;		UseResFile(gAppResFile);		InitCursor;		gCurrentCursor := nil;		rsrc := GetResource('ALRT', id);		if rsrc = nil then begin				NumToString(id, idStr);				Panic('Ask', concat('Can''t find ALRT ', idStr));			end;		Ask := Alert(id, nil);		UseResFile(oldResFile);	end;	procedure DoAlert (id: integer);		var			item: integer;	begin		item := Ask(id);	end;	procedure ErrorAlert (id: integer; param: string; result: OSErr);		var			h: StringHandle;			number, mess: str255;	begin		h := StringHandle(GetResource('EROR', result));		if h <> nil then			mess := h^^		else begin				NumToString(result, number);				h := GetString(gStdIDBase + errorNumberStrID);				mess := concat(h^^, ' ', number);			end;		ParamText(param, mess, '', '');		DoAlert(id);	end;	function DoTEFromScrap: boolean;		var			result: OSErr;	begin		result := TEFromScrap;		DoTEFromScrap := result = noErr;		if result <> noErr then			ErrorAlert(gStdIDBase + clipReadFailedAlertID, '', result);	end;	function DoTEToScrap: boolean;		var			result: OSErr;		procedure Fail;		begin			ErrorAlert(gStdIDBase + clipWriteFailedAlertID, '', result);			DoTEToScrap := false;			exit(DoTEToScrap);		end;	begin {DoTEToScrap}		result := ZeroScrap;		if result <> noErr then			Fail;		result := TEToScrap;		if result <> noErr then			Fail;		DoTEToScrap := true;	end; {DoTEToScrap}	procedure CmdToMenuItem (cmdNumber: integer; var menu, item: integer);		var			m, i: integer;	begin		if cmdNumber >= 0 then begin				with gCmdTable^^ do					for m := 1 to theNumMenus do						with theMenus[m]^^ do							for i := 1 to theNumItems do								if theItems[i] = cmdNumber then begin										menu := theMenuID;										item := i;										exit(CmdToMenuItem);									end;				menu := 0;				item := 0;			end		else begin		{$IFC DA}				menu := -((-cmdNumber) div 100);		{$ELSEC}				menu := (-cmdNumber) div 100;		{$ENDC}				item := (-cmdNumber) mod 100;			end;	end;	function MenuItemToCmd (menu, item: integer): integer;		var			i, cmdNumber: integer;	begin		with gCmdTable^^ do			for i := 1 to theNumMenus do				with theMenus[i]^^ do					if theMenuID = menu then						if (item >= 1) & (item <= theNumItems) then begin								cmdNumber := theItems[item];								if cmdNumber <> 0 then begin										MenuItemToCmd := cmdNumber;										exit(MenuItemToCmd);									end;							end;		MenuItemToCmd := -(abs(menu) * 100 + item);	end;	procedure CmdToMHandleItem (cmdNumber: integer; var mHandle: MenuHandle; var item: integer);		var			menu: integer;	begin		CmdToMenuItem(cmdNumber, menu, item);		mHandle := GetMHandle(menu);	end;	procedure CheckCmd (cmdNumber: integer; check: boolean);		var			menu: MenuHandle;			item: integer;	begin		CmdToMHandleItem(cmdNumber, menu, item);		if menu <> nil then			CheckItem(menu, item, check);	end;	procedure EnableCmd (cmdNumber: integer);		var			menu: MenuHandle;			item: integer;	begin		CmdToMHandleItem(cmdNumber, menu, item);		if menu <> nil then			EnableItem(menu, item);	end;	procedure DisableCmd (cmdNumber: integer);		var			menu: MenuHandle;			item: integer;	begin		CmdToMHandleItem(cmdNumber, menu, item);		if menu <> nil then			DisableItem(menu, item);	end;{$IFC FALSE}	procedure DisableAllItems (menu: MenuHandle);		var			itemNum, numItems: integer;			curMark: char;	begin		numItems := CountMItems(menu);		for itemNum := 1 to numItems do begin				DisableItem(menu, itemNum);				GetItemMark(menu, itemNum, curMark);				if (curMark = chr(noMark)) or (curMark = chr(checkMark)) then					CheckItem(menu, itemNum, false)				else begin					end;			end;	end;{$ENDC}	procedure SetupCursor (pt: Point);		var			code: integer;			wMgrWindow: WindowPtr;			window: TWindow;	begin		code := FindWindow(pt, wMgrWindow);		if (code = inContent) or (code = inSysWindow) then begin				window := RecoverWindow(wMgrWindow);				if (window <> nil) & (window = gFrontWindow) then begin						window.UpdateCursor(pt);						Exit(SetupCursor);					end;			end;		if gCurrentCursor <> nil then begin				InitCursor;				gCurrentCursor := nil;			end;	end;	function RecoverWindow (wMgrWindow: WindowPtr): TWindow;		var			refCon: longint;	begin		RecoverWindow := nil;		if (wMgrWindow <> nil) & (WindowPeek(wMgrWindow)^.windowKind >= 0) then begin				refCon := GetWRefCon(wMgrWindow);				if odd(refCon) then begin						refCon := refCon - 1;						RecoverWindow := TWindow(refCon);					end;			end;	end;end.