program DAShell;{DA Shell customised for GoofDA}	uses		ObjIntf, UGoof, UDAMain;	const		DARefNum = 12;											{Default RefNum of the DA}	{Selector values for calls to a driver.}		TheOpen = 0;		ThePrime = 1;		TheControl = 2;		TheStatus = 3;		TheClose = 4;	{DA action requests}		accEvent = 64;		accRun = 65;		accCursor = 66;		accMenu = 67;		accUndo = 68;		accCut = 70;		accCopy = 71;		accPaste = 72;		accClear = 73;	{csCode value when the Application heap is about to be initialized.}		goodBye = -1;	{Bit settings high byte of dCtlFlag}		dReadEnable = 8;											{Driver responds to _Read}		dWriteEnable = 9;										{Driver responds to _Write}		dCtlEnable = 10;											{Driver responds to _Control}		dStatEnable = 11;										{Driver responds to _Status}		dNeedGoodBye = 12;										{Driver notified prior to InitApplZone}		dNeedTime = 13;											{Driver needs periodic time}		dNeedLock = 14;											{Driver will be locked as soon as openned}	var		fakeDCE: DCtlEntry;										{Fake DCE}		fakeIOPB: ParamBlockRec;								{Fake IOPB}		theEvent: EventRecord;									{Current event}		actionControl: Integer;									{Current DA action}		driverCall: Integer;										{Current DA driver call}		oldMenu: Integer;										{The actual negative menuID for Sample DA}		done: Boolean;											{Life of DAShell}		hitWhere: Integer;										{Where did the event occur}		aWindow: WindowPtr;									{Which window did it occur in}		applMenus: array[1..3] of MenuHandle;			{DAShell menus}		error: OSErr;		evnt: Boolean;											{Unused variable for return val of GetNextEvent}		dragBounds: Rect;										{Limits for window dragging}	procedure DisplayMenuBar;		var			i: Integer;	begin		applMenus[1] := NewMenu(1, Chr(appleMark));		AppendMenu(applMenus[1], 'Sample DA');				{This is the user's Sample DA}		AppendMenu(applMenus[1], '(-');		InsertResMenu(applMenus[1], 'DRVR', 2);				{Real DAs follow}		applMenus[2] := NewMenu(2, 'File');		AppendMenu(applMenus[2], 'Close');					{Closes any DA}		AppendMenu(applMenus[2], 'Quit/Q');					{Forces a goodByeKiss}		applMenus[3] := NewMenu(3, 'Edit');					{Used to force edit action items}		AppendMenu(applMenus[3], 'Undo/Z');		AppendMenu(applMenus[3], '(-');		AppendMenu(applMenus[3], 'Cut/X');		AppendMenu(applMenus[3], 'Copy/C');		AppendMenu(applMenus[3], 'Paste/V');		AppendMenu(applMenus[3], 'Clear');		for i := 1 to 3 do			InsertMenu(applMenus[i], 0);		DrawMenuBar;											{Show the sucker}	end;		{End of DisplayMenuBar PROCEDURE}	procedure RunDA;	begin		if fakeDCE.dCtlDriver <> nil then						{Sample D/A loaded?}			begin		{Yes, is the call a Control and are control calls accepted?}		{Set all of our traps to be IMMED (synchronous) instead of ASYNCHronous.  Even the goodBye}		{kiss is done synchronously in DAShell, remember in a real DA the goodBye kiss is done w/o}		{the IMMED bit set this implies that the user must do a jmp to JIODone.  All real asynchronous}		{request must be completed with JIODone to remove the  the I/O Request from the queue and}		{it marks the DA inactive and unlocked and executes the completion routine if there is one.}				case driverCall of					TheOpen: 						fakeIOPB.ioTrap := $A200;						{_Open with IMMED bit set.}					TheControl: 						fakeIOPB.ioTrap := $A204;						{_Control with IMMED bit set.}					TheClose: 						fakeIOPB.ioTrap := $A201;						{_Close with IMMED bit set.}					otherwise				end;				if ((driverCall = TheControl) and BitTst(@fakeDCE.dCtlFlags, 15 - dCtlEnable)) or (driverCall <> TheControl) then					error := Main(@fakeDCE, @fakeIOPB, driverCall);	{Yes, so call it.}			end;	end;		{End of RunDA PROCEDURE}	procedure OpenSampleDA;	begin		if fakeDCE.dCtlDriver = nil then						{DA already openned?}			begin													{No so initialize the DCE and IOPB}				with fakeDCE do										{Create our fake DCE}					begin						dCtlDriver := @Main;						dCtlFlags := $2400;						dCtlPosition := 0;						dCtlStorage := NewHandle(0);					{So DA will think it has a real A4 world}						dCtlRefNum := DARefNum + 1;						dCtlCurTicks := TickCount;						dCtlWindow := nil;						dCtlDelay := 0;						dCtlEMask := $016A;							{This is the event mask LSP makes for a DA}						dCtlMenu := 0;					end;				with fakeIOPB do									{Create our fake IOPB}					begin						qType := Ord(ioQType);							{Our drive type is this.}						ioCRefNum := DARefNum + 1;					{This is the refNum}						csCode := 0;					end;			end;		driverCall := TheOpen;									{Open the SampleDA}	{With LSP the event mask, flags, delay, and menu ID must be set-up in the "Open" code of the DA}	{if these values are different from LSP default values.}		RunDA;	{If after the _Open needTime was set then set up when the next time the DA should run.}		if BitTst(@fakeDCE.dCtlFlags, 15 - dNeedTime) then			fakeDCE.dCtlCurTicks := TickCount + fakeDCE.dCtlDelay;{If the DA has a window, then show it.}		if fakeDCE.dCtlWindow <> nil then			ShowWindow(WindowPtr(fakeDCE.dCtlWindow));	end;		{End of OpenSampleDA PROCEDURE}	procedure HandleMBar;		const			appleMenu = 1;			fileMenu = 2;			editMenu = 3;		var			menuHit: record					case boolean of						True: (								longWord: LongInt						);						False: (								theMenuID: Integer;								theMenuItem: Integer;						);				end;			theName: Str255;			junk: Integer;			aWindow: WindowPeek;	begin		if theEvent.what = mouseDown then			menuHit.longWord := MenuSelect(theEvent.where)		else			menuHit.longWord := MenuKey(chr(theEvent.message mod 256));		case menuHit.theMenuID of			0: 				;												 		{Do nothing!  We didn't selected anything.}			appleMenu: 				if menuHit.theMenuItem = 1 then					{Open our SampleDA?}					OpenSampleDA										{Yes, so lets do it.}				else begin												{No, open a normal DA}						GetItem(applMenus[1], menuHit.theMenuItem, theName);						junk := OpenDeskAcc(theName);					end;			fileMenu: 				if menuHit.theMenuItem = 1 then					{Close?}					begin												{Yes, should we close a real or fake DA?}						aWindow := WindowPeek(FrontWindow);						if aWindow <> nil then							if aWindow^.windowKind < 0 then			{Is it a real DA?}								CloseDeskAcc(aWindow^.windowKind)		{Yes, so do a normal close of a real DA.}							else								driverCall := TheClose;						{No, close our Sample DA.}					end				else if menuHit.theMenuItem = 2 then			{Did we get a QUIT?}					begin						driverCall := TheClose;							{Yes, close the DA and mark for finishing.}						done := True;					end;			editMenu: 												{Handle real DA's}				if not (SystemEdit(menuHit.theMenuItem - 1)) or (fakeDCE.dCtlDriver <> nil) then		  {If a non-mouseDown event caused the menu do be selected then we want to simulate what	}		  {the Desk Manager does and not pass an AccXXX code but let the D/A decipher the event.	}					if theEvent.what = mouseDown then						case menuHit.theMenuItem of							1: 								fakeIOPB.csCode := accUndo;							3: 								fakeIOPB.csCode := accCut;							4: 								fakeIOPB.csCode := accCopy;							5: 								fakeIOPB.csCode := accPaste;							6: 								fakeIOPB.csCode := accClear;						end;		{End of CASE statement}			otherwise			{See if our SampleDA menu was hit.}				if (menuHit.theMenuID = fakeDCE.dCtlMenu) and (fakeDCE.dCtlDriver <> nil) then begin						fakeIOPB.csCode := accMenu;						BlockMove(@menuHit.theMenuID, @fakeIOPB.csParam, 2);						BlockMove(@menuHit.theMenuItem, Pointer(Ord(@fakeIOPB.csParam) + 2), 2);					end		end;	{End of CASE statement}		HiliteMenu(0);												{Unhilite menu, real or fake DA menu hit.}	end;		{End of HandleMBar PROCEDURE}	procedure SomeTime;	begin	{Make sure the DA is running and has needTime set because we're using values in the DCE}		if (fakeDCE.dCtlDriver <> nil) & BitTst(@fakeDCE.dCtlFlags, 15 - dNeedTime) then			if TickCount > fakeDCE.dCtlCurTicks then				{Has the time passed yet?}				begin														{Yes, so call D/A again.}					fakeIOPB.csCode := accRun;							{Give a slice of time.}					driverCall := TheControl;					RunDA;		   {Calculate the next interval to run the DA.}					fakeDCE.dCtlCurTicks := TickCount + fakeDCE.dCtlDelay;				end;	end;		{End of SomeTime PROCEDURE}	procedure DoDACursor;	begin{Also, give accCursor calls to the DA on a regular basis}		if (fakeDCE.dCtlDriver <> nil) & BitTst(@fakeDCE.dCtlFlags, 15 - dCtlEnable) then begin				fakeIOPB.csCode := accCursor;				driverCall := TheControl;				RunDA;			end;	end;	procedure CheckMenu;		var			mBarEnabled: ^Integer;									{Pointer to the MBarEnabled global}			mHandle: MenuHandle;										{Current DA Menu handle}	begin	{+++																											}	{Check if the SampleDA has installed a menu which is always negative for DAs.  If one is installed	}	{then we'll set the global to say there isn't a DA running and we also have to change the MenuID to	}	{positive so we update the MenuHandle.																	}	{---																											}		mBarEnabled := Pointer($A20);								{Where the MBarEnabled global is.}	{If the SampleDA has a multiple menus lets fix it up.}		if fakeDCE.dCtlMenu < 0 then begin				oldMenu := fakeDCE.dCtlMenu;							{Remember this negative value.}				mHandle := GetMHandle(fakeDCE.dCtlMenu);				DeleteMenu(fakeDCE.dCtlMenu);							{Remove negative DA menuID.}				fakeDCE.dCtlMenu := -fakeDCE.dCtlMenu;				{Update the actual menuID}				if mHandle <> nil then begin						mHandle^^.menuID := fakeDCE.dCtlMenu;			{Adjust the DCE menuID}						InsertMenu(mHandle, 0);							{Add the DA menu as a positive menuID.}						DrawMenuBar;					end;			end;		if mBarEnabled^ = oldMenu then						{Force mBarEnabled to zero if it becomes}			mBarEnabled^ := 0;										{negative.}	end;		{End of CheckMenu PROCEDURE}begin {DAShell}	dragBounds := screenBits.bounds;	with dragBounds do		top := top + 20;											{allow for menu bar}	InsetRect(dragBounds, 4, 4);	gAlreadyOpened := false;	oldMenu := 0;	InitCursor;	fakeDCE.dCtlDriver := nil;								{Mark the Sample D/A as not loaded}	DisplayMenuBar;	done := False;	repeat		CheckMenu;		SystemTask;												{In case we have a real DA}		SomeTime;												{Here's some spare time for the DA.}		evnt := GetNextEvent(everyEvent, theEvent);		{Fetch the next available event}		fakeIOPB.csCode := accEvent;							{We got an event}		driverCall := TheControl;		fakeIOPB.ioMisc := @theEvent;						{Set up the pointer to the event record.}		case theEvent.what of			nullEvent: 				fakeIOPB.csCode := accCursor;			mouseDown: 				begin					hitWhere := FindWindow(theEvent.where, aWindow);					case hitWhere of						inMenuBar: 							HandleMBar;						inSysWindow: 									{Real D/A so handle it.}							SystemClick(theEvent, aWindow);						inDrag: 							DragWindow(aWindow, theEvent.where, dragBounds);						inContent:															{Is the event for the D/A?}							if BitAND(fakeDCE.dCtlEMask, mDownMask) = 0 then								Cycle																{no, so skip it.}							else if FrontWindow <> WindowPtr(aWindow) then 		{If the window we've clicked is not the front window then activate the window.}								begin									SelectWindow(aWindow);									{Post an activate event.}									Cycle;															{Ébut not a MouseDown}								end;						inGoAway: 							if TrackGoAway(aWindow, theEvent.where) then			{If we hit the goAway box}								driverCall := TheClose;										{close the SampleDA}						otherwise					end; {hitWhere CASE statement}				end; {mouseDown code}			keyDown, autoKey: 				if BitAND(theEvent.modifiers, cmdKey) <> 0 then	{Fan Key depressed check if menu}					HandleMBar;			otherwise			{Check the dCtlEMask to see if the SampleDA needs this event.}				if not (BitTst(@fakeDCE.dCtlEMask, 15 - theEvent.what)) then begin						fakeIOPB.csCode := 0;	{it doesn't so just cycle through the loop again.}						Cycle;					end;		end;		{End of theEvent.what CASE statement}  	{Do a Good Bye Kiss...if we're quitting.}		if BitTst(@fakeDCE.dCtlFlags, 15 - dNeedGoodBye) and done then			fakeIOPB.csCode := goodBye;			{SMACK!!!, was it as good for you as for me?}		RunDA;									{Call the DA with the fake DCE and param block.}		if driverCall = TheClose then		{Mark DA as closed, and reset the cursor.}			begin				fakeDCE.dCtlDriver := nil;				InitCursor;			end;	until done;end.	{End of DAShell}