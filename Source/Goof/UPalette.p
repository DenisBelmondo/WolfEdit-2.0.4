unit UPalette;interface	uses		ObjIntf, UGoof;	type		PaletteCellsHandle = ^PaletteCellsPtr;		PaletteCellsPtr = ^PaletteCells;		PaletteCells = array[0..16383] of Handle;		TPalette = object(TView)				fCells: PaletteCellsHandle;				fEnableFlags: Handle;				fCellSize: Point;				fNumCells: Point;				fSelection: Point;				procedure TPalette.IPalette (cellWidth, cellHeight, numCols, numRows: integer; wantBorder: boolean);				procedure TPalette.Free;				override;				procedure TPalette.SetCellIcon (cellNum: integer; icon: Handle);				procedure TPalette.SetSelection (cellNum: integer);				procedure TPalette.SetSelectionPoint (cell: Point);				procedure TPalette.SelectionChanged (cellNum: integer);				function TPalette.GetSelection: integer;				procedure TPalette.Click (var e: EventInfo);				override;				procedure TPalette.Draw;				override;				procedure TPalette.InvalCell (cell: Point);				procedure TPalette.GetCellRect (cell: Point; var r: Rect);				procedure TPalette.InvertSelection;				procedure TPalette.InvertCell (cell: Point);				procedure TPalette.CellNumToPoint (cellNum: integer; var cell: Point);				function TPalette.PointToCellNum (cell: Point): integer;				procedure TPalette.SetEnableFlags (flagString: string);				procedure TPalette.EnableCell (col, row: integer; enable: boolean);				function TPalette.CellEnabled (cell: Point): boolean;			end;implementation	procedure TPalette.IPalette (cellWidth, cellHeight, numCols, numRows: integer; wantBorder: boolean);		var			i, numCells: integer;			extent: Rect;	begin		SetRect(extent, 0, 0, (cellWidth + 1) * numCols - 1, (cellHeight + 1) * numRows - 1);		IView(nil, nil, extent);		fCellSize.h := cellWidth;		fCellSize.v := cellHeight;		fNumCells.h := numCols;		fNumCells.v := numRows;		numCells := numCols * numRows;		fCells := PaletteCellsHandle(NewHandle(numCells * sizeof(Handle)));		fEnableFlags := NewHandle((numCells + 7) div 8);		for i := 0 to numCells - 1 do begin				fCells^^[i] := nil;				BitSet(fEnableFlags^, i);			end;		SetPt(fSelection, 0, 0);	end;	procedure TPalette.Free;	begin		DisposHandle(Handle(fCells));		DisposHandle(fEnableFlags);		inherited Free;	end;	procedure TPalette.SetCellIcon (cellNum: integer; icon: Handle);		var			cell: Point;	begin		fCells^^[cellNum] := icon;		CellNumToPoint(cellNum, cell);		Focus;		InvalCell(cell);	end;	procedure TPalette.SetSelection (cellNum: integer);		var			cell: Point;	begin		CellNumToPoint(cellNum, cell);		SetSelectionPoint(cell);	end;	procedure TPalette.SetSelectionPoint (cell: Point);	begin		if not EqualPt(fSelection, cell) then begin				Focus;				if CellEnabled(fSelection) then					InvertSelection;				fSelection := cell;				if CellEnabled(fSelection) then begin						InvertSelection;						SelectionChanged(PointToCellNum(cell));					end;			end;	end;	procedure TPalette.SelectionChanged (cellNum: integer);	begin	end;	function TPalette.GetSelection: integer;	begin		GetSelection := PointToCellNum(fSelection);	end;	procedure TPalette.Click (var e: EventInfo);		var			cell: Point;			r: Rect;	begin		cell.h := e.where.h div (fCellSize.h + 1);		cell.v := e.where.v div (fCellSize.v + 1);		SetRect(r, 0, 0, fNumCells.h, fNumCells.v);		if PtInRect(cell, r) then			SetSelectionPoint(cell);	end;	procedure TPalette.Draw;		var			i, row, col, cellNum, mode: integer;			srcRect, dstRect: Rect;			srcBits: BitMap;			icon: Handle;			cell: Point;			thePort: GrafPtr;	begin		for i := 1 to fNumCells.h - 1 do begin				MoveTo(i * (fCellSize.h + 1) - 1, 0);				Line(0, fNumCells.v * (fCellSize.v + 1) - 1);			end;		for i := 1 to fNumCells.v - 1 do begin				MoveTo(0, i * (fCellSize.v + 1) - 1);				Line(fNumCells.h * (fCellSize.h + 1) - 1, 0);			end;		srcBits.rowBytes := 4;		SetRect(srcBits.bounds, 0, 0, 64, 64);		SetRect(srcRect, 0, 0, fCellSize.h, fCellSize.v);		for row := 0 to fNumCells.v - 1 do			for col := 0 to fNumCells.h - 1 do begin					SetPt(cell, col, row);					cellNum := PointToCellNum(cell);					icon := fCells^^[cellNum];					GetCellRect(cell, dstRect);					if icon = nil then						EraseRect(dstRect)					else begin							srcBits.baseAddr := icon^;							if (fSelection.h = col) & (fSelection.v = row) & CellEnabled(fSelection) then								mode := notSrcCopy							else								mode := srcCopy;							GetPort(thePort);							CopyBits(srcBits, thePort^.portBits, srcRect, dstRect, mode, nil);						end;				end;	end;	procedure TPalette.InvalCell (cell: Point);		var			r: Rect;	begin		GetCellRect(cell, r);		InvalidateRect(r);	end;	procedure TPalette.GetCellRect (cell: Point; var r: Rect);	begin		SetRect(r, 0, 0, fCellSize.h, fCellSize.v);		OffsetRect(r, cell.h * (fCellSize.h + 1), cell.v * (fCellSize.v + 1));	end;	procedure TPalette.InvertSelection;	begin		InvertCell(fSelection);	end;	procedure TPalette.InvertCell (cell: Point);		var			r: Rect;	begin		GetCellRect(cell, r);		InvertRect(r);	end;	procedure TPalette.CellNumToPoint (cellNum: integer; var cell: Point);	begin		SetPt(cell, cellNum mod fNumCells.h, cellNum div fNumCells.v);	end;	function TPalette.PointToCellNum (cell: Point): integer;	begin		PointToCellNum := cell.v * fNumCells.h + cell.h;	end;	procedure TPalette.SetEnableFlags (flagString: string);	begin		StuffHex(fEnableFlags^, Copy(flagString, 1, 2 * GetHandleSize(fEnableFlags)));		InvalCell(fSelection);	end;	procedure TPalette.EnableCell (col, row: integer; enable: boolean);		var			cell: Point;			bit: integer;			oldEnable: boolean;	begin		SetPt(cell, col, row);		bit := PointToCellNum(cell);		oldEnable := BitTst(fEnableFlags^, bit);		if oldEnable <> enable then begin				if enable then					BitSet(fEnableFlags^, bit)				else					BitClr(fEnableFlags^, bit);				if EqualPt(cell, fSelection) then					InvalCell(fSelection);			end;	end;	function TPalette.CellEnabled (cell: Point): boolean;		var			bit: integer;	begin		bit := PointToCellNum(cell);		CellEnabled := BitTst(fEnableFlags^, bit);	end;end.