unit UDA;{Methods of TDA}interface	uses		ObjIntf, UGoof;implementation	procedure TDA.IDA (itsSignature: OSType);	begin		IEvtHandler(nil);		gDA := self;		gDefaultTarget := self;		gTarget := self;		gHeadDocument := nil;		gCurrentFocus := nil;		gFrontWindow := nil;		gCurrentCursor := nil;		gCreator := itsSignature;		gNextDocNumber := 1;		gTempRgn := NewRgn;		InitDummyPort;		gDragBounds := gDummyPort^.portBits.bounds;		with gDCtlEntry^ do begin				gIDBase := -16384 + BitShift(abs(dCtlRefNum) - 1, 5);				gStdIDBase := gIDBase + 16;				gWindow := nil;			end;		with gDragBounds do			top := top + 20;		InsetRect(gDragBounds, 4, 4);		gMenu := GetMenu(gIDBase + daMenuID);		if gMenu <> nil then begin				gMenu^^.menuID := gDCtlEntry^.dCtlRefNum;				gDCtlEntry^.dCtlMenu := gMenu^^.menuID;				MakeCmdTable(1);				BuildCmdTableEntry(1, gMenu);				InsertMenu(gMenu, 0);				DrawMenuBar;			end;	end;	procedure TDA.ReOpen;	begin	end;	procedure TDA.Close;		var			junk: boolean;	begin		gAlreadyOpened := false;		while gHeadDocument <> nil do			repeat			until gHeadDocument.DoClose(true);	{Can't abort closing a desk acc, unfortunately!}		Free;	end;	procedure TDA.Harakiri;{Ritual self-closing. After doing this, must be VERY careful not to reference any globals}{or make any procedure or method calls, since entrails have been removed.}	begin{$IFC DAShell}		Close;		gDCtlEntry^.dCtlDriver := nil;	{Let DAShell know we're closed}{$ELSEC}		CloseDeskAcc(gDCtlEntry^.dCtlRefNum);{$ENDC}	end;	procedure TDA.Free;	begin		if gMenu <> nil then begin				DeleteMenu(gMenu^^.menuID);				DrawMenuBar;				ReleaseResource(Handle(gMenu));			end;	end;	procedure TDA.AccEvent (e: EventRecord);		var			code: integer;			wMgrWindow: WindowPtr;			refCon: longint;			window: TWindow;	begin		case e.what of			mouseDown: 				begin					code := FindWindow(e.where, wMgrWindow);					refCon := GetWRefCon(wMgrWindow);					if odd(refCon) then begin							window := TWindow(refCon - 1);							window.Content(e);						end;				end;			keyDown: 				gTarget.Key(e, chr(BAND(e.message, charCodeMask)));			activateEvt, updateEvt: 				begin					refCon := GetWRefCon(WindowPtr(e.message));					if odd(refCon) then begin							window := TWindow(refCon - 1);							case e.what of								activateEvt: 									if odd(e.modifiers) then										window.Activate(e)									else										window.Deactivate(e);								updateEvt: 									window.Update(e);							end;						end;				end;		end;	end;	procedure TDA.AccRun;	begin	{Override this}	end;	procedure TDA.AccCursor (e: EventRecord);	begin	{e is always a null event}		gTarget.Idle(e);	end;	procedure TDA.AccMenu (menuID, itemNo: integer);	begin		gTarget.DoMenuCommand(MenuItemToCmd(menuID, itemNo));	end;	procedure TDA.AccUndo;	begin		gTarget.DoMenuCommand(undoCmd);	end;	procedure TDA.AccCut;	begin		gTarget.DoMenuCommand(cutCmd);	end;	procedure TDA.AccCopy;	begin		gTarget.DoMenuCommand(copyCmd);	end;	procedure TDA.AccPaste;	begin		gTarget.DoMenuCommand(pasteCmd);	end;	procedure TDA.AccClear;	begin		gTarget.DoMenuCommand(clearCmd);	end;	procedure TDA.Idle (e: EventRecord);	begin		SetupCursor(e.where);	end;	procedure TDA.DoSetupMenus;	begin		if gMenu <> nil then begin				DisableAllItems(gMenu);				gTarget.SetupMenus;			end;	end;	procedure TDA.SetupMenus;	begin		EnableCmd(newCmd);		EnableCmd(openCmd);		inherited SetupMenus;	end;	procedure TDA.DoMenuCommand (cmdNumber: integer);	begin		case cmdNumber of			newCmd: 				DoNew;			openCmd: 				DoOpen;			otherwise				inherited DoMenuCommand(cmdNumber);		end;	end;	procedure TDA.DoNew;		var			document: TDocument;	begin		document := MakeOwnDocument;		document.DoNew;		document.MakeWindow;	end;	procedure TDA.DoOpen;		var			document: TDocument;	begin		document := MakeOwnDocument;		if document.DoOpen then			document.MakeWindow;	end;	function TDA.MakeOwnDocument: TDocument;	begin	{Override this}		Panic('TDA.MakeOwnDocument', 'Not overridden');	end;end.