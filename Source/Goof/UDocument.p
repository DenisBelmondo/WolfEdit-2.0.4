unit UDocument;interface	uses		ObjIntf, UGoof;implementation	procedure TDocument.IDocument (itsFileType: OSType);	begin		IEvtHandler(gDefaultTarget);		fNextDocument := gHeadDocument;		gHeadDocument := self;		fHeadWindow := nil;		fChanged := false;		fFileType := itsFileType;		fHasFile := false;		fVRefNum := 0;		fFileName := MakeDefaultName;	end;	procedure TDocument.Free;		var			docBefore: TDocument;	begin		DisposeContents;		while fHeadWindow <> nil do			fHeadWindow.Free;		if gHeadDocument = self then			gHeadDocument := fNextDocument		else begin				docBefore := gHeadDocument;				while docBefore.fNextDocument <> self do					docBefore := docBefore.fNextDocument;				docBefore.fNextDocument := fNextDocument;			end;		inherited Free;	end;	procedure TDocument.DisposeContents;	begin	{Override this}	end;	procedure TDocument.MakeWindow;		var			view: TView;	begin		view := MakeOwnView;		if view <> nil then			view.MakeOwnWindow;	end;	function TDocument.MakeOwnView;	begin	{You must override this if you use MakeWindow}		Panic('TDocument.MakeOwnView', 'Not overridden');	end;	procedure TDocument.AddWindow (winToAdd: TWindow);	begin		winToAdd.fNextWindow := fHeadWindow;		fHeadWindow := winToAdd;		winToAdd.fNextHandler := self;	end;	procedure TDocument.RemoveWindow (winToRemove: TWindow);		var			winBefore: TWindow;	begin		if fHeadWindow = winToRemove then			fHeadWindow := winToRemove.fNextWindow		else begin				winBefore := fHeadWindow;				while winBefore.fNextWindow <> winToRemove do					winBefore := winBefore.fNextWindow;				winBefore.fNextWindow := winToRemove.fNextWindow;			end;		if winToRemove.fNextHandler = self then			winToRemove.fNextHandler := gDefaultTarget;	end;	procedure TDocument.EachWindowDo (procedure DoToWin (win: TWindow));		var			window: TWindow;	begin		window := fHeadWindow;		while window <> nil do begin				DoToWin(window);				window := window.fNextWindow;			end;	end;	procedure TDocument.SetupMenus;	begin		EnableCmd(closeCmd);		if fChanged then			EnableCmd(saveCmd);		EnableCmd(saveAsCmd);		if fHasFile and fChanged then			EnableCmd(revertCmd);		inherited SetupMenus;	end;	procedure TDocument.DoMenuCommand (cmdNumber: integer);		var			succeeded: boolean;	begin		case cmdNumber of			closeCmd: 				succeeded := DoClose(false);			saveCmd: 				succeeded := DoSave;			saveAsCmd: 				succeeded := DoSaveAs;			revertCmd: 				DoRevert;			otherwise				inherited DoMenuCommand(cmdNumber);		end;	end;	procedure TDocument.DoNew;	begin	{Override this to create empty document}	end;	function TDocument.DoOpen: boolean;		var			where: Point;			typeList: SFTypeList;			numTypes: integer;			reply: SFReply;			succeeded, failed: boolean;	begin		SetPt(where, 100, 75);		typeList[0] := fFileType;		numTypes := 1;		AugmentFileTypes(numTypes, typeList);		SFGetFile(where, '', nil, numTypes, typeList, nil, reply);		if reply.good then begin				HaveFile(reply.vRefNum, reply.fName);				succeeded := Read;			end		else			succeeded := false;		failed := not succeeded;		if failed then begin				Free;			end;		DoOpen := succeeded;	end;	function TDocument.DoClose (quitting: boolean): boolean;		var			item: integer;			succeeded: boolean;			id: integer;	begin		if fChanged then begin				ParamText(fFileName, '', '', '');				if quitting then					id := saveBeforeQuittingAlertID				else					id := saveBeforeClosingAlertID;				item := Ask(gStdIDBase + id);				case item of					yes: 						succeeded := DoSave;					no: 						succeeded := true;					cancel: 						succeeded := false;				end;			end		else			succeeded := true;		if succeeded then			Free;		DoClose := succeeded;	end;	function TDocument.DoSave: boolean;		var			succeeded: boolean;	begin		if fHasFile then			succeeded := Write		else			succeeded := DoSaveAs;		DoSave := succeeded;	end;	function TDocument.DoSaveAs: boolean;		var			where: Point;			reply: SFReply;			defaultName: Str255;			prompt: StringHandle;	begin		SetPt(where, 100, 75);		if fHasFile then			defaultName := fFileName		else			defaultName := '';		prompt := GetString(gStdIDBase + saveAsPromptStrID);		ParamText(fFileName, '', '', '');		SFPutFile(where, prompt^^, defaultName, nil, reply);		if reply.good then begin				HaveFile(reply.vRefNum, reply.fName);				DoSaveAs := Write;			end		else			DoSaveAs := false;	end;	procedure TDocument.DoRevert;		var			item: integer;			succeeded: boolean;		procedure TellToInvalidate (window: TWindow);		begin			window.Invalidate;		end;	begin		ParamText(fFileName, '', '', '');		item := Ask(gStdIDBase + revertAlertID);		if item = ok then begin				succeeded := Read;				if succeeded then					EachWindowDo(TellToInvalidate)				else					Free;			end;	end;	function TDocument.Read: boolean;		var			refNum, oldResFile, resFile, result: integer;			fileName: Str255;		procedure Check (result: OSErr);		begin			if result <> noErr then begin					if result <> suppressErr then						ErrorAlert(gStdIDBase + couldntOpenAlertID, fFileName, result);					if resFile <> -1 then						CloseResFile(resFile);					if refNum <> 0 then						result := FSClose(refNum);					DisposeContents;					UseResFile(oldResFile);					Read := false;					exit(Read);				end;		end;	begin		oldResFile := CurResFile;		resFile := -1;		DisposeContents;		fChanged := false;		refNum := 0;		Check(SetVol(nil, fVRefNum));		fileName := fFileName;		Check(FSOpen(fileName, fVRefNum, refNum));		resFile := OpenResFile(fileName);		if resFile <> -1 then			UseResFile(resFile);		Check(ReadFromFile(refNum));		if resFile <> -1 then			CloseResFile(resFile);		result := FSClose(refNum);		refNum := 0;		Check(result);		fChanged := false;		UseResFile(oldResFile);		Read := true;	end;	function TDocument.Write: boolean;		var			refNum, item, resFile, oldResFile: integer;			oldFInfo, newFInfo: FInfo;			fileName, scratchName: Str255;			result: OSErr;			fileExists, gotFInfo: boolean;			spaceUsed, spaceFree, spaceNeeded, dataBytes, rsrcBytes: longint;			param: ParamBlockRec;			ticks: Str255;		procedure Abort;		begin			if resFile <> -1 then				CloseResFile(resFile);			if refNum <> 0 then				result := FSClose(refNum);			UseResFile(oldResFile);			Exit(Write);			Write := false;		end;		procedure Check (result: OSErr);		begin			if result <> noErr then begin					if result <> suppressErr then						ErrorAlert(gStdIDBase + couldntSaveAlertID, fileName, result);					Abort;				end;		end;	begin		oldResFile := CurResFile;		resFile := -1;		refNum := 0;		fileName := fFileName;		ParamText(fileName, '', '', '');		with param do begin				ioNamePtr := @fileName;				ioVRefNum := fVRefNum;				ioFVersNum := 0;				ioFDirIndex := 0;			end;		result := PBGetFInfo(@param, false);		if result = fnfErr then begin				fileExists := false;				gotFInfo := false;				spaceUsed := 0;			end		else begin				Check(result);				fileExists := true;				gotFInfo := true;				oldFInfo := param.ioFlFndrInfo;				spaceUsed := param.ioFlPyLen + param.ioFlRPyLen;			end;		NumToString(TickCount, ticks);		scratchName := concat(gCreator, '_', ticks);		fScratchName := scratchName;		Check(GetDiskSpaceNeeded(dataBytes, rsrcBytes));		spaceNeeded := dataBytes + rsrcBytes;		with param do begin				ioNamePtr := nil;				ioVRefNum := fVRefNum;				ioVolIndex := 0;			end;		Check(PBGetVInfo(@param, false));		spaceFree := param.ioVFrBlk * param.ioVAlBlkSiz;		if spaceNeeded > spaceFree then begin				if spaceNeeded <= spaceFree + spaceUsed then begin						item := Ask(gStdIDBase + deleteOldFileAlertID);						if item = cancel then							Abort;						if item = yes then begin								Check(FSDelete(fileName, fVRefNum));								fileExists := false;							end;					end				else begin						DoAlert(gStdIDBase + diskFullAlertID);						Abort;					end;			end;		Check(SetVol(nil, fVRefNum));		Check(Create(scratchName, fVRefNum, gCreator, fFileType));		if gotFInfo then begin				Check(GetFInfo(scratchName, fVRefNum, newFInfo));				newFInfo.fdFlags := oldFInfo.fdFlags;				newFInfo.fdLocation := oldFInfo.fdLocation;				Check(SetFInfo(scratchName, fVRefNum, newFInfo));			end;		Check(FSOpen(scratchName, fVRefNum, refNum));		if rsrcBytes > 0 then begin				CreateResFile(scratchName);				Check(ResError);				resFile := OpenResFile(scratchName);				UseResFile(resFile);			end;		Check(WriteToFile(refNum));		if resFile <> -1 then begin				CloseResFile(resFile);				resFile := -1;				Check(ResError);			end;		result := FSClose(refNum);		refNum := 0;		Check(result);		if fileExists then			Check(FSDelete(fileName, fVRefNum));		Check(Rename(scratchName, fVRefNum, fileName));		fChanged := false;		UseResFile(oldResFile);		Write := true;	end;	procedure TDocument.HaveFile (itsVRefNum: integer; itsFileName: string);		procedure TellToUpdateTitle (window: TWindow);		begin			window.UpdateTitle;		end;	begin		fHasFile := true;		fVRefNum := itsVRefNum;		fFileName := itsFileName;		EachWindowDo(TellToUpdateTitle);	end;	procedure TDocument.AugmentFileTypes (var numTypes: integer; var typeList: SFTypeList);	begin	{Override this if you want}	end;	function TDocument.ReadFromFile (refNum: integer): OSErr;	begin	{Override this}	end;	function TDocument.WriteToFile (refNum: integer): OSErr;	begin	{Override this}	end;	function TDocument.GetDiskSpaceNeeded (var dataBytes, rsrcBytes: longint): OSErr;	begin	{Override this}		dataBytes := 0;		rsrcBytes := 0;		GetDiskSpaceNeeded := noErr;	end;	procedure TDocument.Changed;	begin		fChanged := true;	end;	function TDocument.MakeDefaultName: Str255;		var			num: Str255;	begin		NumToString(gNextDocNumber, num);		MakeDefaultName := concat('Untitled-', num);		gNextDocNumber := gNextDocNumber + 1;	end;end.