unit UWindow;{Methods of TWindow}interface	uses		ObjIntf, UGoof;implementation	procedure TWindow.IWindow (itsDocument: TDocument; itsWMgrWindow: WindowPtr; itsOptions: WindowOptions; disposeFlag: boolean);		var			r: Rect;	begin		SetRect(r, 0, 0, 0, 0);		IFrame(nil, r, []);		fDocument := itsDocument;		fWindow := self;		fTarget := self;		fDisposeWindow := disposeFlag;		fCanResize := wGrowBox in itsOptions;		fCloseOnGoAway := wCloseOnGoAway in itsOptions;		if fDocument <> nil then			fDocument.AddWindow(self);		with gDragBounds do			SetRect(fGrowBounds, 40, 30, right - left, bottom - top);		fWMgrWindow := itsWMgrWindow;		fControls := WindowPeek(fWMgrWindow)^.controlList;		SetWRefCon(fWMgrWindow, longint(self) + 1);{$IFC DA}		WindowPeek(fWMgrWindow)^.windowKind := gDCtlEntry^.dCtlRefNum;{$ENDC}		UpdateTitle;		ResetBounds;	end;	procedure TWindow.INewWindow (itsDocument: TDocument; boundsRect: Rect; title: Str255; procID: integer; itsOptions: WindowOptions);		var			wMgrWindow: WindowPtr;	begin		wMgrWindow := NewWindow(nil, boundsRect, title, wVisible in itsOptions, procID, WindowPtr(-1), wGoAwayBox in itsOptions, 0);		IWindow(itsDocument, wMgrWindow, itsOptions, true);	end;	procedure TWindow.IGetNewWindow (itsDocument: TDocument; itsRsrcID: integer; itsOptions: WindowOptions);		var			wMgrWindow: WindowPtr;	begin		wMgrWindow := GetNewWindow(itsRsrcID, nil, WindowPtr(-1));		if wMgrWindow = nil then			Panic('TWindow.IGetNewWindow', StringOf('Couldn''t get WIND ', itsRsrcID : 1, ' (error number ', ResError : 1, ')'));		IWindow(itsDocument, wMgrWindow, itsOptions, false);	end;	procedure TWindow.IGetNewCWindow (itsDocument: TDocument; itsRsrcID: integer; itsOptions: WindowOptions);		var			wMgrWindow: WindowPtr;	begin		wMgrWindow := GetNewCWindow(itsRsrcID, nil, WindowPtr(-1));		if wMgrWindow = nil then			Panic('TWindow.IGetNewWindow', StringOf('Couldn''t get WIND ', itsRsrcID : 1, ' (error number ', ResError : 1, ')'));		IWindow(itsDocument, wMgrWindow, itsOptions, false);	end;	procedure TWindow.Free;		var			win: WindowPtr;	begin		if fDocument <> nil then			fDocument.RemoveWindow(self);		if gFrontWindow = self then			gFrontWindow := nil;		inherited Free;	end;	procedure TWindow.DisposeWMgrWindow;	begin		if fDisposeWindow then			DisposeWindow(fWMgrWindow)		else			CloseWindow(fWMgrWindow);	end;	procedure TWindow.SetTitle (title: string);	begin		SetWTitle(fWMgrWindow, title);	end;	procedure TWindow.GetTitle (var title: string);		var			s: Str255;	begin		GetWTitle(fWMgrWindow, s);		title := s;	end;	procedure TWindow.UpdateTitle;		var			title: Str255;	begin		if fDocument <> nil then			SetTitle(fDocument.fFileName);	end;	procedure TWindow.ContainerToLocal (var pt: Point);	begin		Focus;		GlobalToLocal(pt);	end;	procedure TWindow.Drag (var e: EventInfo);	begin		DragWindow(fWMgrWindow, e.where, gDragBounds);	end;	procedure TWindow.Grow (var e: EventInfo);		var			result: longint;		procedure InvalGrowBox;			var				r: Rect;		begin			Focus;			r := fWMgrWindow^.portRect;			with r do begin					r.left := r.right - 15;					r.top := r.bottom - 15;				end;			InvalRect(r);		end;	begin		if fCanResize then begin				result := GrowWindow(fWMgrWindow, e.where, fGrowBounds);				if result <> 0 then begin						InvalGrowBox;						Size(LoWord(result), HiWord(result));						InvalGrowBox;					end;			end;	end;	procedure TWindow.GoAway;	begin		if TrackGoAway(fWMgrWindow, gLastEvent.where) then			if fCloseOnGoAway then				DoMenuCommand(closeCmd)			else				Hide;	end;	procedure UpdateGrowIcon (wMgrWindow: WindowPtr);		var			r: Rect;	begin		r := wMgrWindow^.portRect;		with r do begin				left := right - 15;				top := bottom - 15;			end;		ClipRect(r);		DrawGrowIcon(wMgrWindow);		ClipRect(wMgrWindow^.portRect);	end;	procedure TWindow.Zoom (partCode: integer);		var			oldSize, newSize: Point;		procedure TellToResize (frame: TFrame);		begin			frame.ContainerResized(oldSize, newSize);		end;	begin		Focus;		EraseRect(fWMgrWindow^.portRect);		oldSize := fWMgrWindow^.portRect.botRight;		ZoomWindow(fWMgrWindow, partCode, true);		newSize := fWMgrWindow^.portRect.botRight;		EachFrameDo(TellToResize);	end;{$IFC FALSE}	function TitleOfWindow (w: TWindow): string;		var			s: string;	begin		if w <> nil then			w.GetTitle(s)		else			s := 'nil';		TitleOfWindow := s;	end;{$ENDC}{$IFC FALSE}	function NameOfTarget (t: TEvtHandler): string;	begin		if member(t, TFrame) then			NameOfTarget := TitleOfWindow(TWindow(t).fWindow)		else if t = gDefaultTarget then			NameOfTarget := 'gDefaultTarget'		else			NameOfTarget := StringOf('TEvtHandler#', longint(t) : 1);	end;{$ENDC}	procedure TWindow.Activate;	begin{$IFC FALSE}		writeln('Activate ', TitleOfWindow(self)); {***}		writeln('  gFrontWindow = ', TitleOfWindow(gFrontWindow));		writeln('  fTarget = ', NameOfTarget(fTarget));{$ENDC}		gFrontWindow := self;		inherited Activate;		if fCanResize then begin				Focus;				UpdateGrowIcon(fWMgrWindow);			end;		fTarget.BecomeTarget;	end;	procedure TWindow.Deactivate;	begin{$IFC FALSE}		writeln('Deactivate ', TitleOfWindow(self)); {***}		writeln('  gFrontWindow = ', TitleOfWindow(gFrontWindow));		writeln('  gTarget = ', NameOfTarget(gTarget));{$ENDC}		if gFrontWindow = self then begin				fTarget := gTarget;				gDefaultTarget.BecomeTarget;			end;		if fCanResize then begin				Focus;				UpdateGrowIcon(fWMgrWindow);			end;		inherited Deactivate;		gFrontWindow := nil;	end;	procedure TWindow.Update;		var			r: Rect;	begin		BeginUpdate(fWMgrWindow);		if fCanResize then begin				Focus;				UpdateGrowIcon(fWMgrWindow);				r := thePort^.portRect;				r.left := r.right - 15;				r.top := r.bottom - 15;				RectRgn(gTempRgn, r);				DiffRgn(thePort^.clipRgn, gTempRgn, thePort^.clipRgn);			end;		inherited Update;		EndUpdate(fWMgrWindow);	end;	procedure TWindow.Focus;	begin		if not InFocus then begin				SetPort(fWMgrWindow);				WindowPeek(fWMgrWindow)^.controlList := fControls;				SetOrigin(fScrollOffset.h, fScrollOffset.v);				PenNormal;				ClipRect(fWMgrWindow^.portRect);				gCurrentFocus := self;			end;	end;	procedure TWindow.Select;	begin		SelectWindow(fWMgrWindow);		Show;	end;	procedure TWindow.Show;	begin		ShowWindow(fWMgrWindow);	end;	procedure TWindow.Hide;	begin		HideWindow(fWMgrWindow);	end;	procedure TWindow.Close;		var			succeeded: boolean;	begin		if (fDocument <> nil) & (fDocument.fHeadWindow.fNextWindow = nil) then			succeeded := fDocument.DoClose(false)		else			Free;	end;	procedure TWindow.Move (hGlobal, vGlobal: integer);	begin		Move3(hGlobal, vGlobal, true);	end;	procedure TWindow.Move3 (hGlobal, vGlobal: integer; front: boolean);	begin		MoveWindow(fWMgrWindow, hGlobal, vGlobal, front);		ResetBounds;	end;	procedure TWindow.Size (w, h: integer);	begin		Size3(w, h, true);	end;	procedure TWindow.Size3 (w, h: integer; fUpdate: boolean);		var			oldSize, newSize: Point;		procedure TellToResize (frame: TFrame);		begin			frame.ContainerResized(oldSize, newSize);		end;	begin		Focus;		oldSize := fWMgrWindow^.portRect.botRight;		SizeWindow(fWMgrWindow, w, h, fUpdate);		Focus;		newSize := fWMgrWindow^.portRect.botRight;		EachFrameDo(TellToResize);	end;	procedure TWindow.PlaceBehind (behindWindow: TWindow);		var			behindWMgrWindow: WindowPtr;	begin		if behindWindow <> nil then			behindWMgrWindow := behindWindow.fWMgrWindow		else			behindWMgrWindow := nil;		SendBehind(fWMgrWindow, behindWMgrWindow);	end;	procedure TWindow.SetBounds (newBounds: Rect);	begin		with newBounds do begin				Move3(left, top, false);				Size3(right - left, bottom - top, false);			end;		ResetBounds;	end;	function TWindow.Visible: boolean;	begin		Visible := ord(WindowPeek(fWMgrWindow)^.visible) <> 0;	end;{Install a handle to a WDEF function, preserving the old}{variation code in the high byte of the handle}	procedure TWindow.InstallWDEF (newWDEF: Handle);		var			oldHighByte: longint;			wp: WindowPeek;	begin		wp := WindowPeek(fWMgrWindow);		oldHighByte := BAND(wp^.windowDefProc, $FF000000);		newWDEF := Handle(BAND(newWDEF, $00FFFFFF));		wp^.windowDefProc := Handle(BOR(oldHighByte, newWDEF));	end;	procedure TWindow.ResetBounds;		var			r: Rect;			oldPort: GrafPtr;	begin		GetPort(oldPort);		SetPort(fWMgrWindow);		r := fWMgrWindow^.portRect;		LocalToGlobal(r.topLeft);		LocalToGlobal(r.botRight);		SetPort(oldPort);		fBounds := r;	end;	procedure TWindow.SetGrowBounds (newGrowBounds: Rect);	begin		fGrowBounds := newGrowBounds;	end;	procedure TWindow.Invalidate;	begin		Focus;		InvalRect(fWMgrWindow^.portRect);	end;	procedure TWindow.SetTarget (newTarget: TEvtHandler);	begin		if gFrontWindow = self then			newTarget.BecomeTarget;		fTarget := newTarget;	end;	procedure TWindow.SetupMenus;	begin		if WindowPeek(fWMgrWindow)^.goAwayFlag then			EnableCmd(closeCmd);		inherited SetupMenus;	end;	procedure TWindow.DoMenuCommand (cmdNumber: integer);	begin		case cmdNumber of			closeCmd: 				Close;			otherwise				inherited DoMenuCommand(cmdNumber);		end;	end;	procedure TWindow.DefaultPosition;		var			bounds: Rect;			vhs: VHSelect;			correction: Point;	begin		bounds := fBounds;		SubPt(bounds.topLeft, bounds.botRight);		with gWinPosRec do begin				bounds.topLeft := theNextPos;	{$IFC FALSE}				bounds.botRight := gDragBounds.botRight;				SubPt(theLimits.botRight, bounds.botRight);				AddPt(bounds.topLeft, bounds.botRight);	{$ENDC}				AddPt(theIncrement, theNextPos);				SetPt(correction, 0, 0);				for vhs := v to h do begin						if theNextPos.vh[vhs] < theLimits.topLeft.vh[vhs] then							correction.vh[vhs] := LengthRect(theLimits, vhs)						else if theNextPos.vh[vhs] > theLimits.botRight.vh[vhs] then							correction.vh[vhs] := -LengthRect(theLimits, vhs);					end;				AddPt(correction, theNextPos);			end;		if not PtInRect(gWinPosRec.theNextPos, gWinPosRec.theLimits) then			Panic('TWindow.DefaultPosition', 'theNextPos stuffed up.');		AddPt(bounds.topLeft, bounds.botRight);		SetBounds(bounds);	end;end.