unit UList;interface	uses		ObjIntf, UGoof;	type		ListOption = (listMultiSel, listMarquee, listAnimate, listDummy);		ListOptions = set of ListOption;		TList = object(TView)				fCellSize: Point;				fBorderSize: Point;				fDimensions: Rect;				fOptions: ListOptions;				fSelection: Rect;				fSelectionHilited: boolean;		{Initialise/Free}				procedure TList.IList (cellWidth, cellHeight, cellsWide, cellsHigh, borderSize: integer; options: ListOptions);				procedure TList.IListX (itsCellSize: Point; itsBorderSize: Point; itsDimensions: Rect; itsOptions: ListOptions);		{Accessing}				procedure TList.SetCellSize (width, height: integer);				procedure TList.SetBorderSize (width, height: integer);				procedure TList.SetDimensions (left, top, right, bottom: integer);				procedure TList.SetDimensionRect (newDim: Rect);				procedure TList.SetSelection (left, top, right, bottom: integer);				procedure TList.SetSelectionRect (newSel: Rect);				procedure TList.ClearSelection;		{Calculations}				procedure TList.CellToPt (cell: Point; var p: Point);				procedure TList.CellToRect (cell: Point; var r: Rect);				procedure TList.CellToCells (cell: Point; var cells: Rect);				procedure TList.CellsToRect (cells: Rect; var r: Rect);				function TList.FindCell (pt: Point; var cell: Point): boolean;				function TList.FindCells (r: Rect; var cells: Rect): boolean;		{Updating}				procedure TList.InvalidateCells (cells: Rect);				procedure TList.InvalidateCell (cell: Point);				procedure TList.UpdateCell (cell: Point);				procedure TList.Update;		{Behaviour}				procedure TList.DoubleClick (var e: EventInfo);				procedure TList.DrawCell (cell: Point; r: Rect; var hilite: boolean);		{Default Behaviour}				procedure TList.ChangeHilite (oldCells, newCells: Rect);				procedure TList.ChangeCellsHilite (cells: Rect; hilite: boolean);				procedure TList.ChangeCellHilite (cell: Point; hilite: boolean);				procedure TList.DrawMarquee (cells: Rect; hilite: boolean);				procedure TList.DrawBorder (vh: VHSelect; rowOrCol: integer; r: Rect);		{Private}				procedure TList.Activate;				override;				procedure TList.Deactivate;				override;				procedure TList.HiliteSelection (entering: boolean);				override;				procedure TList.Click (var e: EventInfo);				override;				procedure TList.NewSelection (var e: EventInfo);				procedure TList.ExtendSelection (var e: EventInfo);				procedure TList.ModifySelection (var e: EventInfo);				procedure TList.Draw;				override;				procedure TList.RecalcExtent;			end;implementation	const		listMarqueePatListID = 0;	procedure TList.IList (cellWidth, cellHeight, cellsWide, cellsHigh, borderSize: integer; options: ListOptions);		var			cellSize, border: Point;			dimensions: Rect;	begin		SetPt(cellSize, cellWidth, cellHeight);		SetPt(border, borderSize, borderSize);		SetRect(dimensions, 0, 0, cellsWide, cellsHigh);		IListX(cellSize, border, dimensions, options);	end;	procedure TList.IListX (itsCellSize: Point; itsBorderSize: Point; itsDimensions: Rect; itsOptions: ListOptions);		var			extent: Rect;	begin		fCellSize := itsCellSize;		fBorderSize := itsBorderSize;		fDimensions := itsDimensions;		CellsToRect(itsDimensions, extent);		IView(nil, nil, extent);		fOptions := itsOptions;		fSelectionHilited := false;	end;	procedure TList.Activate;	begin		HiliteSelection(true);	end;	procedure TList.Deactivate;	begin		HiliteSelection(false);	end;	procedure TList.HiliteSelection (entering: boolean);		var			empty: Rect;	begin		if entering <> fSelectionHilited then begin				if not EmptyRect(fSelection) then begin						SetRect(empty, 0, 0, 0, 0);						if entering then							ChangeHilite(empty, fSelection)						else							ChangeHilite(fSelection, empty);					end;				fSelectionHilited := entering;			end;	end;	procedure TList.ChangeHilite (oldCells, newCells: Rect);		var			bounds, both: Rect;			cell: Point;			row, col: integer;	begin		if listMarquee in fOptions then begin				ChangeCellsHilite(oldCells, false);				ChangeCellsHilite(newCells, true);			end		else begin				if EmptyRect(oldCells) then					bounds := newCells				else if EmptyRect(newCells) then					bounds := oldCells				else					UnionRect(oldCells, newCells, bounds);				if SectRect(oldCells, newCells, both) then					;				for row := bounds.top to bounds.bottom - 1 do					for col := bounds.left to bounds.right - 1 do begin							SetPt(cell, col, row);							if not PtInRect(cell, both) then begin									if PtInRect(cell, oldCells) then										ChangeCellHilite(cell, false)									else if PtInRect(cell, newCells) then										ChangeCellHilite(cell, true);								end;						end;			end;	end;	procedure TList.ChangeCellsHilite (cells: Rect; hilite: boolean);		var			cell: Point;			row, col: integer;	begin		if listMarquee in fOptions then			DrawMarquee(cells, hilite)		else			for row := cells.top to cells.bottom - 1 do				for col := cells.left to cells.right - 1 do begin						SetPt(cell, col, row);						ChangeCellHilite(cell, hilite);					end;	end;	procedure TList.ChangeCellHilite (cell: Point; hilite: boolean);		var			cells, r: Rect;	begin		if listMarquee in fOptions then begin				CellToCells(cell, cells);				DrawMarquee(cells, hilite);			end		else begin				CellToRect(cell, r);				Focus;				InvertRect(r);			end;	end;	procedure TList.DrawMarquee (cells: Rect; hilite: boolean);		var			pat: Pattern;			r: Rect;	begin		Focus;		if hilite then			GetIndPattern(pat, gStdIDBase + listMarqueePatListID, 1)		else			pat := black;		CellsToRect(cells, r);		InsetRect(r, -fBorderSize.h, -fBorderSize.v);		PenNormal;		PenSize(fBorderSize.h, fBorderSize.v);		PenPat(pat);		FrameRect(r);	end;{$IFC FALSE}	procedure TList.ChangeHilite (oldCells, newCells: Rect);		var			r1, r2: Rect;			rgn1, rgn2: RgnHandle;	begin		rgn1 := NewRgn;		rgn2 := NewRgn;		CellsToRect(oldCells, r1);		CellsToRect(newCells, r2);		RectRgn(rgn1, r1);		RectRgn(rgn2, r2);		XorRgn(rgn1, rgn2, rgn2);		Focus;		InvertRgn(rgn2);		DisposeRgn(rgn1);		DisposeRgn(rgn2);	end;{$ENDC}	procedure TList.SetCellSize (width, height: integer);	begin		SetPt(fCellSize, width, height);		RecalcExtent;	end;	procedure TList.SetBorderSize (width, height: integer);	begin		SetPt(fBorderSize, width, height);		RecalcExtent;	end;	procedure TList.SetDimensions (left, top, right, bottom: integer);		var			r: Rect;	begin		SetRect(r, left, top, right, bottom);		SetDimensionRect(r);	end;	procedure TList.SetDimensionRect (newDim: Rect);		var			r: Rect;			b: boolean;	begin		fDimensions := newDim;		CellsToRect(fDimensions, r);		SetExtent(r);		b := SectRect(fDimensions, fSelection, fSelection);	end;	procedure TList.SetSelection (left, top, right, bottom: integer);		var			r: Rect;	begin		SetRect(r, left, top, right, bottom);		SetSelectionRect(r);	end;	procedure TList.SetSelectionRect (newSel: Rect);		var			oldR, newR, sectR: Rect;	begin		if SectRect(fDimensions, newSel, newSel) then			;		if not EqualRect(fSelection, newSel) then begin				ChangeHilite(fSelection, newSel);				fSelection := newSel;			end;	end;	procedure TList.ClearSelection;		var			r: Rect;	begin		SetRect(r, 0, 0, 0, 0);		SetSelectionRect(r);	end;	procedure TList.CellsToRect (cells: Rect; var r: Rect);	begin		CellToPt(cells.topLeft, r.topLeft);		CellToPt(cells.botRight, r.botRight);		SubPt(fBorderSize, r.botRight);	end;	procedure TList.CellToRect (cell: Point; var r: Rect);	begin		CellToPt(cell, r.topLeft);		r.botRight := r.topLeft;		AddPt(fCellSize, r.botRight);	end;	procedure TList.CellToPt (cell: Point; var p: Point);		var			vh: VHSelect;	begin		for vh := v to h do			p.vh[vh] := cell.vh[vh] * (fCellSize.vh[vh] + fBorderSize.vh[vh]);	end;	function TList.FindCell (pt: Point; var cell: Point): boolean;		var			vh: VHSelect;	begin		for vh := v to h do			cell.vh[vh] := pt.vh[vh] div (fCellSize.vh[vh] + fBorderSize.vh[vh]);		FindCell := PtInRect(cell, fDimensions);	end;	procedure FindFurthestCorner (r, c1: Rect; var c2: Rect);		var			vh: VHSelect;	begin		UnionRect(r, c1, r);		c2 := r;		for vh := v to h do begin				if c1.botRight.vh[vh] - r.topLeft.vh[vh] > r.botRight.vh[vh] - c1.topLeft.vh[vh] then					c2.botRight.vh[vh] := c2.topLeft.vh[vh] + 1				else					c2.topLeft.vh[vh] := c2.botRight.vh[vh] - 1;			end;	end;	procedure TList.Click (var e: EventInfo);		var			curPt: Point;			initCell, curCell: Rect;	begin		if e.theNumClicks > 1 then			DoubleClick(e)		else if e.theShiftKey then			ExtendSelection(e)		else if e.theCmdKey then			ModifySelection(e)		else			NewSelection(e);	end;	procedure TList.CellToCells (cell: Point; var cells: Rect);	begin		cells.topLeft := cell;		cells.right := cells.left + 1;		cells.bottom := cells.top + 1;	end;	procedure TList.NewSelection (var e: EventInfo);		var			inBounds: boolean;			curCell: Point;			newSel: Rect;	begin		inBounds := FindCell(e.where, curCell);		if not PtInRect(curCell, fSelection) then begin				if inBounds then begin						CellToCells(curCell, newSel);						SetSelectionRect(newSel);						ExtendSelection(e);					end				else					ClearSelection;			end;	end;	procedure TList.ExtendSelection (var e: EventInfo);		var			inBounds: boolean;			curPt: Point;			curCell: Point;			initCorner, curCorner, newSel: Rect;	begin		if listMultiSel in fOptions then begin				inBounds := FindCell(e.where, curCell);				CellToCells(curCell, initCorner);				if not EmptyRect(fSelection) then					FindFurthestCorner(fSelection, initCorner, initCorner);				while true do begin						CellToCells(curCell, curCorner);						UnionRect(initCorner, curCorner, newSel);						inBounds := SectRect(newSel, fDimensions, newSel);						SetSelectionRect(newSel);						if not StillDown then							leave;						AutoScroll;						GetMouse(curPt);						inBounds := FindCell(curPt, curCell);					end;			end;	end;	procedure TList.ModifySelection (var e: EventInfo);		var			inBounds: boolean;			cell: Point;			newSel: Rect;	begin		inBounds := FindCell(e.where, cell);		if inBounds then			if PtInRect(cell, fSelection) then				ClearSelection			else begin					CellToCells(cell, newSel);					SetSelectionRect(newSel);				end;	end;	procedure TList.DoubleClick (var e: EventInfo);	begin	{Override this}	end;	procedure TList.Draw;		var			cells, bcells: Rect;			i, row, col: integer;			cell: Point;			r: Rect;			vh, hv: VHSelect;			hilite: boolean;	begin		EraseRect(thePort^.portRect);		SectRgn(thePort^.clipRgn, thePort^.visRgn, gTempRgn);		if FindCells(gTempRgn^^.rgnBBox, cells) then begin				for vh := v to h do begin						hv := VHSelect(1 - ord(vh));						if fBorderSize.vh[vh] > 0 then							for i := cells.topLeft.vh[vh] to cells.botRight.vh[vh] do begin									bcells.topLeft.vh[vh] := i;									bcells.topLeft.vh[hv] := cells.topLeft.vh[hv];									bcells.botRight.vh[vh] := i + 1;									bcells.botRight.vh[hv] := cells.botRight.vh[hv];									CellsToRect(bcells, r);									r.botRight.vh[vh] := r.topLeft.vh[vh];									r.topLeft.vh[vh] := r.botRight.vh[vh] - fBorderSize.vh[vh];									DrawBorder(hv, i, r);								end;					end;				begin				end;				for col := cells.left to cells.right - 1 do					for row := cells.top to cells.bottom - 1 do begin							SetPt(cell, col, row);							CellToRect(cell, r);							hilite := fSelectionHilited & not (listMarquee in fOptions) & PtInRect(cell, fSelection);							DrawCell(cell, r, hilite);							if hilite then								ChangeCellHilite(cell, true);						end;				if listMarquee in fOptions then begin						SetRect(r, 0, 0, 0, 0);						ChangeHilite(r, fSelection);					end;			end;	end;	procedure TList.DrawBorder (vh: VHSelect; rowOrCol: integer; r: Rect);	begin		FillRect(r, black);	end;	function TList.FindCells (r: Rect; var cells: Rect): boolean;		var			inBounds: boolean;			vhs: VHSelect;	begin		for vhs := v to h do			r.botRight.vh[vhs] := r.botRight.vh[vhs] + fCellSize.vh[vhs] + fBorderSize.vh[vhs] - 1;		inBounds := FindCell(r.topLeft, cells.topLeft);		inBounds := FindCell(r.botRight, cells.botRight);		FindCells := SectRect(cells, fDimensions, cells);	end;	procedure TList.DrawCell (cell: Point; r: Rect; var hilite: boolean);	begin	{Draw the cell. If hilite is true, the cell should be highlighted.}	{This routine can either do the highlighting itself and set hilite}	{to false, or leave it true in which case a default method of}	{highlighting will be applied.}	end;	procedure TList.InvalidateCells (cells: Rect);		var			r: Rect;	begin		CellsToRect(cells, r);		InvalidateRect(r);	end;	procedure TList.InvalidateCell (cell: Point);		var			r: Rect;	begin		CellToRect(cell, r);		InvalidateRect(r);	end;	procedure TList.UpdateCell (cell: Point);		var			r: Rect;			hilite: boolean;	begin		CellToRect(cell, r);		Focus;		EraseRect(r);		hilite := fSelectionHilited & PtInRect(cell, fSelection);		DrawCell(cell, r, hilite);	end;	procedure TList.Update;		var			win: WindowPtr;	begin		if (fFrame <> nil) & (fFrame.fWindow <> nil) then begin				Focus;				win := fFrame.fWindow.fWMgrWindow;				BeginUpdate(win);				Draw;				EndUpdate(win);			end;	end;	procedure TList.RecalcExtent;		var			extent: Rect;	begin		CellsToRect(fDimensions, extent);		SetExtent(extent);	end;end.