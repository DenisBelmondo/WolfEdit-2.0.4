unit UBigArt;interface	uses		UWolfDoc;	type		BigArtType = (titleArt, intermissionArt, getPsychedArt);	procedure EditBigArt (doc: TMapListDoc; which: BigArtType);implementation	uses		UXWindow, UPixMapView, ULZSS, UCTables, UMemory;	const		bigArtWindID = 133;		getPsychedWindID = 135;		titlePictBrgrID = 133;	type		TBigArtWindow = object(TXWindow)				fType: BigArtType;				fMapList: TMapListDoc;				fBrgrID: integer;				fWidth, fHeight: longint;				fArtView: TPixMapView;				procedure IBigArtWindow (itsDoc: TMapListDoc; itsType: BigArtType);				procedure InstallBrgr (brgr: Handle);				function Changed: boolean;				override;				function Flush: boolean;				override;				procedure UpdateTitle;				override;			end;	procedure TBigArtWindow.IBigArtWindow (itsDoc: TMapListDoc; itsType: BigArtType);		var			windID: integer;			cTabID: integer;			brgr: Handle;			cTab: CTabHandle;			r: Rect;			artView: TPixMapView;	begin		fType := itsType;		fMapList := itsDoc;		case fType of			titleArt:  begin					windID := bigArtWindID;					fWidth := 512;					fHeight := 384;					fBrgrID := 133;					cTabID := titleCTabID;				end;			intermissionArt:  begin					windID := bigArtWindID;					fWidth := 512;					fHeight := 384;					fBrgrID := 139;					cTabID := intermissionCTabID;				end;			getPsychedArt:  begin					windID := getPsychedWindID;					fWidth := 224;					fHeight := 56;					fBrgrID := 148;					cTabID := getPsychedCTabID;				end;		end;		IGetNewCWindow(itsDoc, windID, [wGrowBox, wCloseOnGoAway]);		r := fGrowBounds;		SetPt(r.botRight, fWidth + 16, fHeight + 16);		SetGrowBounds(r);		cTab := GetMapListCTab(itsDoc, cTabID);		new(artView);		artView.IPixMapView(fWidth, fHeight, cTab);		fArtView := artView;		DisposHandle(Handle(cTab));		Place(fArtView, nil, nil, 0, 0, fill, fill, [frmHScroll, frmVScroll, frmHResize, frmVResize, frmGrowBox]);		fArtView.fDocument := fMapList;		fTarget := fArtView;		brgr := fMapList.GetMiscBrgr(fBrgrID);		if brgr = nil then			brgr := GetResource('BRGR', fBrgrID);		if brgr <> nil then			InstallBrgr(brgr);	end;	procedure TBigArtWindow.InstallBrgr (brgr: Handle);		var			src, buf: Ptr;			bufSize: longint;	begin		HLock(brgr);		src := Ptr(longint(brgr^) + 4);		buf := GetPixBaseAddr(fArtView.fPixMap);		bufSize := fWidth * fHeight;		DLZSSX(src, buf, 4, bufSize);		HUnlock(brgr);		fArtView.fNonEmpty := true;	end;	function TBigArtWindow.Changed: boolean;	begin		Changed := fArtView.fChanged;	end;	function TBigArtWindow.Flush: boolean;		var			header: record					width, height: integer;				end;			buf: Ptr;			bufSize: longint;			brgr: Handle;	begin		if fArtView.fChanged then begin				brgr := nil;				if fArtView.fNonEmpty then begin						buf := GetPixBaseAddr(fArtView.fPixMap);						bufSize := fWidth * fHeight;						header.width := fWidth;						header.height := fHeight;						brgr := LZSSX(4, @header, 4, buf, bufSize, false);						if brgr = nil then begin								Flush := false;								exit(Flush);							end;						LongintPtr(brgr^)^ := bufSize + 4;					end;				fMapList.InstallMiscBrgr(brgr, fBrgrID);				fArtView.fChanged := false;			end;		Flush := true;	end;	procedure TBigArtWindow.UpdateTitle;		var			what: string;	begin		case fType of			titleArt: 				what := 'Title Screen';			getPsychedArt: 				what := 'Get Psyched';			intermissionArt: 				what := 'Intermission Background';		end;		SetTitle(concat(what, ' from ', fMapList.fFileName));	end;	procedure EditBigArt (doc: TMapListDoc; which: BigArtType);		var			win: TWindow;			baWin: TBigArtWindow;		procedure TestWindow (win: TWindow);		begin			if member(win, TBigArtWindow) then				if TBigArtWindow(win).fType = which then begin						win.Select;						exit(EditBigArt);					end;		end;	begin {EditBigArt}		doc.EachWindowDo(TestWindow);		if EnoughMemory($80000) then begin				new(baWin);				baWin.IBigArtWindow(doc, which);				baWin.Show;			end;	end;end.